<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, autumn" />
    <title>
        Life &amp;&amp; Study
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico" />
     
<link rel="stylesheet" href="/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Life && Study" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                Life &amp;&amp; Study
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            Life &amp;&amp; Study
        </a>
    </h1>
    <h2 class="desc">
        
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a href="https://github.com/cnawesome" target="_blank" rel="noopener">
                    Github
                </a>
            </li>
            
            <li>
                <a href="/null">
                    alei
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/categories/%E7%AE%97%E6%B3%95/">
            算法
        </a>
    </h4>
    
    
    <h2 class="post-title">
        概率论1.0
    </h2>
    <ul class="post-date">
        <li>
            2020-04-15
        </li>
        <li>
            alei
        </li>
    </ul>
    <div class="post-content">
        <h3 id="随机过程-random-process"><a href="#随机过程-random-process" class="headerlink" title="随机过程 random process"></a>随机过程 random process</h3><p>easiest random process ：伯努利过程 Bernoulli process</p>
<h3 id="伯努利过程：一直随机的抛一枚硬币-独立的"><a href="#伯努利过程：一直随机的抛一枚硬币-独立的" class="headerlink" title="伯努利过程：一直随机的抛一枚硬币,独立的"></a>伯努利过程：一直随机的抛一枚硬币,独立的</h3><p>independent</p>
<p>at each trials:<br>    $P(sucess) = P(X=1) = p$<br>    $P(failure) = P(X=0) = 1-p$</p>
<p>最简单的随机过程是把随机过程当做一串随机变量的随机序列</p>
<p>$x_1,x_2,x_3$的联合分布<br>    得这些随机变量的概率密度函数：$P_{x_1,x_2,x_3}=P_{x_1}P_{x_2}P_{x_3}$<br>        由于这些随机变量是独立的<br>小总结：随机过程只是随机变量的集合</p>
<p>例：<br><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/概率13：interarrival time.jpg" alt></p>
<p>经过一段实验时间遇见第一个1的时间，我们称为$T_{1}$<br>$T_{1}$的概率分布<br>    $p(T_{1}=t)=(1-p)^{t-1}p$,$t=1,2,3,…$<br>    符合几何分布<br>    $E[t_{1}]=1/p$<br>    $Var[t_{1}]=(1-p)/p^{2}$</p>
<p>一个伯努利实验加上一个伯努利试验可以成为新的一个伯努利试验</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>泊松分布是连续的伯努利过程版本</p>
<p>伯努利实验：<br>            每个间隔相当于一次实验<br>            1.每个间隔的概率是相同的<br>               2.每个间隔的概率是独立的<br>将时间轴使用插槽平等分割，每个时间槽都是独立的。不同长度的时间间隔也是相互独立的</p>
<p>伯努利过程在一个时间段使用一个个插槽，在插槽中用一个0,1表示时间是否发生，如果这个插槽是秒级的，或者毫秒级，越分越小，可以直接用时间段的没一点查看是否发生事件。这样，只需要知道在某个时间点是否发生该时间<br>如下式表达：<br><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/概率13：small interval.jpg" alt><br>$lim \frac{P(1,\delta)}{\delta}=\lambda$<br>这个$\lambda$ 我们称为到达率，或者过程的密度</p>
<p>$E(number of arrived,in [0,\delta])=\lambda \delta$</p>
<p>now,<br>我们有一个大的时间间隔t，我们用小的间隔delta来分割t，<br>能分割的个数$n=\frac{t}{\delta}$<br>又每个$\delta$的概率$p=\lambda \delta$,且不同的\delta间隔之间是独立的<br>近似可得一个伯努利过程<br>当$\delta$ 趋近于0时，使用伯努利实验的概率密度函数</p>
<p>得出泊松的伯努利过程<br>when $\delta$趋于0，n趋于无穷大</p>
<script type="math/tex; mode=display">p(k)=(n  choose  k)(\frac{\lambda t}{n})^{k}(1-\frac{\lambda t}{n})^{n-k}</script><p>由微积分得<script type="math/tex">(1-\frac{\lambda t}{n})^{n-k}=e^{-\lambda t}</script></p>
<script type="math/tex; mode=display">p(k,t)=(n  choose  k)(\frac{\lambda t}{n})^{k}e^{-\lambda t}</script><script type="math/tex; mode=display">E(N_{t})=\lambda t</script><script type="math/tex; mode=display">Var(N_{t})=\lambda t</script><p>—-         詹2020.7.14</p>
<p>泊松PMF:</p>
<script type="math/tex; mode=display">p(k,t)=\frac{(\lambda t)^{k}e^{-\lambda t}}{k!}</script><script type="math/tex; mode=display">k=0,1,2...</script><h4 id="分裂泊松分布"><a href="#分裂泊松分布" class="headerlink" title="分裂泊松分布"></a>分裂泊松分布</h4><p>在在一个泊松分布的随机变量变化轴的一点上可以选择多个其他的泊松分布轴。</p>
<h3 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h3><p>马尔科夫过程是随机过程的一类，建立在事件之间有依赖</p>
<p><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链.jpg" alt><br>马尔科夫通用框架：<br>$new state = f(old state,noise)$<br>一般表示一些系统或变量的演变</p>
<p><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链1.jpg" alt><br>为什么马尔科夫链成立？</p>
<p><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链2.jpg" alt></p>
<p>step状态上升同时没有下降：$p(1-q)$<br>step状态下降同时没有上升：$q(1-p)$<br>step状态上升后下降或没上升也每下降：$pq+(1-p)(1-q)$</p>
<p>assume $X_{0}$是状态0 ，$X_{n}$是状态n<br>$p_{31}$看做在state状态3条件下转换state状态1的条件概率<br>$p_{ij}=P(X_{n+1}=j|X_{n}=i)$</p>
<p>$p_{31}$的转换的概率不受它之前转换的概率的影响，如$p_{23}$是$p_{31}$的概率，$p_{31}$的概率不会受$p_{23}$影响<br>$p_{ij}=P(X_{n+1}=j|X_{n}=i,X_{n-1},X_{n-2},…,X_{0})$<br>之前的转换不影响之后的</p>
<p>马尔科夫链模型制作：<br>1.确定你的状态变量是什么，确定状态的概率<br>2.确定不同的状态，再确定状态转换的概率<br>3.确定转换概率</p>
<p>怎么使用马尔科夫模型？</p>
<p>需要该模型做预测<br>当你需要在这个模型中预测从某一状态到拧一个状态后，可能出现的状态是什么。</p>
<p>例，求下面的$p_{ij}$<br><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链3.jpg" alt><br>key recursion:<br>$r_{ij}=\sum_{k=1}^{n}r_{ik}(n-1)P_{kj}$</p>
<p>with random initial state:<br>$P(x_{n}=j)=\sum_{i=1}^{n}P(x_{0}=i)r_{ij}(n)$</p>
<p>马尔科夫模型的变量的状态会一直改变，但他的变量的概率到一定程度就会稳定。</p>
<p>如果马尔科夫链有周期性，他可能无法收敛</p>
<h5 id="回归和传输状态"><a href="#回归和传输状态" class="headerlink" title="回归和传输状态"></a>回归和传输状态</h5><p>回归状态：从某一状态出去，总是能有一条回来改状态的路径<br>传输状态：从该状态出去，无法再回到该状态，也称瞬态</p>
<p>从一个瞬态出发，最终会在一个回归态群，无法回到瞬态</p>
<p>有指向自己的传输过程一定不是周期性链</p>
<h5 id="稳定状态概率"><a href="#稳定状态概率" class="headerlink" title="稳定状态概率"></a>稳定状态概率</h5><p>马尔科夫链收敛定理：<br>判断一个马尔科夫链最终会成为稳态<br>1，只有一个大的回归态群<br>2，这个回归态群没有周期性</p>
<p>稳定态马尔科夫链的从i到j概率</p>
<p>平衡等式：</p>
<p>$r_{ij}(n)=\sum_{k}r_{ik}(n-1)P_{kj}$</p>
<p>take the limit as n-&gt;无穷大</p>
<p>$\pi_{j}=\sum_{k}\pi_{k}P_{kj}$ for all $j$</p>
<p>我们不难发现，0是这个等式的奇异解</p>
<p>addtional equation ：$\sum_{j}\pi_{j}=1$ </p>
<p>例：<br><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链2-1.jpg" alt><br>$\pi_{1}=\frac{2}{7} \pi_{2}=\frac{5}{7}$</p>
<h5 id="birth-death-process"><a href="#birth-death-process" class="headerlink" title="birth-death process"></a>birth-death process</h5><p>从状态零到一个有限整数状态n<br>特点：在中间人和一个状态i，都可以去前一个状态，自身状态或后一个状态<br>$\sum_{i}\pi_{i}=1$</p>
<p>special case : 假设 $p_{i}=p$,$q_{i}=q$ for all i<br>$\alpha=p/q$= load fatcor</p>
<p>$\pi_{i+1}=\pi_{i}\frac{p}{q}=\pi_{i}\alpha$ </p>
<p>得：<br>$\pi_{i}=\pi_{0}\alpha^{i}$<br>由$\sum_{i}\pi_{i}=1$得：<br>$\sum^{m}_{i=0}\pi_{0}p^{i}=1$<br>-&gt;</p>
<script type="math/tex; mode=display">\pi_{0}=\frac{1}{\sum^{m}_{i=0}p^{i}}</script><p>我们找到了$\pi_{0}$<br>assume p &lt; q and m 趋于无穷大<br>$\pi_{0}=1-\alpha$<br>$E(x_{n})=\frac{\alpha}{1-\alpha}$ </p>
<p>如何计算在n趋于无穷大时，稳态的的概率？</p>
<p>求解线性方程（平衡方程）系统和归一化方程:<br>    $\pi_{j}=\sum_{k}\pi_{k}P_{kj}$,$j=1,2…m$ ,$k+1=j$<br>    together with<br>    $\sum_{j}\pi_{j}=1$</p>
<p><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链3-1.jpg" alt></p>
<p>如图，当进程走到其中一个回归态链，整个稳态系统就会以该回归态的概率作为稳态的概率。<br>问题：怎么知道进程会走到那个回归态链中</p>
<p>进程持续越长，随机性越大，在过程的可能性大小差不多时，初始情况就越被忘记，这告诉我们什么时候才可以使用近似值$\pi$</p>
<p><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链3-2.jpg" alt></p>
<p>圆圈为村庄<br>电话线B，B越小越好</p>
<p>假设每个时刻打电话的人是随机的，整个过程服从泊松分布，时刻之间是独立的，打电话的人数也是独立的</p>
<p>泊松分布运行德连续时间也叫做持续时间。持续时间指数型随机变量也是连续型随机变量<br>不过目前研究离散情况下的马尔科夫链。</p>
<p>扩展马尔科夫链到连续性<br>该问题不采用连续化，而是将时间分开离散化<br>在一个足够小的时间间隔中，每一个状态的情况：<br><img src="/2020/04/15/%E6%A6%82%E7%8E%87%E8%AE%BA1-0/马尔科夫链3-3.jpg" alt></p>
<p>7.27</p>
<p>如何描述一个向上过度的概率，它如同泊松分布记录到一个在一个很小的时间段$\lamda$的概率$\delta$<br>这个向上过度的概率=$\lamda\delta$<br>所以每一个向上过度的概率都是$\lamda\delta$</p>
<p>向下过度的概率，如上在一个很小的时间段内$\alpha$的概率$\delta$<br>所以每一个向下过度的概率都是$\lamda\delta$</p>
<p>i个电话通话时直到有一个人挂电话的概率$i\alpha\delta$</p>

    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/">程序人生</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/java/">java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/" rel="tag">程序人生</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag">计算机组成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

            </section>
        </aside>
    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>