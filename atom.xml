<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Life &amp;&amp; Study</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cnawesome.github.io/"/>
  <updated>2020-05-09T09:29:29.172Z</updated>
  <id>https://cnawesome.github.io/</id>
  
  <author>
    <name>alei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成1.0</title>
    <link href="https://cnawesome.github.io/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/"/>
    <id>https://cnawesome.github.io/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/</id>
    <published>2020-05-07T07:54:29.000Z</published>
    <updated>2020-05-09T09:29:29.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成概念"><a href="#计算机组成概念" class="headerlink" title="计算机组成概念"></a>计算机组成概念</h3><p>计算机组成与计算机体系区别</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8C%BA%E5%88%AB.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.jpg" alt><br>实线是数据传输，虚线是控制传输<br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%842.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%843.jpg" alt></p><p>累加运算器</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E8%BF%90%E7%AE%97%E5%99%A8%E7%BB%93%E6%9E%84.jpg" alt><br>ACC：数据寄存器<br>ALU：运算寄存器<br>X：运算数<br>MQ：存放结果</p><p>控制器<br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt><br>PC:保存指令地址</p><p>运算速度：<br>机器字长：cpu一次处理数据的位数<br>与cpu寄存器位数有关</p><p>CPI：执行一条指令所需要的时间周期</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%90%89%E6%99%AE%E6%A3%AE%E6%B3%95.jpg" alt><br>f表示频率；</p><p>MIPS:每秒执行百万条指令</p><p>ELOPS：每秒浮点运算次数</p><h4 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h4><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB.jpg" alt></p><p>1.单总线结构框图</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt></p><p>多总线结构</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%841.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%841.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%841.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%842.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%841.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/pci%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%A4%9A%E5%B1%82pci%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/vl-bus%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt></p><h4 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h4><p>基础概念：</p><p>主设备（模块）：多总线由控制权<br>从设备（模块）：响应从主设备发来的总线命令</p><p>功能：总线判优，总线通信</p><h5 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h5><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.jpg" alt><br>BS:总线忙<br>BR：总线请求<br>BG:链式查询  是否提出总线占用请求</p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.jpg" alt></p><h5 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h5><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E6%80%BB%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%91%A8%E6%9C%9F.jpg" alt></p><p>总线通信方式：<br>    1.同步通信<br>    2.异步通信<br>    3.半同步通信<br>    4.分离式通信<br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%90%8C%E4%BF%A1.jpg" alt></p><p><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1.jpg" alt><br><img src="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%901-0/%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1%E7%89%B9%E7%82%B9.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成概念&quot;&gt;&lt;a href=&quot;#计算机组成概念&quot; class=&quot;headerlink&quot; title=&quot;计算机组成概念&quot;&gt;&lt;/a&gt;计算机组成概念&lt;/h3&gt;&lt;p&gt;计算机组成与计算机体系区别&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/07/%E8%AE%
      
    
    </summary>
    
    
      <category term="计算机组成" scheme="https://cnawesome.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
    
      <category term="计算机组成" scheme="https://cnawesome.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>linux内核2.0</title>
    <link href="https://cnawesome.github.io/2020/04/16/linux%E5%86%85%E6%A0%B82-0/"/>
    <id>https://cnawesome.github.io/2020/04/16/linux%E5%86%85%E6%A0%B82-0/</id>
    <published>2020-04-16T14:17:08.000Z</published>
    <updated>2020-04-18T09:37:53.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="80x86保护模式及其编程"><a href="#80x86保护模式及其编程" class="headerlink" title="80x86保护模式及其编程"></a>80x86保护模式及其编程</h3><pre><code>-本书介绍的linux擦欧总系统基于intel公司80x86及其相关外围硬件组成的pc机。</code></pre><p>80x86 参考书籍： 《IA-32 intal体系结构软件开发者手册》<br>，《系统编程指南》</p><h4 id="80x86-系统寄存器和系统指令"><a href="#80x86-系统寄存器和系统指令" class="headerlink" title="80x86 系统寄存器和系统指令"></a>80x86 系统寄存器和系统指令</h4><h5 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h5><p>标志寄存器： EFLAGS的系统标志和IOPL字段用于控制i/o访问，可屏蔽硬件中断，调试，任务切换以及虚拟-8086模式。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br>内存管理寄存器：<br>处理器提供四个内存管理寄存器（GDTR，LDTR，IDTR和TR），用于指定分段内存管理所使用的系统表的基地址。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br>控制寄存器：（CR0，CR1，CR2和CR3），用于控制和确定处理器的操作模式以及当前执行的任务的特性。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt></p><h5 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A42.jpg" alt></p><h5 id="保存模式内存管理"><a href="#保存模式内存管理" class="headerlink" title="保存模式内存管理"></a>保存模式内存管理</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A22.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A23.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E4%BF%9D%E6%8A%A4.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E4%BF%9D%E6%8A%A42.jpg" alt></p><p>虚拟地址 采用 段结构<br>段地址 映射到 线性地址<br>线性地址 映射到 物理地址<br>线性地址 可采用 页表结构</p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%892.jpg" alt></p><h5 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h5><p>段描述表 分为 GDT(全局描述表) 和 LDT(局部描述表)<br>虚拟内存中，一般是GDT，一半是LDT。<br>GDT任务共享<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A82.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A83.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A84.jpg" alt></p><h5 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A64.jpg" alt></p><h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A64.jpg" alt></p><p>段选择符 指向 段描述符表 向内寻找 段描述符 找到对应的空间</p><pre><code>-------2020.4.17  这段主要是介绍内存的管理，段内存的寻址至101页</code></pre><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B2.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B3.jpg" alt></p><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B64.jpg" alt></p><h5 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h5><pre><code>二级页表有点难懂</code></pre><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%842.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%843.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%844.jpg" alt></p><h5 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h5><p>段级保护和页级保护</p><h4 id="中断可异常处理"><a href="#中断可异常处理" class="headerlink" title="中断可异常处理"></a>中断可异常处理</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E6%BA%90.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E6%BA%90.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%80%E5%90%AF%EF%BC%8C%E7%A6%81%E6%AD%A2%E4%B8%AD%E6%96%AD.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A82.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A62.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%862.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%863.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%864.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%865.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%866.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%867.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%862.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%863.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt><br>任务状态段：<br>用于恢复一个任务执行的处理器状态信息被保存在称为任务状态段TSS的段中。<br>TSS段中个字段分为两大类： 动态字段和静态字段<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.jpg" alt></p><p><a href="任务管理数据结构动态字段.jpg"></a><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86tss%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt></p><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%93%BE.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%93%BE2.jpg" alt><br>保护模式系统表：一个代码段和数据段的GDT，支持分页机制的页目录和页表，每个应用程序的段和LDT表段。<br>保护模式异常和中断初始化：如见初始化设置一个保护模式IDT，IDT门描述符，任务门，TSS以及相关代码，数据和堆栈段<br>分页机制初始化：控制寄存器CR0的PG标志设置。<br>多任务初始化：TSS及TSS段描述符。</p><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;80x86保护模式及其编程&quot;&gt;&lt;a href=&quot;#80x86保护模式及其编程&quot; class=&quot;headerlink&quot; title=&quot;80x86保护模式及其编程&quot;&gt;&lt;/a&gt;80x86保护模式及其编程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;-本书介绍的linux擦欧总系统基于
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cnawesome.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cnawesome.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux内核1.0</title>
    <link href="https://cnawesome.github.io/2020/04/15/linux%E5%86%85%E6%A0%B81-0/"/>
    <id>https://cnawesome.github.io/2020/04/15/linux%E5%86%85%E6%A0%B81-0/</id>
    <published>2020-04-15T13:56:12.000Z</published>
    <updated>2020-04-17T09:58:08.948Z</updated>
    
    <content type="html"><![CDATA[<pre><code>---------- 再一次看内核书籍，这一次一定要努力看完</code></pre><h3 id="1-linux的由来"><a href="#1-linux的由来" class="headerlink" title="1.linux的由来"></a>1.linux的由来</h3><p>由unix，minix，gun计划，posix标准，internet网络发展过来。</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC2.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6.jpg" alt><br>bootimage 是软盘印象image的引导启动文件。<br>包括磁盘引导扇区代码，操作系统加载程序和内核执行代码。</p><p>磁盘引导扇区代码：<br>    pc的ram bios启动-&gt;默认启动驱动器的引导扇区代码-&gt;操作系统加载程序和内核执行代码读入内存-&gt;操作系统加载程序进行初始化内核-&gt;最终加载陈旭把控制权交给内核代码</p><p>内核代码正常运行需要文件系统的支持。</p><p>rootimage 向内和提供基本的根文件系统。</p><p>这两个盘合起来相当于一个可启动的dos操作系统盘。</p><p>as86.tar.Z 是16位汇编器连接程序软件包<br>Ǆlinux-0.11.tar.Z 压缩的内核源代码</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linnux%E7%9B%AE%E5%BD%95.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E5%8F%82%E8%80%83%E7%9A%84%E4%B9%A6.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%AF%9E%E7%94%9F.jpg" alt></p><h3 id="微型计算机组成结构"><a href="#微型计算机组成结构" class="headerlink" title="微型计算机组成结构"></a>微型计算机组成结构</h3><h4 id="i-o端口寻址"><a href="#i-o端口寻址" class="headerlink" title="i/o端口寻址"></a>i/o端口寻址</h4><p>cpu访问i/o接口控制器或其上的信息，需要首先指定他们的地址。这种地址成为i/o端口</p><p>i/o控制器 包含：访问数据的数据端口，输出命令的命令端口，访问控制器状态的状态端口。</p><p>端口地址的设置方法：1.统一编制：2.独立编址<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%AB%AF%E5%8F%A3%E7%BB%9F%E4%B8%80%E7%BC%96%E5%9D%80.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%AB%AF%E5%8F%A3%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80.jpg" alt></p><p>Linux下 在/proc/ioports 可以查看相关控制器或设置使用的i/o地址范围</p><h4 id="接口访问控制"><a href="#接口访问控制" class="headerlink" title="接口访问控制"></a>接口访问控制</h4><p>pc机接口数据传输控制方式：<br>    1.程序循环查询方式<br>    2.中断处理方式<br>    3.DMA传输方式</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.jpg" alt></p><h3 id="主存，bios和cmos存储器"><a href="#主存，bios和cmos存储器" class="headerlink" title="主存，bios和cmos存储器"></a>主存，bios和cmos存储器</h3><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>计算机上电-&gt;内存地址初始化（除去0xA0000到0xFFFFF 640K到1M 和  0xFFFE0000 到0xFFFFFFFF 4g处的最后一64k，这两个区域特定用于i/o设备和bios程序）</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/at%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9F%9F.jpg" alt></p><h4 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/bios.jpg" alt><br>计算机上电-&gt; 内存地址初始化-&gt; cpu自动把代码段寄存器cs设置为0xF000，段基地址为 0xFFFF0000，段长度为64kb-&gt; ip=0xFFF0,cpu代码指向 0xFFFFFFF0 ，系统ram bios程序存放位置-&gt; bios在该位置存放一条jmp跳转指令转入bios内开始执行-&gt; bios执行初始化后将bios代码与数据复制到内存低端1M末端的64k处-&gt; 跳转到该位置让cpu静茹真正的实地址模式工作-&gt; 将操作系统引导程序加载到内存0x7c00处，继续执行引导程序<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/bios%E6%89%A7%E8%A1%8C.jpg" alt></p><h4 id="cmos"><a href="#cmos" class="headerlink" title="cmos"></a>cmos</h4><p>存储系统硬件信息和时钟信息</p><h3 id="控制器和控制卡"><a href="#控制器和控制卡" class="headerlink" title="控制器和控制卡"></a>控制器和控制卡</h3><p>—–2020.4.15</p><h4 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h4><p>ibm pc/at 80x86 兼容微机使用两片级联的8259A可编程中断控制芯片醉成中断控制器。如图2-6.</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%9B%BE2-6.jpg" alt></p><p>计算机初始化时，<br>    -&gt; rom bios 对两片8259芯片初始化<br>    -&gt; 同时，把15个中断优先级分配给时钟定时器，键盘，串行口，打印口，等设备控制器使用<br>    -&gt; 同时，在内存开始处0x000-0xFFF区域建立一个中断向量表。</p><p>linux对此做了重新的设置。</p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%AE%9A%E6%97%B6%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt></p><h4 id="键盘控制器"><a href="#键盘控制器" class="headerlink" title="键盘控制器"></a>键盘控制器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt><br>键盘控制器=键盘的键盘编码器+主机的键盘控制器</p><p>键盘编码器收集按键按下松开的状态信息（即扫描码）-&gt;  主机键盘控制器接收到键盘扫描码（11为的串行信息）后进行解码-&gt; 转换位pc/xt标准键盘兼容的系统扫描码-&gt; 通过中断控制器IRQ1引脚向cpu发送中断请求-&gt; 响应该中断请求后，调用键盘中断处理程序来读取控制器的xt键盘扫描码-&gt; 解码后把数据发送给操作系统的键盘数据队列中</p><h4 id="串行控制卡"><a href="#串行控制卡" class="headerlink" title="串行控制卡"></a>串行控制卡</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%B2%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt></p><h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%98.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%982.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%983.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%984.jpg" alt></p><h3 id="内核编程语言和环境（阅读源码的准备工作）"><a href="#内核编程语言和环境（阅读源码的准备工作）" class="headerlink" title="内核编程语言和环境（阅读源码的准备工作）"></a>内核编程语言和环境（阅读源码的准备工作）</h3><h4 id="as86汇编器"><a href="#as86汇编器" class="headerlink" title="as86汇编器"></a>as86汇编器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96%E5%99%A8%E4%BB%8B%E7%BB%8D.jpg" alt></p><p>as86汇编语句：赋值语句，伪操作符语句，机器指令语句<br>汇编器编译的产生的目标文件起码包含三个段或区：正文段，数据段，未初始化数据段</p><p>简单的引导扇区启动程序：<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A5.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A.jpg" alt></p><h4 id="gun-as汇编器"><a href="#gun-as汇编器" class="headerlink" title="gun as汇编器"></a>gun as汇编器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%951.jpg" alt><br>as汇编器有简单的预处理功能</p><h5 id="指令语句，操作数和寻址"><a href="#指令语句，操作数和寻址" class="headerlink" title="指令语句，操作数和寻址"></a>指令语句，操作数和寻址</h5><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%93%8D%E4%BD%9C%E7%A0%81%E5%91%BD%E5%90%8D.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%93%8D%E4%BD%9C%E7%A0%81%E5%89%8D%E7%BC%80.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E5%91%BD%E4%BB%A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%9916%E4%BD%8D.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D.jpg" alt></p><h3 id="c语言环境"><a href="#c语言环境" class="headerlink" title="c语言环境"></a>c语言环境</h3><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96%E7%BB%84%E5%90%88%E8%AF%AD%E5%8F%A5.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8c%E5%87%BD%E6%95%B01.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8c%E5%87%BD%E6%95%B02.jpg" alt></p><p>汇编调用c函数，将参数入栈，call函数名即调用带有参数的函数</p><p>这里看的云里雾里的，不太行</p><h4 id="linux目标文件格式"><a href="#linux目标文件格式" class="headerlink" title="linux目标文件格式"></a>linux目标文件格式</h4><p>本书介绍:<br>    编译器申城目标文件结构-&gt; 链接器把目标文件模块组合，生成二进制可执行映像文件</p><pre><code>二进制代码文件image生成原理与过程</code></pre><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F2.jpg" alt></p><pre><code>执行头部分：包含有关整体结构信息。代码区：由编译器或汇编器生成的二进制指令代码和数据信息。数据区：由编译器或汇编器生成的数据信息。代码重定部分：含有供链接程序使用的记录数据。数据重定位部分：用于数据段重定位。符号表部分：同样含有供链接程序使用的记录数据。字符串表部分：含有与符号命相对应的字符串</code></pre><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F4.jpg" alt></p><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C5.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;---------- 再一次看内核书籍，这一次一定要努力看完&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-linux的由来&quot;&gt;&lt;a href=&quot;#1-linux的由来&quot; class=&quot;headerlink&quot; title=&quot;1.linux的由来&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cnawesome.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cnawesome.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>离散数学1.0</title>
    <link href="https://cnawesome.github.io/2020/04/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-0/"/>
    <id>https://cnawesome.github.io/2020/04/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-0/</id>
    <published>2020-04-15T03:20:36.000Z</published>
    <updated>2020-04-15T03:20:36.801Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu 操作</title>
    <link href="https://cnawesome.github.io/2020/04/08/ubuntu-%E6%93%8D%E4%BD%9C/"/>
    <id>https://cnawesome.github.io/2020/04/08/ubuntu-%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-08T10:21:30.000Z</published>
    <updated>2020-04-09T11:52:04.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>whoami 用来查看当前用户名</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>APT管理软件：高级报管理工具</p><p>软件更新，升级<br>    sudo apt-get update 或者 sudo apt-get upgrade<br>软件安装<br>    sudo apt-get install 软件包名</p><p>软件删除<br>    sudo apt-get remove</p><p>搜索软件包<br>    sudo apt-get search 软件包名</p><p>显示该包的依赖信息<br>    sudo apt-get depends 软件包名</p><h4 id="dpkg-command"><a href="#dpkg-command" class="headerlink" title="dpkg command"></a>dpkg command</h4><p>安装dpkg命令：<br>    sudo dpkg -i deb 包名</p><p>shutdown 关机命令<br>    -t 告诉init多久后关机<br>    -r 重新启动<br>    -k 不是真正的关机，只是警告信息<br>    -h 关机后关闭电源</p><p>halt 命令 关闭系统</p><p>putty 远程登录<br>    pputty以中国远程登陆工具，功能强大</p><pre><code>1。在服务器端安装openssh-serveropenssh服务器组件sshd持续监听老子客户端工具的连接请求。在ubuntu安装 openssh-servesudo apt-get install opensssh-server2.客户端安装putty</code></pre><h2 id="ubuntu-文件管理"><a href="#ubuntu-文件管理" class="headerlink" title="ubuntu 文件管理"></a>ubuntu 文件管理</h2><p>在linux里，一切都看作文件<br>在linux中没有磁盘的逻辑分区，任何一种类的文件系统被创建后都需要挂载到某个特定的目录才能使用。</p><p>linux用磁盘块管理内存空间。磁盘块=超级节点+i-节点+数据块</p><p>cat命令：显示文件或追加文件<br>cat -n 编号输出文件<br>cat可以用于输出重定向，将现有的文件内容重定向到已有的文件。如果目标文件不存在，创建该文件。<br>    cat a1.txt&gt;a2.txt<br>    cat a1.txt&gt;&gt;a2.txt 表示追加重定向</p><p>more显示输出内容，根据窗口大小调整分页 </p><p>less 显示文件</p><p>head 显示文件前n行，不带选项时默认显示前10行<br>tail 显示文件后n行</p><p>echo 输出字符串到基本输出，在显示器的输出</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>一个由标准输入</p><h3 id="linux-多用户"><a href="#linux-多用户" class="headerlink" title="linux 多用户"></a>linux 多用户</h3><p>liunx用户分类：<br>    1.超级用户<br>    2.系统用户（一些系统进程的使用名）<br>    3.普通用户</p><p>每一个用户都只能属于一个基本用户组，可以属于多个附加组。</p><p>quote 磁盘配额</p><p>物理内存时系统提供的内存大小。<br>linux的虚拟内存时利用磁盘空间的一块逻辑内存<br>用作虚拟内存的磁盘空间称为交换空间<br>swap时linux下的虚拟内存分区，作用是在物理内存使用完之后，将磁盘空间即swap分区当作内存来使用。</p><p>gcc 编译流程：预编译，编译，汇编（生成目标文件），链接（生成可执行文件）</p><p>gdb程序调试工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;headerlink&quot; title=&quot;基本命令&quot;&gt;&lt;/a&gt;基本命令&lt;/h2&gt;&lt;p&gt;whoami 用来查看当前用户名&lt;/p&gt;
&lt;h3 id=&quot;安装软件&quot;&gt;&lt;a href=&quot;#安装软件&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="linux" scheme="https://cnawesome.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://cnawesome.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>算法设计4.0</title>
    <link href="https://cnawesome.github.io/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/"/>
    <id>https://cnawesome.github.io/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/</id>
    <published>2020-04-02T13:11:58.000Z</published>
    <updated>2020-04-06T13:22:13.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="散列-hashing"><a href="#散列-hashing" class="headerlink" title="散列 hashing"></a>散列 hashing</h3><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%8E%9F%E7%90%86.jpg" alt></p><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E4%BE%8B.jpg" alt></p><p>三列表长度：90001</p><p>n/m ：装填因子</p><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81.jpg" alt></p><p>散列冲突处理方式：<br>    1.选择有效的散列函数<br>    2.多槽位<br>    3.</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%BB%BB%E5%8A%A1.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E9%99%A4%E4%BD%99%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0MAD%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%8A%98%E5%8F%A0%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95.jpg" alt></p><h4 id="多槽位"><a href="#多槽位" class="headerlink" title="多槽位"></a>多槽位</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E5%A4%9A%E6%A7%BD%E4%BD%8D.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E7%8B%AC%E7%AB%8B%E9%93%BE.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E7%8B%AC%E7%AB%8B%E9%93%BE%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" alt></p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E6%80%A7.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%8F%E6%80%A7.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81.jpg" alt></p><p>按优先级排序，需要一个优先级队列来实现</p><h4 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E4%BB%A3%E7%A0%81.jpg" alt></p><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81.jpg" alt></p><p>删除操作：为什么不用左子树根节点？<br>如果用左子树根节点换根节点，也必然会出现顺序错误，在调整顺序的操作上比起用最后一个节点来说，多余了一些操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;散列-hashing&quot;&gt;&lt;a href=&quot;#散列-hashing&quot; class=&quot;headerlink&quot; title=&quot;散列 hashing&quot;&gt;&lt;/a&gt;散列 hashing&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/04/02/%E7%AE%97%E6%B3%
      
    
    </summary>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记</title>
    <link href="https://cnawesome.github.io/2020/03/26/c-%E5%9F%BA%E7%A1%80/"/>
    <id>https://cnawesome.github.io/2020/03/26/c-%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-26T04:18:55.000Z</published>
    <updated>2020-04-19T15:08:24.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h3><p>ANSI标准五个预定义的宏名<br>    <strong>LINE</strong> 表示该行代码的所在行号<br>    <strong>FILE</strong> 表示源文件的文件名<br>    <strong>DATE</strong> 表示源文件被编译的日期，格式(月/日/年)<br>    <strong>TIME</strong> 表示源文件被编译成目标代码的时间，格式(时:分:秒)<br>    <strong>STDC</strong> 表示编译器是否标准，标准时表示常量1，非标准则表示其它数字</p><p>宏定义可以使用在函数身上：</p><pre><code>#define INFO(msg) info_debug(__FILE__, __LINE__, __DATE__, __TIME__, msg) void info_debug(const char* filename, int line, const char* date, const char* time, const char* msg){    printf_s(&quot;info_debug %s:%d (%s-%s):%s&quot;, filename, line, date, time, msg);}int main(){    INFO(&quot;Hello world!\n&quot;);    system(&quot;pause&quot;);    return 0;}</code></pre><p>宏定义的细节<br>    1）对于有参数的宏定义，宏定义时，在宏名与带参数的括号之间不应加空格，否则将空格以后的字符都作为替代字符串的一部分。<br>    2）带参数的宏定义只是进行简单的字符替换，宏展开则是在编译前进行的，在展开时并不分配内存单元，不进行值的传递处理，因此替换不会占用运行时间，只占用编译时间。<br>    3）宏不存在类型问题，宏名无类型，宏的参数也无类型，只是一个符号代表，展开时代入指定的字符串即可，宏定义时，字符串可以是任何类型的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;define宏定义&quot;&gt;&lt;a href=&quot;#define宏定义&quot; class=&quot;headerlink&quot; title=&quot;define宏定义&quot;&gt;&lt;/a&gt;define宏定义&lt;/h3&gt;&lt;p&gt;ANSI标准五个预定义的宏名&lt;br&gt;    &lt;strong&gt;LINE&lt;/strong
      
    
    </summary>
    
    
      <category term="c++" scheme="https://cnawesome.github.io/categories/c/"/>
    
    
      <category term="c++" scheme="https://cnawesome.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>错误集</title>
    <link href="https://cnawesome.github.io/2020/03/23/%E9%94%99%E8%AF%AF%E9%9B%86/"/>
    <id>https://cnawesome.github.io/2020/03/23/%E9%94%99%E8%AF%AF%E9%9B%86/</id>
    <published>2020-03-23T09:51:59.000Z</published>
    <updated>2020-03-23T13:29:22.255Z</updated>
    
    <content type="html"><![CDATA[<p>ifndef 的作用<br>    当有很多头文件时，一般都需要用它<br>    它可以防止头文件被一个源文件多次包含出现冲突<br>    不是防止两个源文件包含同一个头文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ifndef 的作用&lt;br&gt;    当有很多头文件时，一般都需要用它&lt;br&gt;    它可以防止头文件被一个源文件多次包含出现冲突&lt;br&gt;    不是防止两个源文件包含同一个头文件&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Android学习日记1.0</title>
    <link href="https://cnawesome.github.io/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/"/>
    <id>https://cnawesome.github.io/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/</id>
    <published>2020-03-21T03:33:43.000Z</published>
    <updated>2020-03-21T05:32:46.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/newPJ.jpg" alt></p><p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/moudle.jpg.jpg" alt></p><p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80.jpg" alt><br><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/manifest.jpg" alt></p><p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/mainactivity.jpg" alt></p><p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/r%E6%96%87%E4%BB%B6.jpg" alt><br>android R文件出现问题可以 clear 恢复。</p><p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/r%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3.jpg" alt></p><p>res/：包含应用资源，例如可绘制对象文件、布局文件和 UI 字符串。</p><p>raw/：用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！其实和Assets差不多，不过这里面的资源会在R文件那里生成一个资源id而已。</p><p>AVD：安卓模拟器</p><p>viewgroup是抽象类，一般使用它的子类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/newPJ.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/21/Android%E5%AD%A6%E4%B9%
      
    
    </summary>
    
    
      <category term="Android" scheme="https://cnawesome.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://cnawesome.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>算法设计3.0</title>
    <link href="https://cnawesome.github.io/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/"/>
    <id>https://cnawesome.github.io/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/</id>
    <published>2020-03-19T05:06:32.000Z</published>
    <updated>2020-04-02T13:31:08.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.jpg" alt><br>v 顶点 ，e 边<br>|v| 顶点个数 ，|e| 边数</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%97%A0%E5%90%91%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%9C%89%E5%90%91%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%9C%89%EF%BC%8C%E6%97%A0%E5%90%91%E5%9B%BE.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E8%B7%AF%E5%BE%84.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E8%BE%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%BB%A3%E7%A0%81.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E6%93%8D%E4%BD%9C%E5%85%B7%E4%BD%93.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%A1%B6%E7%82%B9%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%A1%B6%E7%82%B9%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt><br>在图中插入一个新的节点</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E8%BE%B9%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E8%BE%B9%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt></p><h4 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS 广度优先遍历"></a>BFS 广度优先遍历</h4><p>把图化为树，把非线性变为半线性。<br>正如把树通过遍历化为队列，把半线性化为了线性。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS.jpg" alt></p><p>图的广度优先遍历类似与树的层次遍历。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E4%BB%A3%E7%A0%811.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E8%BF%87%E7%A8%8B1.jpg" alt></p><p>简单的实现，不建议模仿</p><pre><code>void BFS(Graph g,int n){// 广度优先遍历    if(g.v[n].vs==UNDISCOVER||g.v[n].vs==DISCOVER){        g.v[n].vs=VISITED;    }    for (int i = 0; i &lt;MAX ; i++) //入栈相邻节点    {           if(g.e[i][n].hasEdge == 1 &amp;&amp; g.v[i].vs==UNDISCOVER){                g.v[i].vs=VISITED;                Vquene[k++]=i;           }    }    for (int j = k+1; j &lt; MAX; j++)    {        Vquene[j]=-1;    }    if(Vquene[0]!=-1){        printf(&quot;next node number:%d\n&quot;,Vquene[0]);        int num=Vquene[0];        for (int p = 0; p &lt;MAX; p++)        {            Vquene[p]=Vquene[p+1];        }        BFS(g,num);}</code></pre><p>按BFS广度优先遍历出来的节点到节点的距离时最短路径。</p><h4 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h4><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/DFS%E4%BB%8B%E7%BB%8D.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84DFS%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84DFS%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82.jpg" alt></p><p>分为有向图和无向图的DFS</p><p>dTime 刚访问时间  Ftime 结束访问时间</p><h4 id="嵌套引理"><a href="#嵌套引理" class="headerlink" title="嵌套引理"></a>嵌套引理</h4><p>祖先节点 与 子孙节点的依据活跃期判断： 祖先的活跃期必然大于子孙的活跃期<br>连个节点无关，活跃期不相交<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84dtime.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E6%B4%BB%E8%B7%83%E6%9C%9F%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E8%AF%8D%E6%9D%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E9%A1%BA%E5%BA%8F%E6%80%A7.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8E%A5%E5%8F%A3.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E6%8E%A5%E5%8F%A3%E5%9B%BE.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7%E5%8F%98%E6%8D%A2%E5%9B%BE1.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B%E5%9B%BEjpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A4%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A41%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A41%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A42%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A42%E4%BB%A3%E7%A0%81.jpg" alt></p><h4 id="BBST-平衡二叉树"><a href="#BBST-平衡二叉树" class="headerlink" title="BBST 平衡二叉树"></a>BBST 平衡二叉树</h4><p>适度平衡准则，任何一个树节点在BBST外，都可以变换到BBST内部。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7.jpg" alt></p><p>####AVL树</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8E%A5%E5%8F%A3.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%A4%B1%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avlzigzag.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E9%80%82%E5%BA%A6%E5%B9%B3%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%8D%95%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%8F%8C%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%88%A0%E9%99%A4%E5%8F%8C%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%A0%B8%E5%BF%83ro%E4%BB%A3%E7%A0%81.jpg" alt></p><p>拥有 链表和向量的特点，并且有很好的很低复杂度。</p><p>AVL中，一个节点的删除，只可能是一个节点失衡；而一个节点的插入，可能导致多个节点失衡。</p><p>####3+4重构</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl3+4%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl3+4%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt></p><h4 id="高级搜索树"><a href="#高级搜索树" class="headerlink" title="高级搜索树"></a>高级搜索树</h4><p>伸张树：为了更宽松的使用avl的性质。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E6%95%B4%E6%80%9D%E8%B7%AF.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%B1%80%E9%83%A8%E6%80%A7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A01.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A02.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A03.jpg" alt></p><p>伸张树自适应调整策略并非最佳策略</p><h4 id="B-TREE（高级搜索树）"><a href="#B-TREE（高级搜索树）" class="headerlink" title="B-TREE（高级搜索树）"></a>B-TREE（高级搜索树）</h4><p>原因：数据越来越多，让内存看起来越来越小</p><p>又称平衡多路搜索树</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E8%8A%82%E7%82%B9.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E9%98%B6%E6%95%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E8%AF%A2%E6%95%88%E6%9E%9C.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E7%B4%A7%E5%87%91%E8%A1%A8%E7%A4%BA.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9C%80%E5%B0%8F%E6%A0%91%E9%AB%98.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9C%80%E5%A4%A7%E6%A0%91%E9%AB%98.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91.jpg" alt><br>利用向量来表示<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91tree%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E5%A4%B1%E8%B4%A5.jpg" alt><br>b树的查找失败，必然是在外部的叶子节点。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%88%86%E8%A3%82.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E4%B8%8B%E6%BA%A2%E6%97%8B%E8%BD%AC.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E4%B8%8B%E6%BA%A2%E5%90%88%E5%B9%B6.jpg" alt></p><h4 id="红黑树（高级搜索树）"><a href="#红黑树（高级搜索树）" class="headerlink" title="红黑树（高级搜索树）"></a>红黑树（高级搜索树）</h4><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%80%E8%87%B4%E6%80%A7%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B3%E8%81%94%E6%80%A7.jpg" alt></p><p>目的：为了使各个版本的BST能更快的访问，更小的空间。</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B3%E8%81%94%E6%80%A7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BA%A2%E4%B8%8E%E9%BB%91.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%91%E4%B8%8A%E6%8F%90%E5%8D%87.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%91%E4%B8%8A%E6%8F%90%E5%8D%871.jpg" alt><br>红色节点向上提升与黑节点平齐。<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%9124%E6%A0%91.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg" alt></p><p>红黑树的变化要依赖于b树的结构</p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A51.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A52.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A52%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A53%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A54%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A54%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A55%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A56%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A57%E5%8F%8C%E7%BA%A2%E4%BF%AE%E6%AD%A3%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt></p><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A41.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B72.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B73.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A43%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A43%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B72.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A44%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt></p><h3 id="end-at-2019-4-2"><a href="#end-at-2019-4-2" class="headerlink" title="end at 2019.4.2"></a>end at 2019.4.2</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7
      
    
    </summary>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vscode配置编译环境</title>
    <link href="https://cnawesome.github.io/2020/03/18/vscode%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://cnawesome.github.io/2020/03/18/vscode%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2020-03-18T09:05:53.000Z</published>
    <updated>2020-03-18T09:05:53.351Z</updated>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>电路分析</title>
    <link href="https://cnawesome.github.io/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <id>https://cnawesome.github.io/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</id>
    <published>2020-03-14T03:18:32.000Z</published>
    <updated>2020-04-20T13:37:49.910Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BD%95%E4%B8%BA%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E5%85%83%E4%BB%B6.jpg" alt></p><p>一个电路可能有不同的电路模型<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%B7%AF%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E7%94%B5%E8%B7%AF.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8F%82%E6%95%B0%E7%94%B5%E8%B7%AF.jpg" alt><br>主要研究集总参数电路。</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%B3%A2%E6%AE%B5.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%BD%A2%E6%88%90.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E7%A3%81%E8%83%BD%E9%87%8F.jpg" alt></p><h4 id="电路分类："><a href="#电路分类：" class="headerlink" title="电路分类："></a>电路分类：</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%A8%E6%80%81%E7%94%B5%E9%98%BB.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%9C%89%E6%BA%90%E6%97%A0%E6%BA%90.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%97%B6%E5%8F%98%E6%97%B6%E4%B8%8D%E5%8F%98%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%94%B5%E8%B7%AF.jpg" alt></p><h4 id="电路变量"><a href="#电路变量" class="headerlink" title="电路变量"></a>电路变量</h4><p>为了定量描述电路性能，引入电路变量.<br>分为基本变量和复合变量<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E5%8E%8B%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%BD%A2%E6%88%90.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E6%96%B9%E5%90%91.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg" alt></p><p>基本变量如：电流，电压等。<br>复合变量如：功率，能量等。</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%85%B3%E8%81%94%E5%8F%82%E8%80%83%E6%96%B9%E5%90%91.jpg" alt></p><p>电路的实际方向不好确定，使用参考方向，参考方向可以任意指定。</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%9F%E7%8E%87%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%9F%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%83%BD%E9%87%8F%E8%AE%A1%E7%AE%97.jpg" alt><br>阻值和功率是电阻的属性。<br>超过电阻的额定功率会导致电阻损坏。</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E7%94%B5%E9%98%BB%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt><br>电阻不论是关联和非关联，都是吸收功率。</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8F%97%E6%8E%A7%E6%BA%90%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E7%AB%AF.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E6%9C%AF%E8%AF%AD.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/kvl.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%B9%BF%E4%B9%89kvl.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%B9%BF%E4%B9%89kcl.jpg" alt></p><p>###电阻等效变换</p><h4 id="2b法"><a href="#2b法" class="headerlink" title="2b法"></a>2b法</h4><p>列出所有原件方程，kcl方程，kvl方程<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/2b%E6%B3%95.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E7%94%B5%E9%98%BB%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt></p><h3 id="电路的等效变换"><a href="#电路的等效变换" class="headerlink" title="电路的等效变换"></a>电路的等效变换</h3><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A2.jpg" alt><br>0值电压源等效于0值电阻等效于短路</p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%B8%B2%E5%B9%B6%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E4%B8%B2%E8%81%94.jpg" alt></p><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E5%B9%B6%E8%81%94.jpg" alt></p><pre><code>---2020/4/10</code></pre><h4 id="y型电路和三角形电路"><a href="#y型电路和三角形电路" class="headerlink" title="y型电路和三角形电路"></a>y型电路和三角形电路</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E6%8E%A8%E5%AF%BC.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E6%8E%A8%E5%AF%BC2.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8F%98%E6%8D%A2.jpg" alt></p><h3 id="电压等效变换"><a href="#电压等效变换" class="headerlink" title="电压等效变换"></a>电压等效变换</h3><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E4%B8%B2%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E5%B9%B6%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E8%A1%A8%E6%8D%A2.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A22.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A23.jpg" alt></p><p>求和电路源串联的电压源的电流时，电压源的电流看作0.</p><h4 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%89%B9%E6%80%A7.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E8%B4%9F%E5%8F%8D%E9%A6%88.jpg" alt></p><p>在特定的情况下，只能用加压求流，或加流求压。</p><pre><code>----2020/4/14</code></pre><h4 id="二端口"><a href="#二端口" class="headerlink" title="二端口"></a>二端口</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BA%92%E6%98%93%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt></p><pre><code>----2020/4/20</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BD%95%E4%B8%BA%E7%94%B5%E8%B7%AF.jpg&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;/2020/03/14/%E7%94
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>普通生物学</title>
    <link href="https://cnawesome.github.io/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    <id>https://cnawesome.github.io/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/</id>
    <published>2020-03-13T23:04:35.000Z</published>
    <updated>2020-03-29T12:24:43.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生物膜的特性"><a href="#生物膜的特性" class="headerlink" title="生物膜的特性"></a>生物膜的特性</h3><p>1.生物膜具有流动性<br>2.膜蛋白分布不对称<br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C%E7%9A%84%E7%BB%84%E6%88%90.jpg" alt><br>生物膜处于动态运动中</p><p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C%E7%9A%84%E8%9B%8B%E7%99%BD%E8%B4%A8.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%B4%A8%E5%9F%BA%E8%B4%A8.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%86%9C%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD.jpg" alt></p><p>膜蛋白的作用：<br>    1.作为膜转运蛋白，选择性的介导小分子物质的跨膜运输。<br>    2.具有酶的功能<br>    3.作为细胞表面的受体，与激素结合之后将型号传递到胞内<br>    4.糖蛋白的糖链可有哦为细胞之间的识别标志。<br>    5.形成细胞之间的连接<br>    6。作为细胞骨架的连接点。</p><p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%86%9C%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%B7%A8%E8%86%9C%E8%BF%90%E8%BE%93%E7%AE%80%E5%8D%95%E6%89%A9%E6%95%A3.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E5%B0%8F%E5%88%86%E5%AD%90%E8%B7%A8%E8%86%9C%E8%BF%90%E8%BE%93.jpg" alt></p><p>载体蛋白：通过改变自身构件，转运</p><p>小分子的跨膜运输：<br>    简单扩散<br>    被动运输<br>    主动运输</p><h4 id="细胞连接"><a href="#细胞连接" class="headerlink" title="细胞连接"></a>细胞连接</h4><p>细胞间或细胞-基质见的接触部位形成特殊的连接结构，叫细胞连接。 </p><p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生物膜的特性&quot;&gt;&lt;a href=&quot;#生物膜的特性&quot; class=&quot;headerlink&quot; title=&quot;生物膜的特性&quot;&gt;&lt;/a&gt;生物膜的特性&lt;/h3&gt;&lt;p&gt;1.生物膜具有流动性&lt;br&gt;2.膜蛋白分布不对称&lt;br&gt;&lt;img src=&quot;/2020/03/14/%E6%
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis(1)</title>
    <link href="https://cnawesome.github.io/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cnawesome.github.io/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-11T13:08:33.228Z</published>
    <updated>2020-03-09T10:31:51.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h3><p>什么是框架<br>框架是整个或部分系统的可重用设计，表现为一组抽象构件及抽象构件实例之间加护的方法。（抽象方法，或者实例方法）。<br>它是软件开发中解决问题的一套方案。</p><p>mybatis 持久层框架</p><p>springnvc 表现层框架</p><p>spring 不属于这三个框架</p><p>三层架构<br>        表现层：张世数据<br>        业务层：处理业务需求<br>        持久层：数据库交互 </p><p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/01%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt></p><p>持久层技术解决方案<br>    jdbc技术：<br>            connection<br>            preparedstatement<br>            resultset<br>    jdbc开发不够便捷 </p><p>持久层连接数据库池过程<br>    1，加载驱动<br>    2，创建连接<br>    3，创建statement<br>    …</p><p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/02%E6%8C%81%E4%B9%85%E5%B1%82%E6%80%BB%E5%9B%BE.jpg" alt><br>Mybatis 通过xml或注解的方式 执行各种statment，并通过java对象和sql的动态参数进行映射形成最终sql语句，最后通过mabatis执行sql语句并返回。<br>利用ORM思想，对jdbc进行封装，屏蔽了jdbc api底层的访问问题</p><p>ORM （object relational  mapping）对象关系映射<br>即把数据库的表与实体类及实体类的属性对应起来，让我们可以操作实体类就实现数据表。</p><p>如何做到？<br>目前，我们需要把实体类的属性与数据库的字段名保持一致。</p><h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><p>1，创建maven工程，xml 添加依赖坐标（在官网上找依赖语句），同时写上数据库依赖，日志依赖，junit依赖等。<br>2，创建实体类<br>3，创建mybatis主配置文件（SqlMapConfig.xml）<br>4，创建映射配置文件(UserDao.xml)</p><p>环境搭建的注意事项:<br>1,创建UserDao.xml和UserDao.java是，名称是为了和我们之前的知识保持一致。在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper。所以UserDAO和UserMapper是一样的。</p><p>2.在idea创建目录是，它和包是不一样的 ，包创建时：comit.dao 是三级结构<br>    目录创建时 com.it.dao是一级目录。</p><p>3.mybatis的映射配置文件位置必须和dao接口的包结构相同。</p><p>4.映射文件的mapper标签namespace属性的取值必须是 dao接口的全限定类名。</p><p>5.映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法类,resulttype取值为应用接口的对象。</p><p>作用：按3，4，5配置后，无需再写dao的实现类，由mybatis直接实现。</p><p>UserDao.xml<br><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/UserDaoxml.PNG" alt></p><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"><!-- mybatis主配置文件 --><configuration>    <!-- 配制环境 -->    <environments default="mysql">        <!-- 配置mysql的环境 -->        <environments id="mysql">            <!-- 配置事务类型 -->            <transactionManager type="JDBC"></transactionManager>            <!-- 配置数据源（连接池） -->            <dateSource type="POOLED">                <!-- 配置连接数据库的四个基本信息 -->                <property name="driver" value="com.mysql.jdbc.Driver"></property>                <property name="url" value="jdbc：mysql：//localhost:3306/eesy_mybatis"></property>                <property name="username" value="root"></property>                <property name="passsword" value="123456"></property>            </dateSource><pre><code>    &lt;/environments&gt;&lt;/environments&gt;&lt;!-- 使用配置文件实现maybatis数据库操作，指定映射配置文件的位置，映射配置文件指的是每个dao的独立配置文件 --&gt;    &lt;mappers&gt;    &lt;mapper resource=&quot;com.itz.dao.UserDao.xml&quot; /&gt;&lt;/mappers&gt;或者&lt;!-- 使用注解实现maybatis数据库操作，移除UserDao.xml，在dao接口方法上使用@select注解，指定sql语句。在mapper中，指定class属性是dao接口的全限定类名 --&gt;    &lt;mappers&gt;    &lt;mapper resource=&quot;com.itz.dao.UserDao&quot; /&gt;&lt;/mappers&gt;</code></pre></environments></environments></configuration><p>环境搭建好后</p><h4 id="test步骤"><a href="#test步骤" class="headerlink" title="test步骤"></a>test步骤</h4><p>1.读取配置文件<br>    inputStream in=Pesources.getResourceAsStream(“SqlMapConfig.xml”);</p><pre><code>2.创建SqlSessionFactory工厂方法SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();SqlSEssionFatctory factory=builder.build(in);3.使用工厂产生SqlSeession对象SqlSession session= factory.openSession(); 4.使用SqlSession创建Dao接口的代理对象UserDao userDao=session.getMapper(UserDao.class);//UserDao是接口，包含未实现方法5.使用代理对象执行方法list&lt;User&gt; users=userDao.fandAll();dor(User user:users) {syste.out.println(user);}//打印所有的user6.释放资源session.close();in.close();</code></pre><p>读取配置文件，准备一个工厂生产一个为我们提供dao实现的对象，有了这个dao就能实现查询数据库等操作。，实现功能，最后释放资源。</p><p>mybatis两种数据库访问方式，xml方式和注解方式，见上。</p><h4 id="mybatis也可以实现dao实现。"><a href="#mybatis也可以实现dao实现。" class="headerlink" title="mybatis也可以实现dao实现。"></a>mybatis也可以实现dao实现。</h4><p>在test步骤中改变第3,4步，使用工厂创建dao对象<br>UserDao userdao = new UserDaoImpl(factory);<br>去掉session.close();</p><pre><code>编写UserDaoImpl类继承UsreDao接口private SqlSessionFactory factory；public UserDaoImpl（SqlSessionFactory factory）｛    this.factory=factory;｝public findAll(){    1.使用工厂创建SqlSession对象    SqlSession session = factory.openSession();    2.使用session查询所有方法    List&lt;user&gt; users=session.selectList(satement:&quot;com.itz.dao.UserDao.fandAll&quot;);//需要namespace+id，才能定位要执行的sql语句。    3.返回查询结果    return users；}例.11.读取配置文件inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//1.读取配置文件时，有相对路径（src.com....），绝对路径(d:mai/it/...),部署后都不能用。2.使用类加载器，他只能读取类路径的配置文件；使用ServletContext对象的getRealPath（）。2.创建SqlSessionFactory工厂方法SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();SqlSEssionFatctory factory=builder.build(in);//创建工厂，Myabtis用了构建者模式，in代表什么呢？？？3.使用工厂产生SqlSeession对象SqlSession session= factory.openSession(); //如果用new 实现，每次更换实现方法是都需要改动实现方法名。重新部署，浪费时间。4.使用SqlSession创建Dao接口的代理对象UserDao userDao=session.getMapper(UserDao.class);//getmapper代理模式5.使用代理对象执行方法list&lt;User&gt; users=userDao.fandAll();for(User user:users) {syste.out.println(user);}//打印所有的user6.释放资源session.close();in.close();实现功能只需把上面例.1修改inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;).session.getMapper(UserDao.class);list&lt;User&gt; users=userDao.fandAll();for(User user:users) {syste.out.println(user);}session.close();in.close();例.1的2,3,4,5是为了更灵活的使用满足需求。</code></pre><p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E7%9A%84%E5%88%86%E6%9E%90.png" alt></p><h3 id="自定义Mybatis的分析"><a href="#自定义Mybatis的分析" class="headerlink" title="自定义Mybatis的分析"></a>自定义Mybatis的分析</h3><pre><code>mybatis 使用代理dao的方式增删改查时做了什么？    1.创建代理对象    2.在代理对象中调用selectList。</code></pre><p>mybatis执行过程<br><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E5%88%86%E6%9E%90.png" alt></p><h3 id="JDBC是Java提供的一个操作数据库的API；"><a href="#JDBC是Java提供的一个操作数据库的API；" class="headerlink" title="JDBC是Java提供的一个操作数据库的API；"></a>JDBC是Java提供的一个操作数据库的API；</h3><p>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p><p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p><ol><li>优化获取和释放</li></ol><p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p><p>2.SQL统一管理，对数据库进行存取操作</p><p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p><p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p><p>3.生成动态SQL语句</p><p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p><p>Mybatis可以在配置文件中通过使用<if test="””"></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p><select id="getCountByInfo" parametertype="User" resulttype="int">        select count(*) from user        <where>            <if test="nickname!=null">                and nickname = #{nickname}             </if>            <if test="email!=null">                and email = #{email}             </if>        </where></select><p>就是通过昵称或email或者二者的组合查找用户数。</p><p>4.能够对结果集进行映射</p><p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p><p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mybatis概述&quot;&gt;&lt;a href=&quot;#Mybatis概述&quot; class=&quot;headerlink&quot; title=&quot;Mybatis概述&quot;&gt;&lt;/a&gt;Mybatis概述&lt;/h3&gt;&lt;p&gt;什么是框架&lt;br&gt;框架是整个或部分系统的可重用设计，表现为一组抽象构件及抽象构件实例
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="java" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/java/"/>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java项目基础知识</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-11T13:08:33.143Z</published>
    <updated>2020-02-23T08:18:38.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>学习项目时<br>构件新项目使用到maven了解类似maven的内容</p><p>Maven是一个软件项目管理工具</p><p>创建项目时可选择该种模式开发项目，是一种为了开发管理的工具。</p><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>Maven(翻译为”专家”，”内行”)是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。</p><p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><p>1.项目构建<br>项目构建过程包括【清理项目】→【编译项目】→【测试项目】→【生成测试报告】→【打包项目】→【部署项目】这几个步骤，这六个步骤就是一个项目的完整构建过程。</p><p>2.依赖管理<br>依赖指的是jar包之间的相互依赖，比如我们搭建一个Struts2的开发框架时，光光有struts2-core-2.3.16.3.jar这个jar包是不行的，struts2-core-2.3.16.3.jar还依赖其它的jar包，依赖管理指的就是使用Maven来管理项目中使用到的jar包，Maven管理的方式就是“自动下载项目所需要的jar包，统一管理jar包之间的依赖关系”。</p><p>3.使用Maven的好处<br>　　Maven中使用约定，约定java源代码代码必须放在哪个目录下，编译好的java代码又必须放到哪个目录下，这些目录都有明确的约定。<br>  Maven的每一个动作都拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程<br>　　只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮我们处理其他事情<br>　　使用Maven可以进行项目高度自动化构建，依赖管理(这是使用Maven最大的好处)，仓库管理。</p><p>4.Maven项目的目录约定<br>MavenProjectRoot(项目根目录)<br>   |—-src<br>   |     |—-main<br>   |     |         |—-java ——存放项目的.java文件<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |     |—-test<br>   |     |         |—-java ——存放所有测试.java文件，如JUnit测试类<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |—-target ——项目输出位置<br>   |—-pom.xml —-用于标识该项目是一个Maven项目</p><p>pom.xml文件中的内容如下：</p> <?xml version="1.0" encoding="UTF-8"?><p>  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0   http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>      <!--所有的Maven项目都必须配置这四个配置项--><br>      <modelVersion>4.0.0</modelVersion><br>      <!--groupId指的是项目名的项目组，默认就是包名--><br>      <groupId>cn.gacl.maven.hello</groupId><br>     <!--artifactId指的是项目中的某一个模块，默认命名方式是"项目名-模块名"--><br>     <artifactId>hello-first</artifactId><br>     <!--version指的是版本，这里使用的是Maven的快照版本--><br>     <version>SNAPSHOT-0.0.1</version><br> </project></p><p>编写好java代码后，使用Maven编译完成之后，在项目根目录下会生成一个target文件夹</p><p>在终端使用”mvn clean”命令清除编译结果，也就是把编译生成的target文件夹删掉</p><p>Maven中心仓库下载到本地的jar包的默认存放在”${user.home}/.m2/repository”中，${user.home}表示当前登录系统的用户目录(如”C:\Users\gacl”)，我们可以自己设置下载到本地时的jar包的存放目录，在“E:\”目录下创建一个“repository”文件夹，找到apache-maven-3.2.3\conf目录下的settings.xml文件，编辑setting.xml文件在后面加上代码 <localRepository>E:/repository</localRepository></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h2&gt;&lt;p&gt;学习项目时&lt;br&gt;构件新项目使用到maven了解类似maven的内容&lt;/p&gt;
&lt;p&gt;Maven是一个软件项目管理工具
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="maven" scheme="https://cnawesome.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>java线程</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E7%BA%BF%E7%A8%8B/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-11T13:08:33.138Z</published>
    <updated>2020-02-24T03:21:33.637Z</updated>
    
    <content type="html"><![CDATA[<pre><code>runnable 无返回类型 callable 有返回类型</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>//申请线程池<br>ExecutorServide service = Executors.newFixedCachedPool();//线程受线程池指挥拿取任务<br>ExecutorServide service = Executors.newCacheThreadPool();<br>ScheduleExecutorServide service = Executor.newScheduleThreadPool();//已一定的频率执行线程</p><p>//关闭线程池<br>service.shutdown();</p><p>WorkStealPool//线程窃取，线程主动去拿任务执行</p><p>static class R implentments runnable{ //runnable 任务实现类<br>        int time;</p><pre><code>R(int t){    this.time=t;}    public void run (){            timeUnit.MILLISECONDS.sleep(500);    }    system.out.println(time+&quot; &quot;+Thread.currentThread().getName());</code></pre><p>}</p><p>service.execute(new R(1000));//开启线程执行runable任务</p><h3 id="处理大型数组求和问题"><a href="#处理大型数组求和问题" class="headerlink" title="处理大型数组求和问题"></a>处理大型数组求和问题</h3><p>1.ForkJoinPool方式</p><p>public class T1_ForkJoinPool {<br>    static int[]nums= new int[1000000];<br>    static final int MAX_NUM=50000;<br>    static Random r=new Random();</p><pre><code>static {    for(int i=0;i&lt;nums.length;i++)     {        nums[i]=r.nextInt();    }    System.out.println(Arrays.stream(nums).sum());//stream api,把数组转化为流}static class AddTask extends RecursiveAction{ //继承forkjoin类    int start,end;    AddTask(int s,int e) {        start=s;        end=e;    }    @Override    protected void compute() {        if(end-start&lt;=MAX_NUM)         {            long sum = 0L;            for(int i=start;i&lt;end;i++) sum += nums[i];            System.out.println(&quot;from:&quot;+start+&quot; to:&quot;+end+&quot;=&quot;+sum);        }        else        {            int middle=start+(end-start)/2;            AddTask subTask1=new AddTask(start, middle);            AddTask subTask2=new AddTask(middle, end);            subTask1.fork();            subTask2.fork();        }    }}public static void main(String[] args) throws IOException {    ForkJoinPool fjp=new ForkJoinPool();    AddTask task=new AddTask(0, nums.length);    fjp.execute(task);    System.in.read();}</code></pre><p>}</p><p>大多数使用的线程池来自于threadpoolExecutor</p><p>//自定义线程池<br>public class threadpoolExecutor｛｝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;runnable 无返回类型 
callable 有返回类型&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;//申请线程池&lt;br&gt;E
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://cnawesome.github.io/tags/java/"/>
    
      <category term="线程" scheme="https://cnawesome.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java笔记1</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-11T13:08:33.129Z</published>
    <updated>2020-04-19T15:08:59.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能.</p><p>代理模式包含如下角色：</p><pre><code>ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。RealSubject：真实主题角色，是实现抽象主题接口的类。Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</code></pre><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p><p>###静态代理<br>在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类.</p><p>代码案例：</p><p>复制代码<br>// 接口<br>    interface IStar {<br>        void sing();<br>    }</p><pre><code>// 真实对象class LDHStar implements IStar {    @Override    public void sing() {        System.out.println(&quot;刘德华唱歌&quot;);    }}// 代理类需要有真实对象的控制权 (引用)class ProxyManger implements IStar {    // 真实对象的引用    private IStar star;    public ProxyManger() {        super();    }    public ProxyManger(IStar star) {        super();        this.star = star;    }    @Override    public void sing() {</code></pre><p>　　　　　　System.out.println(“唱歌前准备”);<br>    　　　 star.sing();<br>   　　　　System.out.println(“善后工作”);        }<br>    }<br>class Test{<br>public static void main(String[] args) {<br>            // 创建明星对象<br>            IStar ldh = new LDHStar();<br>            ProxyManger proxy = new ProxyManger(ldh);<br>            proxy.sing();<br>        }<br>}</p><p>静态代理总结:<br>优点：<br>可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。</p><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect</p><p>复制代码<br>//目标类接口<br>interface IDog{<br>    void run();<br>}<br>//目标类<br>class GunDog implements IDog{</p><pre><code>@Overridepublic void run() {    System.out.println(&quot;猎狗在跑&quot;);}</code></pre><p>}<br>class DogUtils{<br>    public static void method1() {<br>        System.out.println(“增强方式一”);<br>    }</p><pre><code>public static void method2() {    System.out.println(&quot;增强方式二&quot;);}</code></pre><p>}<br>class MyInvocationHandle implements InvocationHandler{<br>    private Object target;<br>    public void setTarget(Object target) {<br>        this.target = target;<br>    }<br>    @Override<br>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            DogUtils.method1();<br>            method.invoke(target, args);<br>            DogUtils.method2();<br>            return null;<br>    }<br>}<br>    //生产代理对象的工厂****<br> class MyProxyFactory{<br>    public static Object getProxy(Object target) {<br>        MyInvocationHandle handle = new MyInvocationHandle();<br>        handle.setTarget(target);<br>        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle);<br>        return proxy;<br>    }<br> }<br>public class ProxyDemo {<br>    public static void main(String[] args) {<br>      IDog dog = new GunDog();<br>      IDog proxy =(IDog) MyProxyFactory.getProxy(dog);<br>      proxy.run();<br>    }</p><p>总结：<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。</p><h4 id="基于接口的动态代理-1"><a href="#基于接口的动态代理-1" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>动态代理的特点：<br>字节码随用随创建，随用随加载。<br>作用：不更改源码的情况下，对功能加强。<br>分类：<br>    基于接口的动态代理，<br>    基于类的动态代理，</p><p>基于接口的动态代理，<br>    涉及的类：proxy，提供者：jdk官方</p><p>如何创建代理对象：<br>    使用proxy类的newProxyInstance();<br>创建对象的要求：<br>    被代理类至少实现一个接口，否则不能使用。</p><p>newProxyInstance()的参数：<br>    classLoader：类加载器，用于加载代理对象字节码，和被代理对象使用相同类加载器。<br>    class【】数组：用与让代理对象和被代理对象有相同的方法。<br>    InvactionHandler：用于提供增强的代码，如何代理，一般使用匿名内部类</p><p>Producer Producer = Proxy.wProxyInstance(producer.getClass().getClassLoader(),<br>                    producer.getClass().getInterfaces(),<br>                    new InvactionHandler(){</p><pre><code>    /*该匿名内部类的invoke()作用是：执行该被代理对象的任何接口的方法都经过该方法        proxy :代理对象的引用        method：当前执行的方法         args：当前执行的方法所需的参数    */    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{        //提供增强的代码    }}    )</code></pre><p>####基于子类的动态代理</p><p>Cglib代理<br>上面的静态代理和动态代理模式有个相同点就是都要求目标对象是实现一个接口的对象,然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象,</p><p>这时就可以使用继承目标类以目标对象子类的方式实现代理,这种方法就叫做:Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p><p>使用JDK动态代理有一个限制,就是被代理的对象必须实现一个或多个接口,若想代理没有实现接口的类,就需要使用Cglib实现.</p><p>由于Cglib是第三方提供的所以使用的时候需要导入相关的jar包<br>cglb<br>asm</p><p>代码案例：</p><p>复制代码<br>public class CglibProxy {</p><pre><code>public static void main(String[] args) {    int[] arr = new int[100000];    for (int i = 0; i &lt; arr.length; i++) {        arr[i] = (int) (Math.random() * 1000);    }    //实例化一个增强器，也就是cglib中的一个class generator    Enhancer enhancer = new Enhancer();    //设置目标类    enhancer.setSuperclass(ArraySort2.class);    //设置拦截对象，这里直接使用匿名内部类写法    enhancer.setCallback(new MethodInterceptor() {        @Override        public Object intercept(Object object , Method method, Object[] args, MethodProxy proxy) throws Throwable {            String sortName = method.getName();            switch (sortName) {            case &quot;bubbleSort&quot;:                sortName = &quot;冒泡排序&quot;;                break;            case &quot;selectSort&quot;:                sortName = &quot;选择排序&quot;;                break;            case &quot;quickSort&quot;:                sortName = &quot;快速排序&quot;;                break;            default:                break;            }            long start = System.currentTimeMillis();            //此处一定要使用proxy的invokeSuper方法来调用目标类的方法            proxy.invokeSuper(object, args);            long end = System.currentTimeMillis();            System.out.println(&quot;本次&quot; + sortName + &quot;的执行时间为: &quot; + (end -start) + &quot;ms&quot;);            return null;        }    });    //生成代理类并返回一个实例    ArraySort2 arraySort = (ArraySort2) enhancer.create();    arraySort.bubbleSort(arr);    arraySort.selectSort(arr);    arraySort.quickSort(arr);}</code></pre><p>}<br>class ArraySort2{<br>    public void quickSort(int[] arr) {<br>        Arrays.sort(arr);<br>    }<br>    public void selectSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            for (int j = i+1; j &lt; arr.length; j++) {<br>                if (arr[i] &gt; arr[j]) {<br>                    int temp = 0;<br>                    temp = arr[i];<br>                    arr[i] = arr[j];<br>                    arr[j] = temp;<br>                }<br>            }<br>        }<br>    }<br>    public void bubbleSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            for (int j = 0; j &lt; arr.length - 1 - i; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    int temp = 0;<br>                    temp = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = temp;<br>                }<br>            }<br>        }<br>    }<br>}</p><p>基于子类的动态代理<br>    涉及的类：Enhancer，提供者：第三方Cglib</p><p>如何创建代理对象：<br>    使用Enhancer类的create方法;<br>创建对象的要求：<br>    被代理类不能是最终类。</p><p>create()的参数：<br>    class：用于指定被代理对象字节码。<br>    callback：用于提供增强的代码，如何代理，一般使用callbac的子类接口方法MethodInterceptor()</p><p>Enhancer.create(producer.getClass(),new MethodInterceptor(){</p><pre><code> /*该匿名内部类的intercept(()作用是：执行该被代理对象的任何接口的方法都经过该方法                    proxy :代理对象的引用                    method：当前执行的方法                     args：当前执行的方法所需的参数                */public Object intercept(Object proxy,Method method,Object[] args) throws Throwable    </code></pre><p>}<br>)</p><h3 id="Java虚拟机类加载机制"><a href="#Java虚拟机类加载机制" class="headerlink" title="Java虚拟机类加载机制"></a>Java虚拟机类加载机制</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的</p><p><img src="/2020/03/11/java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD.ng" alt></p><p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。</p><p>加载<br>通过全限定类名来获取定义此类的二进制字节流。<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。<br>验证<br>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。<br>此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。<br>元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。<br>第二阶段，保证不存在不符合 Java 语言规范的元数据信息。<br>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。<br>符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。<br>可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>准备<br>为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配。</p><p>解析<br>虚拟机将常量池内的符号引用替换为直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p><p>初始化<br>到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 <clinit>() 方法的过程。</clinit></p><p><clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <init>() ,<clinit>() 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <clinit>()，虚拟机会保证在子类的 <clinit>() 方法执行之前，父类的 <clinit>() 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></clinit></clinit></clinit></init></clinit></p><p><clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法。</clinit></clinit></p><p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 <clinit>() 方法完毕。</clinit></clinit></clinit></p><h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><p>遇到new、getstatic 和 putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应场景是：使用 new 实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。<br>对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。（而一个接口在初始化时，并不要求其父接口全部都完成了初始化）<br>虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），<br>虚拟机会先初始化这个主类。<br>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>第5种情况，我暂时看不懂。</p><p>以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</p><p>通过子类引用父类的静态字段，不会导致子类初始化。<br>通过数组定义来引用类，不会触发此类的初始化。MyClass[] cs = new MyClass[10];<br>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p><p>将 class 文件二进制数据放入方法区内，然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。</p><p>目前类加载器却在类层次划分、OSGi、热部署、代码加密等领域非常重要，我们运行任何一个 Java 程序都会涉及到类加载器。</p><h4 id="类的唯一性和类加载器"><a href="#类的唯一性和类加载器" class="headerlink" title="类的唯一性和类加载器"></a>类的唯一性和类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p><p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。<br>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、 isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><p>Bootstrap 类加载器是用 C++ 实现的，是虚拟机自身的一部分，如果获取它的对象，将会返回 null；扩展类加载器和应用类加载器是独立于虚拟机外部，为 Java 语言实现的，均继承自抽象类 java.lang.ClassLoader ，开发者可直接使用这两个类加载器。</p><p>Application 类加载器对象可以由 ClassLoader.getSystemClassLoader() 方法的返回，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>双亲委派模型对于保证 Java 程序的稳定运作很重要，例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p><h4 id="自定义类加载器分为两步："><a href="#自定义类加载器分为两步：" class="headerlink" title="自定义类加载器分为两步："></a>自定义类加载器分为两步：</h4><p>继承 java.lang.ClassLoader<br>重写父类的 findClass() 方法<br>针对第 1 步，为什么要继承 ClassLoader 这个抽象类，而不继承 AppClassLoader 呢？<br>因为它和 ExtClassLoader 都是 Launcher 的静态内部类，其访问权限是缺省的包访问权限。<br>static class AppClassLoader extends URLClassLoader{…}</p><p>第 2 步，JDK 的 loadCalss() 方法在所有父类加载器无法加载的时候，会调用本身的 findClass() 方法来进行类加载，因此我们只需重写 findClass() 方法找到类的二进制数据即可。</p><p>下面我自定义了一个简单的类加载器，并加载一个简单的类。</p><p>首先是需要被加载的简单类：</p><p>// 存放于D盘根目录<br>public class Test {</p><pre><code>public static void main(String[] args) {    System.out.println(&quot;Test类已成功加载运行！&quot;);    ClassLoader classLoader = Test.class.getClassLoader();    System.out.println(&quot;加载我的classLoader：&quot; + classLoader);    System.out.println(&quot;classLoader.parent：&quot; + classLoader.getParent());}</code></pre><p>}<br>并使用 javac -encoding utf8 Test.java 编译成 Test.class 文件。</p><p>类加载器代码如下：</p><p>import java.io.*;</p><p>public class MyClassLoader extends ClassLoader {<br>    @Override<br>    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br>        // 加载D盘根目录下指定类名的class<br>        String clzDir = “D:\“ + File.separatorChar<br>                + name.replace(‘.’, File.separatorChar) + “.class”;<br>        byte[] classData = getClassData(clzDir);</p><pre><code>    if (classData == null) {        throw new ClassNotFoundException();    } else {        return defineClass(name, classData, 0, classData.length);    }}private byte[] getClassData(String path) {    try (InputStream ins = new FileInputStream(path);         ByteArrayOutputStream baos = new ByteArrayOutputStream()    ) {        int bufferSize = 4096;        byte[] buffer = new byte[bufferSize];        int bytesNumRead = 0;        while ((bytesNumRead = ins.read(buffer)) != -1) {            baos.write(buffer, 0, bytesNumRead);        }        return baos.toByteArray();    } catch (IOException e) {        e.printStackTrace();    }    return null;}</code></pre><p>}<br>使用类加载器加载调用 Test 类：</p><p>public class MyClassLoaderTest {<br>    public static void main(String[] args) throws Exception {<br>        // 指定类加载器加载调用<br>        MyClassLoader classLoader = new MyClassLoader();<br>        classLoader.loadClass(“Test”).getMethod(“test”).invoke(null);<br>    }<br>}<br>输出信息：</p><p>Copy<br>Test.test()已成功加载运行！<br>加载我的classLoader：class MyClassLoader<br>classLoader.parent：class sun.misc.Launcher$AppClassLoader</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="java基础" scheme="https://cnawesome.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git基础（下）</title>
    <link href="https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A02-0/"/>
    <id>https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A02-0/</id>
    <published>2020-03-11T13:08:31.206Z</published>
    <updated>2020-01-30T09:03:19.138Z</updated>
    
    <content type="html"><![CDATA[<p>本地仓库使用如下命令初始化：</p><p>$ git init<br>之后使用如下命令添加远程库：</p><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:hahah/ftpmanage.git<br>然后使用</p><p>$ git push -u origin master<br>出现如下错误：</p><p>error: src refspec master does not match any.<br>error: failed to push some refs to ‘git@github.com:hahaha/ftpmanage.git’<br>原因：</p><p>本地仓库为空</p><p>解决方法：使用如下命令 添加文件；</p><p>$ git add add.php </p><p>$ git commit -m “init files”</p><p>$ git pull origin master</p><p>远程上传成功！</p><h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><p>git branch (branchname)</p><p>切换分支命令:</p><p>git checkout (branchname)</p><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><p>git merge </p><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><p>$ mkdir gitdemo<br>$ cd gitdemo/<br>$ git init<br>Initialized empty Git repository…<br>$ touch README<br>$ git add README<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) 3b58100] 第一次版本提交<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README</p><h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><pre><code> 列出分支列出分支基本命令：</code></pre><p>git branch<br>没有参数时，git branch 会列出你在本地的分支。</p><p>$ git branch</p><ul><li>master<br>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</li></ul><p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p><p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。</p><p>$ git branch testing<br>$ git branch</p><ul><li>master<br>testing<br>现在我们可以看到，有了一个新分支 testing。</li></ul><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><p>$ ls<br>README<br>$ echo ‘runoob.com’ &gt; test.txt<br>$ git add .<br>$ git commit -m ‘add test.txt’<br>[master 3e92c19] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>$ ls<br>README        test.txt<br>$ git checkout testing<br>Switched to branch ‘testing’<br>$ ls<br>README<br>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><p>$ git checkout -b newtest<br>Switched to a new branch ‘newtest’<br>$ git rm test.txt<br>rm ‘test.txt’<br>$ ls<br>README<br>$ touch runoob.php<br>$ git add .<br>$ git commit -am ‘removed test.txt、add runoob.php’<br>[newtest c1501a2] removed test.txt、add runoob.php<br> 2 files changed, 1 deletion(-)<br> create mode 100644 runoob.php<br> delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><p>删除分支<br>删除分支命令：</p><p>git branch -d (branchname)<br>例如我们要删除 testing 分支：</p><p>$ git branch</p><ul><li>master<br>testing<br>$ git branch -d testing<br>Deleted branch testing (was 85fc7e7).<br>$ git branch</li><li>master<br>分支合并<br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</li></ul><p>git merge<br>$ git branch</p><ul><li>master<br>newtest<br>$ ls<br>README        test.txt<br>$ git merge newtest<br>Updating 3e92c19..c1501a2<br>Fast-forward<br>runoob.php | 0<br>test.txt   | 1 -<br>2 files changed, 1 deletion(-)<br>create mode 100644 runoob.php<br>delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</li></ul><p>合并完后就可以删除分支:</p><p>$ git branch -d newtest<br>Deleted branch newtest (was c1501a2).<br>删除后， 就只剩下 master 分支了：</p><p>$ git branch</p><ul><li>master</li></ul><p>合并冲突<br>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><p>$ git branch</p><ul><li>master<br>$ cat runoob.php<br>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</li></ul><?phpecho 'runoob';?><p>创建 change_site 分支：</p><p>$ git checkout -b change_site<br>Switched to a new branch ‘change_site’<br>$ vim runoob.php<br>$ head -3 runoob.php<br><?phpecho 'runoob';?><br>$ git commit -am ‘changed the runoob.php’<br>[change_site 7774248] changed the runoob.php<br> 1 file changed, 3 insertions(+)</p><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ cat runoob.php<br>$ vim runoob.php    # 修改内容如下<br>$ cat runoob.php<br><?phpecho 1;?><br>$ git diff<br>diff –git a/runoob.php b/runoob.php<br>index e69de29..ac60739 100644<br>— a/runoob.php<br>+++ b/runoob.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo 1;+?><br>$ git commit -am ‘修改代码’<br>[master c68142b] 修改代码<br> 1 file changed, 3 insertions(+)<br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><p>$ git merge change_site<br>Auto-merging runoob.php<br>CONFLICT (content): Merge conflict in runoob.php<br>Automatic merge failed; fix conflicts and then commit the result.</p><p>$ cat runoob.php     # 代开文件，看到冲突内容<br>&lt;?php<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>echo 1;<br>=======<br>echo ‘runoob’;</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>change_site<br>?&gt;<br>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>$ vim runoob.php<br>$ cat runoob.php<br><?phpecho 1;echo 'runoob';?><br>$ git diff<br>diff –cc runoob.php<br>index ac60739,b63d7d7..0000000<br>— a/runoob.php<br>+++ b/runoob.php<br>@@@ -1,3 -1,3 +1,4 @@@<br>  &lt;?php<br> +echo 1;</p><ul><li>echo ‘runoob’;<br>?&gt;<br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</li></ul><p>$ git status -s<br>UU runoob.php<br>$ git add runoob.php<br>$ git status -s<br>M  runoob.php<br>$ git commit<br>[master 88afe0e] Merge branch ‘change_site’<br>现在我们成功解决了合并中的冲突，并提交了结果。</p><p>##Git 查看提交历史<br>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><p>$ git log<br>commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)<br>Merge: c68142b 7774248<br>Author: runoob <a href="mailto:&#116;&#101;&#115;&#x74;&#x40;&#x72;&#117;&#110;&#x6f;&#x6f;&#98;&#46;&#99;&#111;&#x6d;">&#116;&#101;&#115;&#x74;&#x40;&#x72;&#117;&#110;&#x6f;&#x6f;&#98;&#46;&#99;&#111;&#x6d;</a><br>Date:   Fri May 3 15:55:58 2019 +0800</p><pre><code>Merge branch &apos;change_site&apos;</code></pre><p>commit c68142b562c260c3071754623b08e2657b4c6d5b<br>Author: runoob <a href="mailto:&#116;&#x65;&#115;&#116;&#64;&#114;&#117;&#110;&#111;&#111;&#98;&#x2e;&#x63;&#111;&#109;">&#116;&#x65;&#115;&#116;&#64;&#114;&#117;&#110;&#111;&#111;&#98;&#x2e;&#x63;&#111;&#109;</a><br>Date:   Fri May 3 15:52:12 2019 +0800</p><pre><code>修改代码</code></pre><p>commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)<br>Author: runoob <a href="mailto:&#x74;&#101;&#x73;&#116;&#x40;&#x72;&#x75;&#x6e;&#111;&#x6f;&#x62;&#x2e;&#99;&#111;&#109;">&#x74;&#101;&#x73;&#116;&#x40;&#x72;&#x75;&#x6e;&#111;&#x6f;&#x62;&#x2e;&#99;&#111;&#109;</a><br>Date:   Fri May 3 15:49:26 2019 +0800</p><pre><code>changed the runoob.php</code></pre><p>commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00<br>Author: runoob <a href="mailto:&#x74;&#101;&#115;&#116;&#64;&#114;&#x75;&#110;&#x6f;&#x6f;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#101;&#115;&#116;&#64;&#114;&#x75;&#110;&#x6f;&#x6f;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a><br>Date:   Fri May 3 15:35:32 2019 +0800<br>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><p>$ git log –oneline<br>$ git log –oneline<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>c68142b 修改代码<br>7774248 (change_site) changed the runoob.php<br>c1501a2 removed test.txt、add runoob.php<br>3e92c19 add test.txt<br>3b58100 第一次版本提交<br>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</li></ul><p>你也可以用 –reverse 参数来逆向显示所有日志。</p><p>$ git log –reverse –oneline<br>3b58100 第一次版本提交<br>3e92c19 add test.txt<br>c1501a2 removed test.txt、add runoob.php<br>7774248 (change_site) changed the runoob.php<br>c68142b 修改代码<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><p>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in<br>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><p>$ git log –oneline –before={3.weeks.ago} –after={2010-04-18} –no-merges<br>5469e2d Git 1.7.1-rc2<br>d43427d Documentation/remote-helpers: Fix typos and improve language<br>272a36b Fixup: Second argument may be any arbitrary string<br>b6c8d2d Documentation/remote-helpers: Add invocation section<br>5ce4f4e Documentation/urls: Rewrite to accomodate transport::address<br>00b84e9 Documentation/remote-helpers: Rewrite description<br>03aa87e Documentation: Describe other situations where -z affects git diff<br>77bc694 rebase-interactive: silence warning when no commits rewritten<br>636db2c t3301: add tests to use –format=”%N”</p><p>Git 标签<br>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><p>$ git tag -a v1.0<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li></ul><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><p>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 (tag: v0.9) 第一次版本提交<br>如果我们要查看所有标签可以使用以下命令：</li></ul><p>$ git tag<br>v0.9<br>v1.0<br>指定标签信息命令：</p><p>git tag -a <tagname> -m “runoob.com标签”<br>PGP签名标签命令：</tagname></p><p>git tag -s <tagname> -m “runoob.com标签”</tagname></p><p>Git 远程仓库(Github)<br>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 Github 简明教程。</p><p>添加远程库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><p>git remote add [shortname] [url]<br>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com/注册。" target="_blank" rel="noopener">https://github.com/注册。</a></p><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成 SSH Key：</p><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“<br>后面的 <a href="mailto:your_email@youremail.com">your_email@youremail.com</a> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。</p><p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p><p>左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p><p>添加成功后界面如下所示</p><p>为了验证是否成功，输入以下命令：</p><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Hi tianqixin! You’ve successfully authenticated, but GitHub does not provide shell access.<br>以下命令说明我们已成功连上 Github。</p><p>之后登录后点击” New repository “ 如下图所示：</p><p>之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p>创建成功后，显示如下信息：</p><p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p><p>$ mkdir runoob-git-test                     # 创建测试目录<br>$ cd runoob-git-test/                       # 进入测试目录<br>$ echo “# 菜鸟教程 Git 测试” &gt;&gt; README.md     # 创建 README.md 文件并写入内容<br>$ ls                                        # 查看目录下的文件<br>README<br>$ git init                                  # 初始化<br>$ git add README.md                         # 添加文件<br>$ git commit -m “添加 README.md 文件”        # 提交并备注信息<br>[master (root-commit) 0205aab] 添加 README.md 文件<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p><h1 id="提交到-Github"><a href="#提交到-Github" class="headerlink" title="提交到 Github"></a>提交到 Github</h1><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git<br>$ git push -u origin master<br>以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。</p><p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p><p>git remote<br>实例<br>$ git remote<br>origin<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p><p>提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><p>git fetch<br>该命令执行完后需要执行git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><p>git merge<br>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><p>接下来我们在 Github 上点击” README.md” 并在线修改它:</p><p>然后我们在本地更新修改。</p><p>$ git fetch origin<br>remote: Counting objects: 3, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>From github.com:tianqixin/runoob-git-test<br>   0205aab..febd8ed  master     -&gt; origin/master<br>以上信息”0205aab..febd8ed master -&gt; origin/master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p><p>$ git merge origin/master<br>Updating 0205aab..febd8ed<br>Fast-forward<br> README.md | 1 +<br> 1 file changed, 1 insertion(+)<br>查看 README.md 文件内容：</p><p>$ cat README.md </p><h1 id="菜鸟教程-Git-测试"><a href="#菜鸟教程-Git-测试" class="headerlink" title="菜鸟教程 Git 测试"></a>菜鸟教程 Git 测试</h1><h2 id="第一次修改内容"><a href="#第一次修改内容" class="headerlink" title="第一次修改内容"></a>第一次修改内容</h2><p>推送到远程仓库<br>推送你的新分支与数据到某个远端仓库命令:</p><p>git push [alias] [branch]<br>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><p>$ touch runoob-test.txt      # 添加文件<br>$ git add runoob-test.txt<br>$ git commit -m “添加到远程”<br>master 69e702d] 添加到远程<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 runoob-test.txt</p><p>$ git push origin master    # 推送到 Github<br>重新回到我们的 Github 仓库，可以看到文件以及提交上来了：</p><p>删除远程仓库<br>删除远程仓库你可以使用命令：</p><p>git remote rm [别名]<br>实例<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><h1 id="添加仓库-origin2"><a href="#添加仓库-origin2" class="headerlink" title="添加仓库 origin2"></a>添加仓库 origin2</h1><p>$ git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git</p><p>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><h1 id="删除仓库-origin2"><a href="#删除仓库-origin2" class="headerlink" title="删除仓库 origin2"></a>删除仓库 origin2</h1><p>$ git remote rm origin2<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><p>##Git 服务器搭建<br>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p><p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p><p>接下来我们将以 Centos 为例搭建 Git 服务器。</p><p>1、安装Git<br>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>$ yum install git<br>接下来我们 创建一个git用户组和用户，用来运行git服务：</p><p>$ groupadd git<br>$ useradd git -g git<br>2、创建证书登录<br>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p><p>如果没有该文件创建它：</p><p>$ cd /home/git/<br>$ mkdir .ssh<br>$ chmod 755 .ssh<br>$ touch .ssh/authorized_keys<br>$ chmod 644 .ssh/authorized_keys<br>3、初始化Git仓库<br>首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令：</p><p>$ cd /home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo/<br>$ cd gitrepo</p><p>$ git init –bare runoob.git<br>Initialized empty Git repository in /home/gitrepo/runoob.git/<br>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p><p>$ chown -R git:git runoob.git<br>4、克隆仓库<br>$ git clone <a href="mailto:git@192.168.45.4">git@192.168.45.4</a>:/home/gitrepo/runoob.git<br>Cloning into ‘runoob’…<br>warning: You appear to have cloned an empty repository.<br>Checking connectivity… done.<br>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本地仓库使用如下命令初始化：&lt;/p&gt;
&lt;p&gt;$ git init&lt;br&gt;之后使用如下命令添加远程库：&lt;/p&gt;
&lt;p&gt;$ git remote add origin &lt;a href=&quot;mailto:git@github.com&quot;&gt;git@github.com&lt;/a&gt;:haha
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="git" scheme="https://cnawesome.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git基础（上）</title>
    <link href="https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-11T13:08:31.203Z</published>
    <updated>2020-01-30T09:02:00.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h2><p>Git 是一个开源的分布式版本控制系统，<br>                                用于敏捷高效地处理任何或小或大的项目。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h4 id="Git与SVN区别"><a href="#Git与SVN区别" class="headerlink" title="Git与SVN区别"></a>Git与SVN区别</h4><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>Git 与 SVN 区别点：</p><pre><code>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</code></pre><p><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/001.jpg" alt></p><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>本章节我们将为大家介绍 Git 的工作流程。</p><p>一般工作流程如下：</p><pre><code>克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</code></pre><p><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/002.png" alt></p><h2 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h2><p>基本概念</p><p>我们先来理解下Git 工作区、暂存区和版本库概念</p><p>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：<br><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/003.jpg" alt></p><h2 id="git创建仓库"><a href="#git创建仓库" class="headerlink" title="git创建仓库"></a>git创建仓库</h2><p>git init<br>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p><p>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><p>使用方法<br>使用当前目录作为Git仓库，我们只需使它初始化。</p><p>git init<br>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库 。/////</p><p>git init newrepo<br>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><p>$ git add *.c<br>$ git add README<br>$ git commit -m ‘初始化项目版本’<br>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><p>git clone //常用<br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p><p>克隆仓库的命令格式为：</p><p>git clone <repo><br>如果我们需要克隆到指定的目录，可以使用以下命令格式：</repo></p><p>git clone <repo> <directory><br>参数说明：</directory></repo></p><p>repo:Git 仓库。<br>directory:本地目录。<br>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><p>$ git clone git://github.com/schacon/grit.git<br>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：<br>$ git clone git://github.com/schacon/grit.git mygrit</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><p>获取与创建项目命令<br>git init<br>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p><p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 runoob 项目：</p><p>$ mkdir runoob<br>$ cd runoob/<br>$ git init<br>Initialized empty Git repository in /Users/tianqixin/www/runoob/.git/</p><h1 id="在-www-runoob-git-目录初始化空-Git-仓库完毕。"><a href="#在-www-runoob-git-目录初始化空-Git-仓库完毕。" class="headerlink" title="在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。"></a>在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。</h1><p>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p><p>ls -a<br>.    ..    .git<br>git clone<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p><p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p><p> git clone [url]<br>[url] 为你想要复制的项目，就可以了。</p><p>例如我们克隆 Github 上的项目：</p><p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:schacon/simplegit.git<br>Cloning into ‘simplegit’…<br>remote: Counting objects: 13, done.<br>remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13<br>Receiving objects: 100% (13/13), done.<br>Resolving deltas: 100% (2/2), done.<br>Checking connectivity… done.<br>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p><p>$ cd simplegit/<br>$ ls<br>README   Rakefile lib<br>上述操作将复制该项目的全部记录。</p><p>$ ls -a<br>.        ..       .git     README   Rakefile lib<br>$ cd .git<br>$ ls<br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><hr><p>基本快照<br>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。</p><p>git status</p><p>$ touch README<br>$ touch hello.php<br>$ ls<br>README        hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$<br>/////git status 命令用于查看项目的当前状态。/////</p><p>接下来我们执行 git add 命令来添加文件：</p><p>$ git add README hello.php<br>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p><p>$ git status -s<br>A  README<br>A  hello.php<br>$<br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。</p><p>现在我们修改 README 文件：</p><p>$ vim README<br>在 README 添加以下内容：# Runoob Git 测试，然后保存退出。</p><p>再执行一下 git status：</p><p>$ git status -s<br>AM README<br>A  hello.php<br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 git add 命令将其添加到缓存中：</p><p>$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p><p>git status<br>//////git status 以查看在你上次提交之后是否有修改。//////</p><p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p><p>$ git status<br>On branch master</p><p>Initial commit</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</file></p><pre><code>new file:   READMEnew file:   hello.php</code></pre><p>git diff<br>执行 git diff 来查看执行 git status 的结果的详细信息。</p><p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p><p>尚未缓存的改动：git diff<br>查看已缓存的改动： git diff –cached<br>查看已缓存的与未缓存的所有改动：git diff HEAD<br>显示摘要而非整个 diff：git diff –stat<br>在 hello.php 文件中输入以下内容：</p><?phpecho '菜鸟教程：www.runoob.com';?><p>$ git status -s<br>A  README<br>AM hello.php</p><p>$ git diff<br>diff –git a/hello.php b/hello.php<br>index e69de29..69b5711 100644<br>— a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.runoob.com';+?></p><p>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p><p>接下来我们来查看下 git diff –cached 的执行效果：</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff –cached<br>diff –git a/README b/README<br>new file mode 100644<br>index 0000000..8f87495<br>— /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+# Runoob Git 测试<br>diff –git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..69b5711<br>— /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.runoob.com';+?></p><p>git commit<br>////使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。/////</p><p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p><p>$ git config –global user.name ‘runoob’<br>$ git config –global user.email <a href="mailto:test@runoob.com">test@runoob.com</a><br>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) d32cf1f] 第一次版本提交<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php</p><p>现在我们已经记录了快照。如果我们再执行 git status:</p><p>$ git status</p><h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><p>nothing to commit (working directory clean)<br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。</p><p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p><h1 id="Please-enter-the-commit-message-for-your-changes-Lines-starting"><a href="#Please-enter-the-commit-message-for-your-changes-Lines-starting" class="headerlink" title="Please enter the commit message for your changes. Lines starting"></a>Please enter the commit message for your changes. Lines starting</h1><h1 id="with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit"><a href="#with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit" class="headerlink" title="with ‘#’ will be ignored, and an empty message aborts the commit."></a>with ‘#’ will be ignored, and an empty message aborts the commit.</h1><h1 id="On-branch-master-1"><a href="#On-branch-master-1" class="headerlink" title="On branch master"></a>On branch master</h1><h1 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</file></h1><p>#</p><h1 id="modified-hello-php"><a href="#modified-hello-php" class="headerlink" title="modified:   hello.php"></a>modified:   hello.php</h1><p>#<br>~<br>~<br>“.git/COMMIT_EDITMSG” 9L, 257C<br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><p>git commit -a<br>我们先修改 hello.php 文件为以下内容：</p><?phpecho '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';?><p>再执行以下命令：</p><p>git commit -am ‘修改 hello.php 文件’<br>[master 71ee2cb] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)</p><p>git reset HEAD<br>git reset HEAD 命令用于取消已缓存的内容。</p><p>我们先改动文件 README 文件，内容如下：</p><h1 id="Runoob-Git-测试"><a href="#Runoob-Git-测试" class="headerlink" title="Runoob Git 测试"></a>Runoob Git 测试</h1><h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p>hello.php 文件修改为：</p><?phpecho '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';?><p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p><p>$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.php<br>$ git reset HEAD hello.php<br>Unstaged changes after reset:<br>M    hello.php<br>$ git status -s<br>M  README<br> M hello.php<br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p><p>$ git commit -m ‘修改’<br>[master f50cfda] 修改<br> 1 file changed, 1 insertion(+)<br>$ git status -s<br> M hello.php<br>可以看到 hello.php 文件的修改并未提交。</p><p>这时我们可以使用以下命令将 hello.php 的修改提交：</p><p>$ git commit -am ‘修改 hello.php 文件’<br>[master 760f74d] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>$ git status<br>On branch master<br>nothing to commit, working directory clean</p><p>/////简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。////</p><p>git rm<br>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作<br>git rm <file></file></p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f<br>git rm -f <file></file></p><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可<br>git rm –cached <file></file></p><p>如我们删除 hello.php文件：</p><p>$ git rm hello.php<br>rm ‘hello.php’<br>$ ls<br>README</p><p>不从工作区中删除文件：<br>$ git rm –cached README<br>rm ‘README’<br>$ ls<br>README</p><p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：<br>git rm –r * </p><p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。<br>git mv<br>git mv 命令用于移动或重命名一个文件、目录、软连接。</p><p>我们先把刚移除的 README 添加回来：</p><p>$ git add README<br>然后对其重名:</p><p>$ git mv README  README.md<br>$ ls<br>README.md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git学习&quot;&gt;&lt;a href=&quot;#Git学习&quot; class=&quot;headerlink&quot; title=&quot;Git学习&quot;&gt;&lt;/a&gt;Git学习&lt;/h2&gt;&lt;p&gt;Git 是一个开源的分布式版本控制系统，&lt;br&gt;                                用于
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="git" scheme="https://cnawesome.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>二叉树（c版本）</title>
    <link href="https://cnawesome.github.io/2020/03/11/c%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://cnawesome.github.io/2020/03/11/c%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-11T13:08:31.186Z</published>
    <updated>2020-03-07T11:29:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>btree.h  //二叉树头文件，用于声明数据类型和相关函数</p><pre><code>#ifndef __BTREE_H__#define __BTREE_H__#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef char dataype_bt;  //声明二叉树中存放的数据类型，便于后续更改typedef struct btreenode{   //二叉树的节点结构：存放的数据 该节点的左子节点地址及右子节点地址。注意和单链表的区别，二叉树是非线性存储，单链表是线性存储    dataype_bt data;    struct btreenode *lchild,*rchild;}btree_node,*btree_pnode;extern btree_pnode create_btree1(void);    //通过递归方法创建一个二叉树extern void create_btree(btree_pnode *T);  //通过递归方法创建一个二叉树（功能同上）extern void pre_order(btree_pnode t);    //采用递归方法先序遍历extern void unpre_order(btree_pnode t);  //采用非递归方法先序遍历extern void mid_order(btree_pnode t);    //采用递归方法中序遍历extern void post_order(btree_pnode t);   //采用递归方法后序遍历extern void level_order(btree_pnode t);  //层次遍历extern void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t);   //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述#endifbtree.c  //二叉树相关函数的实现方法#include &quot;btree.h&quot;#include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲#include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲btree_pnode create_btree1(void)        //通过递归方法创建一个二叉树{    dataype_bt ch;    btree_pnode new;    scanf(&quot;%c&quot;,&amp;ch);    if(&apos;#&apos;==ch)    {        return NULL;    }    else    {        //创建根结点        new=(btree_pnode)malloc(sizeof(btree_node));        if(NULL==new)        {            perror(&quot;malloc&quot;);            exit(-1);        }        new-&gt;data=ch;        //用相同方法创建左子数        new-&gt;lchild=create_btree1();        //用相同方法创建右子数        new-&gt;rchild=create_btree1();    }    return new;}void create_btree(btree_pnode *T)          //通过递归方法创建一个二叉树（功能同上）{    dataype_bt ch;    scanf(&quot;%c&quot;,&amp;ch);    if(&apos;#&apos;==ch)    {        return ;    }    else{        //创建根结点        (*T)=(btree_pnode)malloc(sizeof(btree_node));        if(NULL==(*T))        {            perror(&quot;malloc&quot;);            exit(-1);        }        (*T)-&gt;data=ch;        //用相同方法创建左子数        create_btree(&amp;((*T)-&gt;lchild));        //用相同方法创建右子数        create_btree(&amp;((*T)-&gt;rchild));    }}void pre_order(btree_pnode t)          //采用递归方法先序遍历{    if(t!=NULL)    {        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);        //先序遍历左子树        pre_order(t-&gt;lchild);        //先序遍历右子树        pre_order(t-&gt;rchild);    }}void unpre_order(btree_pnode t)          //采用非递归方法先序遍历{    linklist top;//top为指向栈顶结点的指针    top=stack_create();//初始化链式栈    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲        linklist stack_create()        {            linklist s;            if((s=(linklist)malloc(sizeof(listnode)))==NULL){                puts(&quot;malloc failed&quot;);                return NULL;            }            s-&gt;next=NULL;            return s;        }    */    while(t!=NULL || !(stack_empty(top))){        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲            int stack_empty(linklist s)  //判断栈是否为空（1表示空，0表示非空）            {                return (s-&gt;next==NULL ? 1:0);            }        */        if(t!=NULL){            printf(&quot;%c&quot;,t-&gt;data);            if(t-&gt;rchild !=NULL)                stack_push(top,t-&gt;rchild);  //入栈            /*                该函数包含的头文件 和 实现方法如下：                #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲                int stack_push(linklist s,datatype_ls value)  //入栈                {                    linklist p;                    if((p=(linklist)malloc(sizeof(listnode)))==NULL)                    {                        puts(&quot;malloc failed&quot;);                        return -1;                    }                    p-&gt;data = value;                    p-&gt;next=s-&gt;next;                    s-&gt;next = p;                    return 0;                }            */            t=t-&gt;lchild;        }else            t=stack_pop(top);   //出栈        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲            datatype_ls stack_pop(linklist s)    //出栈            {                linklist p;                datatype_ls ret;                p=s-&gt;next;                s-&gt;next=p-&gt;next;                ret=p-&gt;data;                free(p);                p=NULL;                return ret;            }        */    }    stack_free(top);   //释放栈    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲        void stack_free(linklist s)    //释放栈        {            linklist p;            printf(&quot;free:&quot;);            p=s;            while(p)            {                s=s-&gt;next;                printf(&quot;%d &quot;,p-&gt;data);                free(p);                p=s;            }            putchar(10);    //10 表示 回车符（&apos;\n&apos;）        }    */}void mid_order(btree_pnode t)           //采用递归方法中序遍历{    if(t!=NULL)    {        //中序遍历左子树        mid_order(t-&gt;lchild);        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);        //中序遍历右子树        mid_order(t-&gt;rchild);    }}void post_order(btree_pnode t)          //采用递归方法后序遍历{    if(t!=NULL)    {        //后序遍历左子树        post_order(t-&gt;lchild);        //后序遍历右子树        post_order(t-&gt;rchild);        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);    }}void level_order(btree_pnode t)        //层次遍历{    link_pqueue q;    init_linkqueue(&amp;q);//初始化链式队列    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲        void init_linkqueue(link_pqueue *Q)     //创建队列        {            //申请front和rear的空间            *Q=(link_pqueue)malloc(sizeof(link_queue));            if((*Q)==NULL)            {                perror(&quot;malloc&quot;);                exit(-1);            }            //申请头结点空间            (*Q)-&gt;front=(linkqueue_pnode)malloc(sizeof(linkqueue_node));            if((*Q)-&gt;front==NULL)            {                perror(&quot;malloc&quot;);                exit(-1) ;            }            (*Q)-&gt;front-&gt;next=NULL;            (*Q)-&gt;rear=(*Q)-&gt;front;            return;        }    */    while(t!=NULL)    {        //访问t指向的结点数据        printf(&quot;%c&quot;,t-&gt;data);        //当t的左指针不为空，则入队        if(t-&gt;lchild!=NULL)            in_linkqueue(t-&gt;lchild,q);        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲            bool in_linkqueue(datatype data,link_pqueue q)   //入队            {                linkqueue_pnode  new;                //申请数据结点空间                new=(linkqueue_pnode)malloc(sizeof(linkqueue_node));                if(new==NULL)                {                    puts(&quot;入队失败！&quot;);                    return false;                }                //将数据存储在申请的空间                new-&gt;data=data;                //将new指向的结点插入到链式队列中                new-&gt;next=q-&gt;rear-&gt;next;            //这里等价于new-&gt;next = NULL;                q-&gt;rear-&gt;next=new;                         //让rear指针指向新的队尾结点                q-&gt;rear=q-&gt;rear-&gt;next;          //等价于q-&gt;rear = new;                return true;            }        */        //当t的右指针不为空，则入队        if(t-&gt;rchild!=NULL)            in_linkqueue(t-&gt;rchild,q);        //队列不为空，则出队        if(!is_empty_linkqueue(q))            out_linkqueue(q,&amp;t);        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲            bool out_linkqueue(link_pqueue q,datatype *D)      //出队            {                linkqueue_pnode t;                //判断队列是否空                if(is_empty_linkqueue(q)){                    printf(&quot;队列已空!\n&quot;);                    return false;                }                //出队                t=q-&gt;front;                q-&gt;front =q-&gt;front-&gt;next;                *D=q-&gt;front-&gt;data;                free(t);                return true;            }        */        else            break;    }    free_linkqueue(q);           //释放队列    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲        void free_linkqueue(link_pqueue q)           //释放队列        {            link_pqueue p;            p = q-&gt;front;            while(p)            {                q-&gt;front = q-&gt;front-&gt;next;                free(p);                p = q-&gt;front;            }            free(q);        }    */}void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t)      //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述{    printf(&quot;%s&quot;,str);    pfun(t);    puts(&quot;&quot;);}</code></pre><p>————————————————<br>版权声明：本文为CS80960356DN博主「许新天」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39148042/article/details/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39148042/article/details/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;btree.h  //二叉树头文件，用于声明数据类型和相关函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __BTREE_H__
#define __BTREE_H__

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://cnawesome.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c" scheme="https://cnawesome.github.io/tags/c/"/>
    
  </entry>
  
</feed>
