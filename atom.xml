<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Life &amp;&amp; Study</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cnawesome.github.io/"/>
  <updated>2020-03-09T10:31:51.352Z</updated>
  <id>https://cnawesome.github.io/</id>
  
  <author>
    <name>alei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis(1)</title>
    <link href="https://cnawesome.github.io/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cnawesome.github.io/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-11T13:08:33.228Z</published>
    <updated>2020-03-09T10:31:51.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h3><p>什么是框架<br>框架是整个或部分系统的可重用设计，表现为一组抽象构件及抽象构件实例之间加护的方法。（抽象方法，或者实例方法）。<br>它是软件开发中解决问题的一套方案。</p><p>mybatis 持久层框架</p><p>springnvc 表现层框架</p><p>spring 不属于这三个框架</p><p>三层架构<br>        表现层：张世数据<br>        业务层：处理业务需求<br>        持久层：数据库交互 </p><p><img src="01%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt=""></p><p>持久层技术解决方案<br>    jdbc技术：<br>            connection<br>            preparedstatement<br>            resultset<br>    jdbc开发不够便捷 </p><p>持久层连接数据库池过程<br>    1，加载驱动<br>    2，创建连接<br>    3，创建statement<br>    …</p><p><img src="02%E6%8C%81%E4%B9%85%E5%B1%82%E6%80%BB%E5%9B%BE.jpg" alt=""><br>Mybatis 通过xml或注解的方式 执行各种statment，并通过java对象和sql的动态参数进行映射形成最终sql语句，最后通过mabatis执行sql语句并返回。<br>利用ORM思想，对jdbc进行封装，屏蔽了jdbc api底层的访问问题</p><p>ORM （object relational  mapping）对象关系映射<br>即把数据库的表与实体类及实体类的属性对应起来，让我们可以操作实体类就实现数据表。</p><p>如何做到？<br>目前，我们需要把实体类的属性与数据库的字段名保持一致。</p><h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><p>1，创建maven工程，xml 添加依赖坐标（在官网上找依赖语句），同时写上数据库依赖，日志依赖，junit依赖等。<br>2，创建实体类<br>3，创建mybatis主配置文件（SqlMapConfig.xml）<br>4，创建映射配置文件(UserDao.xml)</p><p>环境搭建的注意事项:<br>1,创建UserDao.xml和UserDao.java是，名称是为了和我们之前的知识保持一致。在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper。所以UserDAO和UserMapper是一样的。</p><p>2.在idea创建目录是，它和包是不一样的 ，包创建时：comit.dao 是三级结构<br>    目录创建时 com.it.dao是一级目录。</p><p>3.mybatis的映射配置文件位置必须和dao接口的包结构相同。</p><p>4.映射文件的mapper标签namespace属性的取值必须是 dao接口的全限定类名。</p><p>5.映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法类,resulttype取值为应用接口的对象。</p><p>作用：按3，4，5配置后，无需再写dao的实现类，由mybatis直接实现。</p><p>UserDao.xml<br><img src="UserDaoxml.PNG" alt=""></p><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"><!-- mybatis主配置文件 --><configuration>    <!-- 配制环境 -->    <environments default="mysql">        <!-- 配置mysql的环境 -->        <environments id="mysql">            <!-- 配置事务类型 -->            <transactionManager type="JDBC"></transactionManager>            <!-- 配置数据源（连接池） -->            <dateSource type="POOLED">                <!-- 配置连接数据库的四个基本信息 -->                <property name="driver" value="com.mysql.jdbc.Driver"></property>                <property name="url" value="jdbc：mysql：//localhost:3306/eesy_mybatis"></property>                <property name="username" value="root"></property>                <property name="passsword" value="123456"></property>            </dateSource><pre><code>    &lt;/environments&gt;&lt;/environments&gt;&lt;!-- 使用配置文件实现maybatis数据库操作，指定映射配置文件的位置，映射配置文件指的是每个dao的独立配置文件 --&gt;    &lt;mappers&gt;    &lt;mapper resource=&quot;com.itz.dao.UserDao.xml&quot; /&gt;&lt;/mappers&gt;或者&lt;!-- 使用注解实现maybatis数据库操作，移除UserDao.xml，在dao接口方法上使用@select注解，指定sql语句。在mapper中，指定class属性是dao接口的全限定类名 --&gt;    &lt;mappers&gt;    &lt;mapper resource=&quot;com.itz.dao.UserDao&quot; /&gt;&lt;/mappers&gt;</code></pre></configuration><p>环境搭建好后</p><h4 id="test步骤"><a href="#test步骤" class="headerlink" title="test步骤"></a>test步骤</h4><p>1.读取配置文件<br>    inputStream in=Pesources.getResourceAsStream(“SqlMapConfig.xml”);</p><pre><code>2.创建SqlSessionFactory工厂方法SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();SqlSEssionFatctory factory=builder.build(in);3.使用工厂产生SqlSeession对象SqlSession session= factory.openSession(); 4.使用SqlSession创建Dao接口的代理对象UserDao userDao=session.getMapper(UserDao.class);//UserDao是接口，包含未实现方法5.使用代理对象执行方法list&lt;User&gt; users=userDao.fandAll();dor(User user:users) {syste.out.println(user);}//打印所有的user6.释放资源session.close();in.close();</code></pre><p>读取配置文件，准备一个工厂生产一个为我们提供dao实现的对象，有了这个dao就能实现查询数据库等操作。，实现功能，最后释放资源。</p><p>mybatis两种数据库访问方式，xml方式和注解方式，见上。</p><h4 id="mybatis也可以实现dao实现。"><a href="#mybatis也可以实现dao实现。" class="headerlink" title="mybatis也可以实现dao实现。"></a>mybatis也可以实现dao实现。</h4><p>在test步骤中改变第3,4步，使用工厂创建dao对象<br>UserDao userdao = new UserDaoImpl(factory);<br>去掉session.close();</p><pre><code>编写UserDaoImpl类继承UsreDao接口private SqlSessionFactory factory；public UserDaoImpl（SqlSessionFactory factory）｛    this.factory=factory;｝public findAll(){    1.使用工厂创建SqlSession对象    SqlSession session = factory.openSession();    2.使用session查询所有方法    List&lt;user&gt; users=session.selectList(satement:&quot;com.itz.dao.UserDao.fandAll&quot;);//需要namespace+id，才能定位要执行的sql语句。    3.返回查询结果    return users；}例.11.读取配置文件inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//1.读取配置文件时，有相对路径（src.com....），绝对路径(d:mai/it/...),部署后都不能用。2.使用类加载器，他只能读取类路径的配置文件；使用ServletContext对象的getRealPath（）。2.创建SqlSessionFactory工厂方法SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();SqlSEssionFatctory factory=builder.build(in);//创建工厂，Myabtis用了构建者模式，in代表什么呢？？？3.使用工厂产生SqlSeession对象SqlSession session= factory.openSession(); //如果用new 实现，每次更换实现方法是都需要改动实现方法名。重新部署，浪费时间。4.使用SqlSession创建Dao接口的代理对象UserDao userDao=session.getMapper(UserDao.class);//getmapper代理模式5.使用代理对象执行方法list&lt;User&gt; users=userDao.fandAll();for(User user:users) {syste.out.println(user);}//打印所有的user6.释放资源session.close();in.close();实现功能只需把上面例.1修改inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;).session.getMapper(UserDao.class);list&lt;User&gt; users=userDao.fandAll();for(User user:users) {syste.out.println(user);}session.close();in.close();例.1的2,3,4,5是为了更灵活的使用满足需求。</code></pre><p><img src="%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E7%9A%84%E5%88%86%E6%9E%90.png" alt=""></p><h3 id="自定义Mybatis的分析"><a href="#自定义Mybatis的分析" class="headerlink" title="自定义Mybatis的分析"></a>自定义Mybatis的分析</h3><pre><code>mybatis 使用代理dao的方式增删改查时做了什么？    1.创建代理对象    2.在代理对象中调用selectList。</code></pre><p>mybatis执行过程<br><img src="%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E5%88%86%E6%9E%90.png" alt=""></p><h3 id="JDBC是Java提供的一个操作数据库的API；"><a href="#JDBC是Java提供的一个操作数据库的API；" class="headerlink" title="JDBC是Java提供的一个操作数据库的API；"></a>JDBC是Java提供的一个操作数据库的API；</h3><p>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p><p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p><ol><li>优化获取和释放</li></ol><p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p><p>2.SQL统一管理，对数据库进行存取操作</p><p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p><p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p><p>3.生成动态SQL语句</p><p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p><p>Mybatis可以在配置文件中通过使用<if test=””></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p><select id="getCountByInfo" parameterType="User" resultType="int">        select count(*) from user        <where>            <if test="nickname!=null">                and nickname = #{nickname}             </if>            <if test="email!=null">                and email = #{email}             </if>        </where></select><p>就是通过昵称或email或者二者的组合查找用户数。</p><p>4.能够对结果集进行映射</p><p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p><p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mybatis概述&quot;&gt;&lt;a href=&quot;#Mybatis概述&quot; class=&quot;headerlink&quot; title=&quot;Mybatis概述&quot;&gt;&lt;/a&gt;Mybatis概述&lt;/h3&gt;&lt;p&gt;什么是框架&lt;br&gt;框架是整个或部分系统的可重用设计，表现为一组抽象构件及抽象构件实例
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="java" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/java/"/>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java项目基础知识</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-11T13:08:33.143Z</published>
    <updated>2020-02-23T08:18:38.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>学习项目时<br>构件新项目使用到maven了解类似maven的内容</p><p>Maven是一个软件项目管理工具</p><p>创建项目时可选择该种模式开发项目，是一种为了开发管理的工具。</p><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>Maven(翻译为”专家”，”内行”)是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。</p><p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p><p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p><p>1.项目构建<br>项目构建过程包括【清理项目】→【编译项目】→【测试项目】→【生成测试报告】→【打包项目】→【部署项目】这几个步骤，这六个步骤就是一个项目的完整构建过程。</p><p>2.依赖管理<br>依赖指的是jar包之间的相互依赖，比如我们搭建一个Struts2的开发框架时，光光有struts2-core-2.3.16.3.jar这个jar包是不行的，struts2-core-2.3.16.3.jar还依赖其它的jar包，依赖管理指的就是使用Maven来管理项目中使用到的jar包，Maven管理的方式就是“自动下载项目所需要的jar包，统一管理jar包之间的依赖关系”。</p><p>3.使用Maven的好处<br>　　Maven中使用约定，约定java源代码代码必须放在哪个目录下，编译好的java代码又必须放到哪个目录下，这些目录都有明确的约定。<br>  Maven的每一个动作都拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程<br>　　只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮我们处理其他事情<br>　　使用Maven可以进行项目高度自动化构建，依赖管理(这是使用Maven最大的好处)，仓库管理。</p><p>4.Maven项目的目录约定<br>MavenProjectRoot(项目根目录)<br>   |—-src<br>   |     |—-main<br>   |     |         |—-java ——存放项目的.java文件<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |     |—-test<br>   |     |         |—-java ——存放所有测试.java文件，如JUnit测试类<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |—-target ——项目输出位置<br>   |—-pom.xml —-用于标识该项目是一个Maven项目</p><p>pom.xml文件中的内容如下：</p> <?xml version="1.0" encoding="UTF-8"?><p>  <project xmlns="http://maven.apache.org/POM/4.0.0"   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0   http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>      <!--所有的Maven项目都必须配置这四个配置项--><br>      <modelVersion>4.0.0</modelVersion><br>      <!--groupId指的是项目名的项目组，默认就是包名--><br>      <groupId>cn.gacl.maven.hello</groupId><br>     <!--artifactId指的是项目中的某一个模块，默认命名方式是"项目名-模块名"--><br>     <artifactId>hello-first</artifactId><br>     <!--version指的是版本，这里使用的是Maven的快照版本--><br>     <version>SNAPSHOT-0.0.1</version><br> </project></p><p>编写好java代码后，使用Maven编译完成之后，在项目根目录下会生成一个target文件夹</p><p>在终端使用”mvn clean”命令清除编译结果，也就是把编译生成的target文件夹删掉</p><p>Maven中心仓库下载到本地的jar包的默认存放在”${user.home}/.m2/repository”中，${user.home}表示当前登录系统的用户目录(如”C:\Users\gacl”)，我们可以自己设置下载到本地时的jar包的存放目录，在“E:\”目录下创建一个“repository”文件夹，找到apache-maven-3.2.3\conf目录下的settings.xml文件，编辑setting.xml文件在后面加上代码 <localRepository>E:/repository</localRepository></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h2&gt;&lt;p&gt;学习项目时&lt;br&gt;构件新项目使用到maven了解类似maven的内容&lt;/p&gt;
&lt;p&gt;Maven是一个软件项目管理工具
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="maven" scheme="https://cnawesome.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>java线程</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E7%BA%BF%E7%A8%8B/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-11T13:08:33.138Z</published>
    <updated>2020-02-24T03:21:33.637Z</updated>
    
    <content type="html"><![CDATA[<pre><code>runnable 无返回类型 callable 有返回类型</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>//申请线程池<br>ExecutorServide service = Executors.newFixedCachedPool();//线程受线程池指挥拿取任务<br>ExecutorServide service = Executors.newCacheThreadPool();<br>ScheduleExecutorServide service = Executor.newScheduleThreadPool();//已一定的频率执行线程</p><p>//关闭线程池<br>service.shutdown();</p><p>WorkStealPool//线程窃取，线程主动去拿任务执行</p><p>static class R implentments runnable{ //runnable 任务实现类<br>        int time;</p><pre><code>R(int t){    this.time=t;}    public void run (){            timeUnit.MILLISECONDS.sleep(500);    }    system.out.println(time+&quot; &quot;+Thread.currentThread().getName());</code></pre><p>}</p><p>service.execute(new R(1000));//开启线程执行runable任务</p><h3 id="处理大型数组求和问题"><a href="#处理大型数组求和问题" class="headerlink" title="处理大型数组求和问题"></a>处理大型数组求和问题</h3><p>1.ForkJoinPool方式</p><p>public class T1_ForkJoinPool {<br>    static int[]nums= new int[1000000];<br>    static final int MAX_NUM=50000;<br>    static Random r=new Random();</p><pre><code>static {    for(int i=0;i&lt;nums.length;i++)     {        nums[i]=r.nextInt();    }    System.out.println(Arrays.stream(nums).sum());//stream api,把数组转化为流}static class AddTask extends RecursiveAction{ //继承forkjoin类    int start,end;    AddTask(int s,int e) {        start=s;        end=e;    }    @Override    protected void compute() {        if(end-start&lt;=MAX_NUM)         {            long sum = 0L;            for(int i=start;i&lt;end;i++) sum += nums[i];            System.out.println(&quot;from:&quot;+start+&quot; to:&quot;+end+&quot;=&quot;+sum);        }        else        {            int middle=start+(end-start)/2;            AddTask subTask1=new AddTask(start, middle);            AddTask subTask2=new AddTask(middle, end);            subTask1.fork();            subTask2.fork();        }    }}public static void main(String[] args) throws IOException {    ForkJoinPool fjp=new ForkJoinPool();    AddTask task=new AddTask(0, nums.length);    fjp.execute(task);    System.in.read();}</code></pre><p>}</p><p>大多数使用的线程池来自于threadpoolExecutor</p><p>//自定义线程池<br>public class threadpoolExecutor｛｝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;runnable 无返回类型 
callable 有返回类型&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;//申请线程池&lt;br&gt;E
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://cnawesome.github.io/tags/java/"/>
    
      <category term="线程" scheme="https://cnawesome.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>代理模式，类加载器，</title>
    <link href="https://cnawesome.github.io/2020/03/11/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://cnawesome.github.io/2020/03/11/java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-11T13:08:33.129Z</published>
    <updated>2020-02-23T08:11:23.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能.</p><p>代理模式包含如下角色：</p><pre><code>ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。RealSubject：真实主题角色，是实现抽象主题接口的类。Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</code></pre><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p><p>###静态代理<br>在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类.</p><p>代码案例：</p><p>复制代码<br>// 接口<br>    interface IStar {<br>        void sing();<br>    }</p><pre><code>// 真实对象class LDHStar implements IStar {    @Override    public void sing() {        System.out.println(&quot;刘德华唱歌&quot;);    }}// 代理类需要有真实对象的控制权 (引用)class ProxyManger implements IStar {    // 真实对象的引用    private IStar star;    public ProxyManger() {        super();    }    public ProxyManger(IStar star) {        super();        this.star = star;    }    @Override    public void sing() {</code></pre><p>　　　　　　System.out.println(“唱歌前准备”);<br>    　　　 star.sing();<br>   　　　　System.out.println(“善后工作”);        }<br>    }<br>class Test{<br>public static void main(String[] args) {<br>            // 创建明星对象<br>            IStar ldh = new LDHStar();<br>            ProxyManger proxy = new ProxyManger(ldh);<br>            proxy.sing();<br>        }<br>}</p><p>静态代理总结:<br>优点：<br>可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。</p><h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect</p><p>复制代码<br>//目标类接口<br>interface IDog{<br>    void run();<br>}<br>//目标类<br>class GunDog implements IDog{</p><pre><code>@Overridepublic void run() {    System.out.println(&quot;猎狗在跑&quot;);}</code></pre><p>}<br>class DogUtils{<br>    public static void method1() {<br>        System.out.println(“增强方式一”);<br>    }</p><pre><code>public static void method2() {    System.out.println(&quot;增强方式二&quot;);}</code></pre><p>}<br>class MyInvocationHandle implements InvocationHandler{<br>    private Object target;<br>    public void setTarget(Object target) {<br>        this.target = target;<br>    }<br>    @Override<br>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            DogUtils.method1();<br>            method.invoke(target, args);<br>            DogUtils.method2();<br>            return null;<br>    }<br>}<br>    //生产代理对象的工厂****<br> class MyProxyFactory{<br>    public static Object getProxy(Object target) {<br>        MyInvocationHandle handle = new MyInvocationHandle();<br>        handle.setTarget(target);<br>        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle);<br>        return proxy;<br>    }<br> }<br>public class ProxyDemo {<br>    public static void main(String[] args) {<br>      IDog dog = new GunDog();<br>      IDog proxy =(IDog) MyProxyFactory.getProxy(dog);<br>      proxy.run();<br>    }</p><p>总结：<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。</p><h4 id="基于接口的动态代理-1"><a href="#基于接口的动态代理-1" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>动态代理的特点：<br>字节码随用随创建，随用随加载。<br>作用：不更改源码的情况下，对功能加强。<br>分类：<br>    基于接口的动态代理，<br>    基于类的动态代理，</p><p>基于接口的动态代理，<br>    涉及的类：proxy，提供者：jdk官方</p><p>如何创建代理对象：<br>    使用proxy类的newProxyInstance();<br>创建对象的要求：<br>    被代理类至少实现一个接口，否则不能使用。</p><p>newProxyInstance()的参数：<br>    classLoader：类加载器，用于加载代理对象字节码，和被代理对象使用相同类加载器。<br>    class【】数组：用与让代理对象和被代理对象有相同的方法。<br>    InvactionHandler：用于提供增强的代码，如何代理，一般使用匿名内部类</p><p>Producer Producer = Proxy.wProxyInstance(producer.getClass().getClassLoader(),<br>                    producer.getClass().getInterfaces(),<br>                    new InvactionHandler(){</p><pre><code>    /*该匿名内部类的invoke()作用是：执行该被代理对象的任何接口的方法都经过该方法        proxy :代理对象的引用        method：当前执行的方法         args：当前执行的方法所需的参数    */    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{        //提供增强的代码    }}    )</code></pre><p>####基于子类的动态代理</p><p>Cglib代理<br>上面的静态代理和动态代理模式有个相同点就是都要求目标对象是实现一个接口的对象,然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象,</p><p>这时就可以使用继承目标类以目标对象子类的方式实现代理,这种方法就叫做:Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p><p>使用JDK动态代理有一个限制,就是被代理的对象必须实现一个或多个接口,若想代理没有实现接口的类,就需要使用Cglib实现.</p><p>由于Cglib是第三方提供的所以使用的时候需要导入相关的jar包<br>cglb<br>asm</p><p>代码案例：</p><p>复制代码<br>public class CglibProxy {</p><pre><code>public static void main(String[] args) {    int[] arr = new int[100000];    for (int i = 0; i &lt; arr.length; i++) {        arr[i] = (int) (Math.random() * 1000);    }    //实例化一个增强器，也就是cglib中的一个class generator    Enhancer enhancer = new Enhancer();    //设置目标类    enhancer.setSuperclass(ArraySort2.class);    //设置拦截对象，这里直接使用匿名内部类写法    enhancer.setCallback(new MethodInterceptor() {        @Override        public Object intercept(Object object , Method method, Object[] args, MethodProxy proxy) throws Throwable {            String sortName = method.getName();            switch (sortName) {            case &quot;bubbleSort&quot;:                sortName = &quot;冒泡排序&quot;;                break;            case &quot;selectSort&quot;:                sortName = &quot;选择排序&quot;;                break;            case &quot;quickSort&quot;:                sortName = &quot;快速排序&quot;;                break;            default:                break;            }            long start = System.currentTimeMillis();            //此处一定要使用proxy的invokeSuper方法来调用目标类的方法            proxy.invokeSuper(object, args);            long end = System.currentTimeMillis();            System.out.println(&quot;本次&quot; + sortName + &quot;的执行时间为: &quot; + (end -start) + &quot;ms&quot;);            return null;        }    });    //生成代理类并返回一个实例    ArraySort2 arraySort = (ArraySort2) enhancer.create();    arraySort.bubbleSort(arr);    arraySort.selectSort(arr);    arraySort.quickSort(arr);}</code></pre><p>}<br>class ArraySort2{<br>    public void quickSort(int[] arr) {<br>        Arrays.sort(arr);<br>    }<br>    public void selectSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            for (int j = i+1; j &lt; arr.length; j++) {<br>                if (arr[i] &gt; arr[j]) {<br>                    int temp = 0;<br>                    temp = arr[i];<br>                    arr[i] = arr[j];<br>                    arr[j] = temp;<br>                }<br>            }<br>        }<br>    }<br>    public void bubbleSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            for (int j = 0; j &lt; arr.length - 1 - i; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    int temp = 0;<br>                    temp = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = temp;<br>                }<br>            }<br>        }<br>    }<br>}</p><p>基于子类的动态代理<br>    涉及的类：Enhancer，提供者：第三方Cglib</p><p>如何创建代理对象：<br>    使用Enhancer类的create方法;<br>创建对象的要求：<br>    被代理类不能是最终类。</p><p>create()的参数：<br>    class：用于指定被代理对象字节码。<br>    callback：用于提供增强的代码，如何代理，一般使用callbac的子类接口方法MethodInterceptor()</p><p>Enhancer.create(producer.getClass(),new MethodInterceptor(){</p><pre><code> /*该匿名内部类的intercept(()作用是：执行该被代理对象的任何接口的方法都经过该方法                    proxy :代理对象的引用                    method：当前执行的方法                     args：当前执行的方法所需的参数                */public Object intercept(Object proxy,Method method,Object[] args) throws Throwable    </code></pre><p>}<br>)</p><h3 id="Java虚拟机类加载机制"><a href="#Java虚拟机类加载机制" class="headerlink" title="Java虚拟机类加载机制"></a>Java虚拟机类加载机制</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的</p><p><img src="%E7%B1%BB%E5%8A%A0%E8%BD%BD.ng" alt=""></p><p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。</p><p>加载<br>通过全限定类名来获取定义此类的二进制字节流。<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。<br>验证<br>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。<br>此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。<br>元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。<br>第二阶段，保证不存在不符合 Java 语言规范的元数据信息。<br>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。<br>符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。<br>可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>准备<br>为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配。</p><p>解析<br>虚拟机将常量池内的符号引用替换为直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p><p>初始化<br>到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 <clinit>() 方法的过程。</p><p><clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <init>() ,<clinit>() 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <clinit>()，虚拟机会保证在子类的 <clinit>() 方法执行之前，父类的 <clinit>() 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p><clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法。</p><p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 <clinit>() 方法完毕。</p><h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><p>遇到new、getstatic 和 putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应场景是：使用 new 实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。<br>对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。（而一个接口在初始化时，并不要求其父接口全部都完成了初始化）<br>虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），<br>虚拟机会先初始化这个主类。<br>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>第5种情况，我暂时看不懂。</p><p>以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</p><p>通过子类引用父类的静态字段，不会导致子类初始化。<br>通过数组定义来引用类，不会触发此类的初始化。MyClass[] cs = new MyClass[10];<br>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p><p>将 class 文件二进制数据放入方法区内，然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。</p><p>目前类加载器却在类层次划分、OSGi、热部署、代码加密等领域非常重要，我们运行任何一个 Java 程序都会涉及到类加载器。</p><h4 id="类的唯一性和类加载器"><a href="#类的唯一性和类加载器" class="headerlink" title="类的唯一性和类加载器"></a>类的唯一性和类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p><p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。<br>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、 isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><p>Bootstrap 类加载器是用 C++ 实现的，是虚拟机自身的一部分，如果获取它的对象，将会返回 null；扩展类加载器和应用类加载器是独立于虚拟机外部，为 Java 语言实现的，均继承自抽象类 java.lang.ClassLoader ，开发者可直接使用这两个类加载器。</p><p>Application 类加载器对象可以由 ClassLoader.getSystemClassLoader() 方法的返回，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>双亲委派模型对于保证 Java 程序的稳定运作很重要，例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p><h4 id="自定义类加载器分为两步："><a href="#自定义类加载器分为两步：" class="headerlink" title="自定义类加载器分为两步："></a>自定义类加载器分为两步：</h4><p>继承 java.lang.ClassLoader<br>重写父类的 findClass() 方法<br>针对第 1 步，为什么要继承 ClassLoader 这个抽象类，而不继承 AppClassLoader 呢？<br>因为它和 ExtClassLoader 都是 Launcher 的静态内部类，其访问权限是缺省的包访问权限。<br>static class AppClassLoader extends URLClassLoader{…}</p><p>第 2 步，JDK 的 loadCalss() 方法在所有父类加载器无法加载的时候，会调用本身的 findClass() 方法来进行类加载，因此我们只需重写 findClass() 方法找到类的二进制数据即可。</p><p>下面我自定义了一个简单的类加载器，并加载一个简单的类。</p><p>首先是需要被加载的简单类：</p><p>// 存放于D盘根目录<br>public class Test {</p><pre><code>public static void main(String[] args) {    System.out.println(&quot;Test类已成功加载运行！&quot;);    ClassLoader classLoader = Test.class.getClassLoader();    System.out.println(&quot;加载我的classLoader：&quot; + classLoader);    System.out.println(&quot;classLoader.parent：&quot; + classLoader.getParent());}</code></pre><p>}<br>并使用 javac -encoding utf8 Test.java 编译成 Test.class 文件。</p><p>类加载器代码如下：</p><p>import java.io.*;</p><p>public class MyClassLoader extends ClassLoader {<br>    @Override<br>    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br>        // 加载D盘根目录下指定类名的class<br>        String clzDir = “D:\“ + File.separatorChar<br>                + name.replace(‘.’, File.separatorChar) + “.class”;<br>        byte[] classData = getClassData(clzDir);</p><pre><code>    if (classData == null) {        throw new ClassNotFoundException();    } else {        return defineClass(name, classData, 0, classData.length);    }}private byte[] getClassData(String path) {    try (InputStream ins = new FileInputStream(path);         ByteArrayOutputStream baos = new ByteArrayOutputStream()    ) {        int bufferSize = 4096;        byte[] buffer = new byte[bufferSize];        int bytesNumRead = 0;        while ((bytesNumRead = ins.read(buffer)) != -1) {            baos.write(buffer, 0, bytesNumRead);        }        return baos.toByteArray();    } catch (IOException e) {        e.printStackTrace();    }    return null;}</code></pre><p>}<br>使用类加载器加载调用 Test 类：</p><p>public class MyClassLoaderTest {<br>    public static void main(String[] args) throws Exception {<br>        // 指定类加载器加载调用<br>        MyClassLoader classLoader = new MyClassLoader();<br>        classLoader.loadClass(“Test”).getMethod(“test”).invoke(null);<br>    }<br>}<br>输出信息：</p><p>Copy<br>Test.test()已成功加载运行！<br>加载我的classLoader：class MyClassLoader<br>classLoader.parent：class sun.misc.Launcher$AppClassLoader</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="java基础" scheme="https://cnawesome.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git基础（下）</title>
    <link href="https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A02-0/"/>
    <id>https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A02-0/</id>
    <published>2020-03-11T13:08:31.206Z</published>
    <updated>2020-01-30T09:03:19.138Z</updated>
    
    <content type="html"><![CDATA[<p>本地仓库使用如下命令初始化：</p><p>$ git init<br>之后使用如下命令添加远程库：</p><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:hahah/ftpmanage.git<br>然后使用</p><p>$ git push -u origin master<br>出现如下错误：</p><p>error: src refspec master does not match any.<br>error: failed to push some refs to ‘git@github.com:hahaha/ftpmanage.git’<br>原因：</p><p>本地仓库为空</p><p>解决方法：使用如下命令 添加文件；</p><p>$ git add add.php </p><p>$ git commit -m “init files”</p><p>$ git pull origin master</p><p>远程上传成功！</p><h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><p>git branch (branchname)</p><p>切换分支命令:</p><p>git checkout (branchname)</p><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><p>git merge </p><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><p>$ mkdir gitdemo<br>$ cd gitdemo/<br>$ git init<br>Initialized empty Git repository…<br>$ touch README<br>$ git add README<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) 3b58100] 第一次版本提交<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README</p><h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><pre><code> 列出分支列出分支基本命令：</code></pre><p>git branch<br>没有参数时，git branch 会列出你在本地的分支。</p><p>$ git branch</p><ul><li>master<br>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</li></ul><p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p><p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。</p><p>$ git branch testing<br>$ git branch</p><ul><li>master<br>testing<br>现在我们可以看到，有了一个新分支 testing。</li></ul><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><p>$ ls<br>README<br>$ echo ‘runoob.com’ &gt; test.txt<br>$ git add .<br>$ git commit -m ‘add test.txt’<br>[master 3e92c19] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>$ ls<br>README        test.txt<br>$ git checkout testing<br>Switched to branch ‘testing’<br>$ ls<br>README<br>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><p>$ git checkout -b newtest<br>Switched to a new branch ‘newtest’<br>$ git rm test.txt<br>rm ‘test.txt’<br>$ ls<br>README<br>$ touch runoob.php<br>$ git add .<br>$ git commit -am ‘removed test.txt、add runoob.php’<br>[newtest c1501a2] removed test.txt、add runoob.php<br> 2 files changed, 1 deletion(-)<br> create mode 100644 runoob.php<br> delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><p>删除分支<br>删除分支命令：</p><p>git branch -d (branchname)<br>例如我们要删除 testing 分支：</p><p>$ git branch</p><ul><li>master<br>testing<br>$ git branch -d testing<br>Deleted branch testing (was 85fc7e7).<br>$ git branch</li><li>master<br>分支合并<br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</li></ul><p>git merge<br>$ git branch</p><ul><li>master<br>newtest<br>$ ls<br>README        test.txt<br>$ git merge newtest<br>Updating 3e92c19..c1501a2<br>Fast-forward<br>runoob.php | 0<br>test.txt   | 1 -<br>2 files changed, 1 deletion(-)<br>create mode 100644 runoob.php<br>delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</li></ul><p>合并完后就可以删除分支:</p><p>$ git branch -d newtest<br>Deleted branch newtest (was c1501a2).<br>删除后， 就只剩下 master 分支了：</p><p>$ git branch</p><ul><li>master</li></ul><p>合并冲突<br>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><p>$ git branch</p><ul><li>master<br>$ cat runoob.php<br>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</li></ul><?phpecho 'runoob';?><p>创建 change_site 分支：</p><p>$ git checkout -b change_site<br>Switched to a new branch ‘change_site’<br>$ vim runoob.php<br>$ head -3 runoob.php<br><?phpecho 'runoob';?><br>$ git commit -am ‘changed the runoob.php’<br>[change_site 7774248] changed the runoob.php<br> 1 file changed, 3 insertions(+)</p><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ cat runoob.php<br>$ vim runoob.php    # 修改内容如下<br>$ cat runoob.php<br><?phpecho 1;?><br>$ git diff<br>diff –git a/runoob.php b/runoob.php<br>index e69de29..ac60739 100644<br>— a/runoob.php<br>+++ b/runoob.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo 1;+?><br>$ git commit -am ‘修改代码’<br>[master c68142b] 修改代码<br> 1 file changed, 3 insertions(+)<br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><p>$ git merge change_site<br>Auto-merging runoob.php<br>CONFLICT (content): Merge conflict in runoob.php<br>Automatic merge failed; fix conflicts and then commit the result.</p><p>$ cat runoob.php     # 代开文件，看到冲突内容<br>&lt;?php<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>echo 1;<br>=======<br>echo ‘runoob’;</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>change_site<br>?&gt;<br>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>$ vim runoob.php<br>$ cat runoob.php<br><?phpecho 1;echo 'runoob';?><br>$ git diff<br>diff –cc runoob.php<br>index ac60739,b63d7d7..0000000<br>— a/runoob.php<br>+++ b/runoob.php<br>@@@ -1,3 -1,3 +1,4 @@@<br>  &lt;?php<br> +echo 1;</p><ul><li>echo ‘runoob’;<br>?&gt;<br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</li></ul><p>$ git status -s<br>UU runoob.php<br>$ git add runoob.php<br>$ git status -s<br>M  runoob.php<br>$ git commit<br>[master 88afe0e] Merge branch ‘change_site’<br>现在我们成功解决了合并中的冲突，并提交了结果。</p><p>##Git 查看提交历史<br>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><p>$ git log<br>commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)<br>Merge: c68142b 7774248<br>Author: runoob <a href="mailto:&#116;&#101;&#x73;&#116;&#64;&#114;&#117;&#110;&#x6f;&#111;&#98;&#x2e;&#99;&#x6f;&#109;">&#116;&#101;&#x73;&#116;&#64;&#114;&#117;&#110;&#x6f;&#111;&#98;&#x2e;&#99;&#x6f;&#109;</a><br>Date:   Fri May 3 15:55:58 2019 +0800</p><pre><code>Merge branch &apos;change_site&apos;</code></pre><p>commit c68142b562c260c3071754623b08e2657b4c6d5b<br>Author: runoob <a href="mailto:&#116;&#x65;&#115;&#x74;&#x40;&#114;&#117;&#x6e;&#111;&#x6f;&#98;&#x2e;&#99;&#111;&#x6d;">&#116;&#x65;&#115;&#x74;&#x40;&#114;&#117;&#x6e;&#111;&#x6f;&#98;&#x2e;&#99;&#111;&#x6d;</a><br>Date:   Fri May 3 15:52:12 2019 +0800</p><pre><code>修改代码</code></pre><p>commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)<br>Author: runoob <a href="mailto:&#x74;&#x65;&#115;&#x74;&#64;&#114;&#117;&#110;&#x6f;&#x6f;&#x62;&#46;&#x63;&#x6f;&#109;">&#x74;&#x65;&#115;&#x74;&#64;&#114;&#117;&#110;&#x6f;&#x6f;&#x62;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Fri May 3 15:49:26 2019 +0800</p><pre><code>changed the runoob.php</code></pre><p>commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00<br>Author: runoob <a href="mailto:&#x74;&#x65;&#x73;&#116;&#64;&#x72;&#117;&#x6e;&#x6f;&#111;&#x62;&#46;&#99;&#x6f;&#109;">&#x74;&#x65;&#x73;&#116;&#64;&#x72;&#117;&#x6e;&#x6f;&#111;&#x62;&#46;&#99;&#x6f;&#109;</a><br>Date:   Fri May 3 15:35:32 2019 +0800<br>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><p>$ git log –oneline<br>$ git log –oneline<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>c68142b 修改代码<br>7774248 (change_site) changed the runoob.php<br>c1501a2 removed test.txt、add runoob.php<br>3e92c19 add test.txt<br>3b58100 第一次版本提交<br>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</li></ul><p>你也可以用 –reverse 参数来逆向显示所有日志。</p><p>$ git log –reverse –oneline<br>3b58100 第一次版本提交<br>3e92c19 add test.txt<br>c1501a2 removed test.txt、add runoob.php<br>7774248 (change_site) changed the runoob.php<br>c68142b 修改代码<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><p>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in<br>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><p>$ git log –oneline –before={3.weeks.ago} –after={2010-04-18} –no-merges<br>5469e2d Git 1.7.1-rc2<br>d43427d Documentation/remote-helpers: Fix typos and improve language<br>272a36b Fixup: Second argument may be any arbitrary string<br>b6c8d2d Documentation/remote-helpers: Add invocation section<br>5ce4f4e Documentation/urls: Rewrite to accomodate transport::address<br>00b84e9 Documentation/remote-helpers: Rewrite description<br>03aa87e Documentation: Describe other situations where -z affects git diff<br>77bc694 rebase-interactive: silence warning when no commits rewritten<br>636db2c t3301: add tests to use –format=”%N”</p><p>Git 标签<br>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><p>$ git tag -a v1.0<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li></ul><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><p>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add runoob.php</li><li>3e92c19 add test.txt</li><li>3b58100 (tag: v0.9) 第一次版本提交<br>如果我们要查看所有标签可以使用以下命令：</li></ul><p>$ git tag<br>v0.9<br>v1.0<br>指定标签信息命令：</p><p>git tag -a <tagname> -m “runoob.com标签”<br>PGP签名标签命令：</p><p>git tag -s <tagname> -m “runoob.com标签”</p><p>Git 远程仓库(Github)<br>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 Github 简明教程。</p><p>添加远程库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><p>git remote add [shortname] [url]<br>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com/注册。" target="_blank" rel="noopener">https://github.com/注册。</a></p><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成 SSH Key：</p><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“<br>后面的 <a href="mailto:your_email@youremail.com">your_email@youremail.com</a> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。</p><p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p><p>左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p><p>添加成功后界面如下所示</p><p>为了验证是否成功，输入以下命令：</p><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Hi tianqixin! You’ve successfully authenticated, but GitHub does not provide shell access.<br>以下命令说明我们已成功连上 Github。</p><p>之后登录后点击” New repository “ 如下图所示：</p><p>之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p>创建成功后，显示如下信息：</p><p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p><p>$ mkdir runoob-git-test                     # 创建测试目录<br>$ cd runoob-git-test/                       # 进入测试目录<br>$ echo “# 菜鸟教程 Git 测试” &gt;&gt; README.md     # 创建 README.md 文件并写入内容<br>$ ls                                        # 查看目录下的文件<br>README<br>$ git init                                  # 初始化<br>$ git add README.md                         # 添加文件<br>$ git commit -m “添加 README.md 文件”        # 提交并备注信息<br>[master (root-commit) 0205aab] 添加 README.md 文件<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p><h1 id="提交到-Github"><a href="#提交到-Github" class="headerlink" title="提交到 Github"></a>提交到 Github</h1><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git<br>$ git push -u origin master<br>以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。</p><p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p><p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p><p>git remote<br>实例<br>$ git remote<br>origin<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p><p>提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><p>git fetch<br>该命令执行完后需要执行git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><p>git merge<br>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><p>接下来我们在 Github 上点击” README.md” 并在线修改它:</p><p>然后我们在本地更新修改。</p><p>$ git fetch origin<br>remote: Counting objects: 3, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>From github.com:tianqixin/runoob-git-test<br>   0205aab..febd8ed  master     -&gt; origin/master<br>以上信息”0205aab..febd8ed master -&gt; origin/master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p><p>$ git merge origin/master<br>Updating 0205aab..febd8ed<br>Fast-forward<br> README.md | 1 +<br> 1 file changed, 1 insertion(+)<br>查看 README.md 文件内容：</p><p>$ cat README.md </p><h1 id="菜鸟教程-Git-测试"><a href="#菜鸟教程-Git-测试" class="headerlink" title="菜鸟教程 Git 测试"></a>菜鸟教程 Git 测试</h1><h2 id="第一次修改内容"><a href="#第一次修改内容" class="headerlink" title="第一次修改内容"></a>第一次修改内容</h2><p>推送到远程仓库<br>推送你的新分支与数据到某个远端仓库命令:</p><p>git push [alias] [branch]<br>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><p>$ touch runoob-test.txt      # 添加文件<br>$ git add runoob-test.txt<br>$ git commit -m “添加到远程”<br>master 69e702d] 添加到远程<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 runoob-test.txt</p><p>$ git push origin master    # 推送到 Github<br>重新回到我们的 Github 仓库，可以看到文件以及提交上来了：</p><p>删除远程仓库<br>删除远程仓库你可以使用命令：</p><p>git remote rm [别名]<br>实例<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><h1 id="添加仓库-origin2"><a href="#添加仓库-origin2" class="headerlink" title="添加仓库 origin2"></a>添加仓库 origin2</h1><p>$ git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git</p><p>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><h1 id="删除仓库-origin2"><a href="#删除仓库-origin2" class="headerlink" title="删除仓库 origin2"></a>删除仓库 origin2</h1><p>$ git remote rm origin2<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p><p>##Git 服务器搭建<br>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p><p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p><p>接下来我们将以 Centos 为例搭建 Git 服务器。</p><p>1、安装Git<br>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>$ yum install git<br>接下来我们 创建一个git用户组和用户，用来运行git服务：</p><p>$ groupadd git<br>$ useradd git -g git<br>2、创建证书登录<br>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p><p>如果没有该文件创建它：</p><p>$ cd /home/git/<br>$ mkdir .ssh<br>$ chmod 755 .ssh<br>$ touch .ssh/authorized_keys<br>$ chmod 644 .ssh/authorized_keys<br>3、初始化Git仓库<br>首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令：</p><p>$ cd /home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo/<br>$ cd gitrepo</p><p>$ git init –bare runoob.git<br>Initialized empty Git repository in /home/gitrepo/runoob.git/<br>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p><p>$ chown -R git:git runoob.git<br>4、克隆仓库<br>$ git clone <a href="mailto:git@192.168.45.4">git@192.168.45.4</a>:/home/gitrepo/runoob.git<br>Cloning into ‘runoob’…<br>warning: You appear to have cloned an empty repository.<br>Checking connectivity… done.<br>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本地仓库使用如下命令初始化：&lt;/p&gt;
&lt;p&gt;$ git init&lt;br&gt;之后使用如下命令添加远程库：&lt;/p&gt;
&lt;p&gt;$ git remote add origin &lt;a href=&quot;mailto:git@github.com&quot;&gt;git@github.com&lt;/a&gt;:haha
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="git" scheme="https://cnawesome.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git基础（上）</title>
    <link href="https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cnawesome.github.io/2020/03/11/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-11T13:08:31.203Z</published>
    <updated>2020-01-30T09:02:00.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h2><p>Git 是一个开源的分布式版本控制系统，<br>                                用于敏捷高效地处理任何或小或大的项目。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h4 id="Git与SVN区别"><a href="#Git与SVN区别" class="headerlink" title="Git与SVN区别"></a>Git与SVN区别</h4><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>Git 与 SVN 区别点：</p><pre><code>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</code></pre><p><img src="001.jpg" alt=""></p><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>本章节我们将为大家介绍 Git 的工作流程。</p><p>一般工作流程如下：</p><pre><code>克隆 Git 资源作为工作目录。在克隆的资源上添加或修改文件。如果其他人修改了，你可以更新资源。在提交前查看修改。提交修改。在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</code></pre><p><img src="002.png" alt=""></p><h2 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h2><p>基本概念</p><p>我们先来理解下Git 工作区、暂存区和版本库概念</p><p>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：<br><img src="003.jpg" alt=""></p><h2 id="git创建仓库"><a href="#git创建仓库" class="headerlink" title="git创建仓库"></a>git创建仓库</h2><p>git init<br>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p><p>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><p>使用方法<br>使用当前目录作为Git仓库，我们只需使它初始化。</p><p>git init<br>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库 。/////</p><p>git init newrepo<br>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><p>$ git add *.c<br>$ git add README<br>$ git commit -m ‘初始化项目版本’<br>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><p>git clone //常用<br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p><p>克隆仓库的命令格式为：</p><p>git clone <repo><br>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><p>git clone <repo> <directory><br>参数说明：</p><p>repo:Git 仓库。<br>directory:本地目录。<br>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><p>$ git clone git://github.com/schacon/grit.git<br>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：<br>$ git clone git://github.com/schacon/grit.git mygrit</p><h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><p>获取与创建项目命令<br>git init<br>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p><p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 runoob 项目：</p><p>$ mkdir runoob<br>$ cd runoob/<br>$ git init<br>Initialized empty Git repository in /Users/tianqixin/www/runoob/.git/</p><h1 id="在-www-runoob-git-目录初始化空-Git-仓库完毕。"><a href="#在-www-runoob-git-目录初始化空-Git-仓库完毕。" class="headerlink" title="在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。"></a>在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。</h1><p>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p><p>ls -a<br>.    ..    .git<br>git clone<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p><p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p><p> git clone [url]<br>[url] 为你想要复制的项目，就可以了。</p><p>例如我们克隆 Github 上的项目：</p><p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:schacon/simplegit.git<br>Cloning into ‘simplegit’…<br>remote: Counting objects: 13, done.<br>remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13<br>Receiving objects: 100% (13/13), done.<br>Resolving deltas: 100% (2/2), done.<br>Checking connectivity… done.<br>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p><p>$ cd simplegit/<br>$ ls<br>README   Rakefile lib<br>上述操作将复制该项目的全部记录。</p><p>$ ls -a<br>.        ..       .git     README   Rakefile lib<br>$ cd .git<br>$ ls<br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><hr><p>基本快照<br>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。</p><p>git status</p><p>$ touch README<br>$ touch hello.php<br>$ ls<br>README        hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$<br>/////git status 命令用于查看项目的当前状态。/////</p><p>接下来我们执行 git add 命令来添加文件：</p><p>$ git add README hello.php<br>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p><p>$ git status -s<br>A  README<br>A  hello.php<br>$<br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。</p><p>现在我们修改 README 文件：</p><p>$ vim README<br>在 README 添加以下内容：# Runoob Git 测试，然后保存退出。</p><p>再执行一下 git status：</p><p>$ git status -s<br>AM README<br>A  hello.php<br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 git add 命令将其添加到缓存中：</p><p>$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p><p>git status<br>//////git status 以查看在你上次提交之后是否有修改。//////</p><p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p><p>$ git status<br>On branch master</p><p>Initial commit</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</p><pre><code>new file:   READMEnew file:   hello.php</code></pre><p>git diff<br>执行 git diff 来查看执行 git status 的结果的详细信息。</p><p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p><p>尚未缓存的改动：git diff<br>查看已缓存的改动： git diff –cached<br>查看已缓存的与未缓存的所有改动：git diff HEAD<br>显示摘要而非整个 diff：git diff –stat<br>在 hello.php 文件中输入以下内容：</p><?phpecho '菜鸟教程：www.runoob.com';?><p>$ git status -s<br>A  README<br>AM hello.php</p><p>$ git diff<br>diff –git a/hello.php b/hello.php<br>index e69de29..69b5711 100644<br>— a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.runoob.com';+?></p><p>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p><p>接下来我们来查看下 git diff –cached 的执行效果：</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff –cached<br>diff –git a/README b/README<br>new file mode 100644<br>index 0000000..8f87495<br>— /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+# Runoob Git 测试<br>diff –git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..69b5711<br>— /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.runoob.com';+?></p><p>git commit<br>////使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。/////</p><p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p><p>$ git config –global user.name ‘runoob’<br>$ git config –global user.email <a href="mailto:test@runoob.com">test@runoob.com</a><br>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) d32cf1f] 第一次版本提交<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php</p><p>现在我们已经记录了快照。如果我们再执行 git status:</p><p>$ git status</p><h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><p>nothing to commit (working directory clean)<br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。</p><p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p><h1 id="Please-enter-the-commit-message-for-your-changes-Lines-starting"><a href="#Please-enter-the-commit-message-for-your-changes-Lines-starting" class="headerlink" title="Please enter the commit message for your changes. Lines starting"></a>Please enter the commit message for your changes. Lines starting</h1><h1 id="with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit"><a href="#with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit" class="headerlink" title="with ‘#’ will be ignored, and an empty message aborts the commit."></a>with ‘#’ will be ignored, and an empty message aborts the commit.</h1><h1 id="On-branch-master-1"><a href="#On-branch-master-1" class="headerlink" title="On branch master"></a>On branch master</h1><h1 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</h1><p>#</p><h1 id="modified-hello-php"><a href="#modified-hello-php" class="headerlink" title="modified:   hello.php"></a>modified:   hello.php</h1><p>#<br>~<br>~<br>“.git/COMMIT_EDITMSG” 9L, 257C<br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><p>git commit -a<br>我们先修改 hello.php 文件为以下内容：</p><?phpecho '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';?><p>再执行以下命令：</p><p>git commit -am ‘修改 hello.php 文件’<br>[master 71ee2cb] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)</p><p>git reset HEAD<br>git reset HEAD 命令用于取消已缓存的内容。</p><p>我们先改动文件 README 文件，内容如下：</p><h1 id="Runoob-Git-测试"><a href="#Runoob-Git-测试" class="headerlink" title="Runoob Git 测试"></a>Runoob Git 测试</h1><h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p>hello.php 文件修改为：</p><?phpecho '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';echo '菜鸟教程：www.runoob.com';?><p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p><p>$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.php<br>$ git reset HEAD hello.php<br>Unstaged changes after reset:<br>M    hello.php<br>$ git status -s<br>M  README<br> M hello.php<br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p><p>$ git commit -m ‘修改’<br>[master f50cfda] 修改<br> 1 file changed, 1 insertion(+)<br>$ git status -s<br> M hello.php<br>可以看到 hello.php 文件的修改并未提交。</p><p>这时我们可以使用以下命令将 hello.php 的修改提交：</p><p>$ git commit -am ‘修改 hello.php 文件’<br>[master 760f74d] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>$ git status<br>On branch master<br>nothing to commit, working directory clean</p><p>/////简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。////</p><p>git rm<br>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作<br>git rm <file></p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f<br>git rm -f <file></p><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可<br>git rm –cached <file></p><p>如我们删除 hello.php文件：</p><p>$ git rm hello.php<br>rm ‘hello.php’<br>$ ls<br>README</p><p>不从工作区中删除文件：<br>$ git rm –cached README<br>rm ‘README’<br>$ ls<br>README</p><p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：<br>git rm –r * </p><p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。<br>git mv<br>git mv 命令用于移动或重命名一个文件、目录、软连接。</p><p>我们先把刚移除的 README 添加回来：</p><p>$ git add README<br>然后对其重名:</p><p>$ git mv README  README.md<br>$ ls<br>README.md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git学习&quot;&gt;&lt;a href=&quot;#Git学习&quot; class=&quot;headerlink&quot; title=&quot;Git学习&quot;&gt;&lt;/a&gt;Git学习&lt;/h2&gt;&lt;p&gt;Git 是一个开源的分布式版本控制系统，&lt;br&gt;                                用于
      
    
    </summary>
    
    
      <category term="程序人生" scheme="https://cnawesome.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="git" scheme="https://cnawesome.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>二叉树（c版本）</title>
    <link href="https://cnawesome.github.io/2020/03/11/c%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://cnawesome.github.io/2020/03/11/c%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-03-11T13:08:31.186Z</published>
    <updated>2020-03-07T11:29:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>btree.h  //二叉树头文件，用于声明数据类型和相关函数</p><pre><code>#ifndef __BTREE_H__#define __BTREE_H__#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef char dataype_bt;  //声明二叉树中存放的数据类型，便于后续更改typedef struct btreenode{   //二叉树的节点结构：存放的数据 该节点的左子节点地址及右子节点地址。注意和单链表的区别，二叉树是非线性存储，单链表是线性存储    dataype_bt data;    struct btreenode *lchild,*rchild;}btree_node,*btree_pnode;extern btree_pnode create_btree1(void);    //通过递归方法创建一个二叉树extern void create_btree(btree_pnode *T);  //通过递归方法创建一个二叉树（功能同上）extern void pre_order(btree_pnode t);    //采用递归方法先序遍历extern void unpre_order(btree_pnode t);  //采用非递归方法先序遍历extern void mid_order(btree_pnode t);    //采用递归方法中序遍历extern void post_order(btree_pnode t);   //采用递归方法后序遍历extern void level_order(btree_pnode t);  //层次遍历extern void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t);   //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述#endifbtree.c  //二叉树相关函数的实现方法#include &quot;btree.h&quot;#include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲#include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲btree_pnode create_btree1(void)        //通过递归方法创建一个二叉树{    dataype_bt ch;    btree_pnode new;    scanf(&quot;%c&quot;,&amp;ch);    if(&apos;#&apos;==ch)    {        return NULL;    }    else    {        //创建根结点        new=(btree_pnode)malloc(sizeof(btree_node));        if(NULL==new)        {            perror(&quot;malloc&quot;);            exit(-1);        }        new-&gt;data=ch;        //用相同方法创建左子数        new-&gt;lchild=create_btree1();        //用相同方法创建右子数        new-&gt;rchild=create_btree1();    }    return new;}void create_btree(btree_pnode *T)          //通过递归方法创建一个二叉树（功能同上）{    dataype_bt ch;    scanf(&quot;%c&quot;,&amp;ch);    if(&apos;#&apos;==ch)    {        return ;    }    else{        //创建根结点        (*T)=(btree_pnode)malloc(sizeof(btree_node));        if(NULL==(*T))        {            perror(&quot;malloc&quot;);            exit(-1);        }        (*T)-&gt;data=ch;        //用相同方法创建左子数        create_btree(&amp;((*T)-&gt;lchild));        //用相同方法创建右子数        create_btree(&amp;((*T)-&gt;rchild));    }}void pre_order(btree_pnode t)          //采用递归方法先序遍历{    if(t!=NULL)    {        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);        //先序遍历左子树        pre_order(t-&gt;lchild);        //先序遍历右子树        pre_order(t-&gt;rchild);    }}void unpre_order(btree_pnode t)          //采用非递归方法先序遍历{    linklist top;//top为指向栈顶结点的指针    top=stack_create();//初始化链式栈    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲        linklist stack_create()        {            linklist s;            if((s=(linklist)malloc(sizeof(listnode)))==NULL){                puts(&quot;malloc failed&quot;);                return NULL;            }            s-&gt;next=NULL;            return s;        }    */    while(t!=NULL || !(stack_empty(top))){        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲            int stack_empty(linklist s)  //判断栈是否为空（1表示空，0表示非空）            {                return (s-&gt;next==NULL ? 1:0);            }        */        if(t!=NULL){            printf(&quot;%c&quot;,t-&gt;data);            if(t-&gt;rchild !=NULL)                stack_push(top,t-&gt;rchild);  //入栈            /*                该函数包含的头文件 和 实现方法如下：                #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲                int stack_push(linklist s,datatype_ls value)  //入栈                {                    linklist p;                    if((p=(linklist)malloc(sizeof(listnode)))==NULL)                    {                        puts(&quot;malloc failed&quot;);                        return -1;                    }                    p-&gt;data = value;                    p-&gt;next=s-&gt;next;                    s-&gt;next = p;                    return 0;                }            */            t=t-&gt;lchild;        }else            t=stack_pop(top);   //出栈        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲            datatype_ls stack_pop(linklist s)    //出栈            {                linklist p;                datatype_ls ret;                p=s-&gt;next;                s-&gt;next=p-&gt;next;                ret=p-&gt;data;                free(p);                p=NULL;                return ret;            }        */    }    stack_free(top);   //释放栈    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲        void stack_free(linklist s)    //释放栈        {            linklist p;            printf(&quot;free:&quot;);            p=s;            while(p)            {                s=s-&gt;next;                printf(&quot;%d &quot;,p-&gt;data);                free(p);                p=s;            }            putchar(10);    //10 表示 回车符（&apos;\n&apos;）        }    */}void mid_order(btree_pnode t)           //采用递归方法中序遍历{    if(t!=NULL)    {        //中序遍历左子树        mid_order(t-&gt;lchild);        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);        //中序遍历右子树        mid_order(t-&gt;rchild);    }}void post_order(btree_pnode t)          //采用递归方法后序遍历{    if(t!=NULL)    {        //后序遍历左子树        post_order(t-&gt;lchild);        //后序遍历右子树        post_order(t-&gt;rchild);        //访问根结点        printf(&quot;%c&quot;,t-&gt;data);    }}void level_order(btree_pnode t)        //层次遍历{    link_pqueue q;    init_linkqueue(&amp;q);//初始化链式队列    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲        void init_linkqueue(link_pqueue *Q)     //创建队列        {            //申请front和rear的空间            *Q=(link_pqueue)malloc(sizeof(link_queue));            if((*Q)==NULL)            {                perror(&quot;malloc&quot;);                exit(-1);            }            //申请头结点空间            (*Q)-&gt;front=(linkqueue_pnode)malloc(sizeof(linkqueue_node));            if((*Q)-&gt;front==NULL)            {                perror(&quot;malloc&quot;);                exit(-1) ;            }            (*Q)-&gt;front-&gt;next=NULL;            (*Q)-&gt;rear=(*Q)-&gt;front;            return;        }    */    while(t!=NULL)    {        //访问t指向的结点数据        printf(&quot;%c&quot;,t-&gt;data);        //当t的左指针不为空，则入队        if(t-&gt;lchild!=NULL)            in_linkqueue(t-&gt;lchild,q);        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲            bool in_linkqueue(datatype data,link_pqueue q)   //入队            {                linkqueue_pnode  new;                //申请数据结点空间                new=(linkqueue_pnode)malloc(sizeof(linkqueue_node));                if(new==NULL)                {                    puts(&quot;入队失败！&quot;);                    return false;                }                //将数据存储在申请的空间                new-&gt;data=data;                //将new指向的结点插入到链式队列中                new-&gt;next=q-&gt;rear-&gt;next;            //这里等价于new-&gt;next = NULL;                q-&gt;rear-&gt;next=new;                         //让rear指针指向新的队尾结点                q-&gt;rear=q-&gt;rear-&gt;next;          //等价于q-&gt;rear = new;                return true;            }        */        //当t的右指针不为空，则入队        if(t-&gt;rchild!=NULL)            in_linkqueue(t-&gt;rchild,q);        //队列不为空，则出队        if(!is_empty_linkqueue(q))            out_linkqueue(q,&amp;t);        /*            该函数包含的头文件 和 实现方法如下：            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲            bool out_linkqueue(link_pqueue q,datatype *D)      //出队            {                linkqueue_pnode t;                //判断队列是否空                if(is_empty_linkqueue(q)){                    printf(&quot;队列已空!\n&quot;);                    return false;                }                //出队                t=q-&gt;front;                q-&gt;front =q-&gt;front-&gt;next;                *D=q-&gt;front-&gt;data;                free(t);                return true;            }        */        else            break;    }    free_linkqueue(q);           //释放队列    /*        该函数包含的头文件 和 实现方法如下：        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲        void free_linkqueue(link_pqueue q)           //释放队列        {            link_pqueue p;            p = q-&gt;front;            while(p)            {                q-&gt;front = q-&gt;front-&gt;next;                free(p);                p = q-&gt;front;            }            free(q);        }    */}void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t)      //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述{    printf(&quot;%s&quot;,str);    pfun(t);    puts(&quot;&quot;);}</code></pre><p>————————————————<br>版权声明：本文为CS80960356DN博主「许新天」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39148042/article/details/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39148042/article/details/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;btree.h  //二叉树头文件，用于声明数据类型和相关函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __BTREE_H__
#define __BTREE_H__

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://cnawesome.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="c" scheme="https://cnawesome.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="https://cnawesome.github.io/2020/03/11/hello-world/"/>
    <id>https://cnawesome.github.io/2020/03/11/hello-world/</id>
    <published>2020-03-11T08:24:36.211Z</published>
    <updated>2020-02-26T02:37:28.152Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my Chanal, This is my very first post. </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="博客初体验"><a href="#博客初体验" class="headerlink" title="博客初体验"></a>博客初体验</h3><h4 id="new-blog-new-life"><a href="#new-blog-new-life" class="headerlink" title="new blog,new life"></a>new blog,new life</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to my Chanal, This is my very first post. &lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;
      
    
    </summary>
    
    
      <category term="生活" scheme="https://cnawesome.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://cnawesome.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识点（供考试）</title>
    <link href="https://cnawesome.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BE%9B%E8%80%83%E8%AF%95%EF%BC%89/"/>
    <id>https://cnawesome.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BE%9B%E8%80%83%E8%AF%95%EF%BC%89/</id>
    <published>2020-03-10T02:04:16.000Z</published>
    <updated>2020-03-12T10:17:51.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>计算机网络的分类：</p><pre><code>按分布范围：    1）广域网WAN    2）城域网MAN（大多使用以太网技术，也可以成为局域网）    3）局域网LAN    4)个人区域网PAN（）按传输技术：    1）广播式网络（共享通信信道，发送报文所有人都能接收到）    2）点对点网络（一对计算机通信）按交换技术分：（交换技术指的是通信设备和主机之间交换信息所采用的数据格式，交换装置的方式）    1）电路交换网络（在源节点与目标节点间建立一条专用的通信链路用来传输数据，该链路可以使虚拟的）    2）报文交换网络（也称存储转发，将数据封装成报文，存储转发，每个报文单独选择到达目的地的路径）    3）分组交换网络（也称包交换，将数据分成较短固定长度的数据块，把报文分块？以存储转发方式传输）等;</code></pre><p>计算机网络性能指标：</p><pre><code>带宽：本来表示通信线路允许通过的信号频带范围，单位赫兹Hz。在计算机网络中，    表示网络的通信线路传送数据的能力，即传送的最高数据率，单位b/s。时延：数据从一端传输到另一端所需要的时间。    发送时延：节点将分组的所有比特传输到链路上的时间。        发送时延=分组长度/信道宽度    传播时延：一个比特从链路的一端到另一端的所需时间。        传播时延=信道长度/电磁波在信道传播的速率    处理时延：数据在存储转发时处理的所需时间。    排队时延：分组进入路由器在队列中等待处理的时间。时延带宽积：发送端连续发送数据，当发送的第一个比特即将到达终点时，发送端已经发送出的数据数。    时延带宽积=传播时延*信道带宽往返时延：发送端发送数据，到发送端接收到接收端的确认，总共经过的时延。吞吐量：单位时间内，通过某个网络的数据量。吞吐量受网络的带宽和额定速率限制。速率：计算机网络中主机在数字信道上传送数据的速率。单位为b/s</code></pre><p>计算机网络中接口定义：同一节点中，相邻两层交换信息的接触点。</p><p>服务的定义：下层为紧邻的上层提供的功能调用。</p><p>计算机网络的服务：</p><pre><code>1）面向连接和面向无连接服务    面向连接：通信前双方必须建立连接结束后释放连接。    无连接：不需要现建立连接，尽最大努力交付，得不可靠传输。2）可靠传输与不可靠传输3）有应答服务和无应答服务    有应答，接收方接收到数据向发送方给出相应的应答。</code></pre><p>码元：一个固定时长的信号波形，表示一位k进制数，代表不同离散数值的基本波形是数字信号的计量单位。</p><p>码元速率：单位时间传输的码元个数，码元速率与进制无关，单位波特每秒</p><p>信息传输速率：单位时间传输的二进制码元个数，单位比特每秒</p><p>电路交换，报文交换和分组交换<br>    1）电路交换：两个节点之间不许先建立一条专用的物理通信路径。传输期间一直被占用。<br>                三个阶段：连接建立，数据传输，连接释放<br>                优势：通信时延小，有序传输，没有冲突，适用范围广，实时性强，控制简单。</p><pre><code>2）报文交换：交换的单位是报文，报文携带目标地址等信息。采用存储转发机制。            优点：无需建立连接，动态分配路线，提高线路可靠性，提高线路利用性，提供多目标服务。3）分组交换：把大的报文进行分组，再加上必要的控制信息，节点接受的分组后，展示保存下来并排队等待传输。            优点：无建立时延，线路利用率高，加速传输</code></pre><p>数据报与虚电路（分组交换的两种形式）<br>    分组交换很具器通信子网向端点系统提供服务，进一步可分为面向连接的虚电路方式和无连接的数据报形式，这两种服务都是网络层提供的。</p><pre><code>数据报:使用端系统的协议把报文拆成若干带有序号的数据单元形成数据报分组。虚电路：把数据报方式与电路交换结合起来。分组发送以前，要求发送方与接收方建立一条逻辑上相连的电路，并且一点连接建立，虚电路所对应的物理路径也就确立了。虚电路方式建立虚电路时，要选择一个没用过的虚电路号给该虚电路连接。虚电路网络中每个节点都维护一张虚电路表。</code></pre><p>物理层设备<br>    中继器：又称转发器，将信号整形放大在转发出去。<br>    集线器：多端口中继器，没有冲突检测。</p><p>数据链路层：为网络层服务，加强物理层功能，将物理层提供的可能出错的物理连接，改为无差错的数据链路，使之在网络层表现为无差错的数据链路。<br>    为网络层提供的服务：<br>                    1）无确认的无连接服务，发送数据帧不需要建立链路连接，目标接收到帧也不需要回应。<br>                    2）有确认的无连接服务。<br>                    3）有确认的面向连接服务。<br>    透明传输：不管什么样的数据都能在链路上传输，比如，某些内容中的数据与帧的标志相同需要做一些处理是指能传输。</p><p>组帧：帧定界，帧同步，透明传输等。</p><p>编码技术实现差错控制：<br>                1）自动重传请求 ARQ<br>                2)前向纠错 FEC</p><p>常见的检错编码:<br>            1)奇偶校验码<br>            2）循环允余码<br>流量控制：由接收方控制发送方的发送数据的速率。<br>    1）停止等待流量协议<br>    2）滑动窗口协议：滑动，每次把目标整体向后移动一位，窗口，指目标整体</p><p>可靠传输：<br>    自动重传分为三种：<br>        1）停等式<br>        2）后退N帧<br>        3）选择性重传</p><p>单帧滑动窗口停等协议：<br>接收方每收到一个帧都回应确认</p><p>多帧滑动窗口后退N帧协议：<br>不需要逐帧确认，确认一个，便确认了这个前面所有的。</p><p>介质访问控制：为使用介质的每一个节点隔离来自同一个信道上其他节点传送的信号。</p><pre><code>常用的介质访问控制方法：    1）信道划分    2）随机划分    3）轮询访问：令牌传递协议信道划分：    频分复用    时分复用    码分复用    波分复用随机访问介质访问控制：    ALOHA:纯ALOHA发送无确认，等待重传；时隙ALOHA：把各站的时间同步起来    CSMA：1-坚持CSMA：当侦听到信道忙时，继续侦听信道；非坚持CSMA：侦听到信道忙即放弃侦听；p-坚持CSMA，以概率P发送数据。    CSMA/CD:冲突检测，先听后发，边听边发，冲突停发，随机重发    CSMA/CS：碰撞避免</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/h3&gt;&lt;p&gt;计算机网络的分类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;按分布范围：
    1）广域网W
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>算法设计2.0</title>
    <link href="https://cnawesome.github.io/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/"/>
    <id>https://cnawesome.github.io/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/</id>
    <published>2020-03-06T02:33:04.000Z</published>
    <updated>2020-03-12T04:14:44.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%8C%BA%E5%88%AB.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%8C%BA%E5%88%AB.jpg" alt></p><h3 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h3><p>列表循秩访问成本比向量循秩访问高</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E5%BE%AA%E7%A7%A9%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6.jpg" alt></p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8F%92%E5%85%A5.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%9F%BA%E4%BA%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9E%84%E9%80%A0.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%88%A0%E9%99%A4.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9E%90%E6%9E%84.jpg" alt></p><p>使元素唯一化<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96.jpg" alt></p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE.jpg" alt></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E4%B8%8E%E5%86%92%E6%B3%A1.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81.jpg" alt></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg" alt></p><p>1.比较要插入的数，确定位置<br>2.把该位置前所有元素向前挪一位<br>3.把元素插入该位置</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg" alt></p><p>线性代数中的排列的逆序数：<br>  逆序数在插入算法中的作用，用逆序数来表示要转移的次数<br>  线性代数中的逆序数是用来确定行列式的值的正负号的。<br>  两者可能没什么关联。</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F%E5%AF%B9.jpg" alt><br>算法复杂度：最坏复杂度：n平方<br>           最好复杂度：n</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%9B%BE.jpg" alt><br>栈：后进先出 LIFO</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%8E%A5%E5%8F%A3.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88.jpg" alt></p><p>####进制转换</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81.jpg" alt></p><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%9E%84%E6%80%9D.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%9E%84%E6%80%9D%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%9B%BE%E8%A7%A3.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97.jpg" alt></p><p>栈混洗的序列不唯一</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E7%94%84%E5%88%AB.jpg" alt></p><p>任何一个数如i，进栈后想要第一个出栈，原队列的i之前的数都得先进栈。<br>解释为什么不能出现 顺序：312</p><p>在栈内，pop一个元素后，在pop出一个元素必然是该栈内顶上的元素或者要入栈队列的第一个元素。<br>所以再一次pop的元素是剩下的队列的所有元素之一及栈顶元素。<br>栈顶元素下的栈内元素是不可动的。</p><p>栈的出栈也表先出先后顺序，嵌套顺序</p><p>栈混洗成功的充分必要条件</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E7%9A%84%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E4%B8%8E%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.jpg" alt><br>n个数的栈混洗有多少种，n对括号能成的表达式就有多少种。</p><h4 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%B8%8E%E9%82%A3%E7%AE%97%E7%AC%A6%E5%A4%84%E7%90%86.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%AB%E6%8F%8F%E4%B8%BB%E7%AE%97%E6%B3%95.jpg" alt></p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E7%AE%97%E6%9C%AF%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8.jpg" alt></p><p>逆波兰表达式RPN</p><p>将中缀表达式转换为RPN,可以使用间的的栈进出来实现中缀表达式的问题。</p><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/RPN%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt><br>中缀转RPN,操作数的顺序不会变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%8C%BA%E5%88%AB.jp
      
    
    </summary>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>QT1.0</title>
    <link href="https://cnawesome.github.io/2020/03/03/QT1-0/"/>
    <id>https://cnawesome.github.io/2020/03/03/QT1-0/</id>
    <published>2020-03-03T09:27:01.000Z</published>
    <updated>2020-03-06T23:39:28.236Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="QT" scheme="https://cnawesome.github.io/categories/QT/"/>
    
    
      <category term="QT" scheme="https://cnawesome.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="https://cnawesome.github.io/2020/02/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://cnawesome.github.io/2020/02/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-25T12:15:41.000Z</published>
    <updated>2020-02-29T13:25:42.526Z</updated>
    
    <content type="html"><![CDATA[<p><img src="%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" alt=""></p><h4 id="套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。"><a href="#套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。" class="headerlink" title="套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。"></a>套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。</h4><p>｛    流套接字：用于提供面向连接、可靠的数据传输服务。<br>    数据报套接字：提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传    输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。<br>    原始套接字(SOCKET_RAW)：允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。<br> ｝</p><h4 id="套接字基本函数："><a href="#套接字基本函数：" class="headerlink" title="套接字基本函数："></a>套接字基本函数：</h4><pre><code> 创建套接字：int socket(int family, int type, intprotocol);         个人理解创建socket的过程其实就是一个获得文件描述符的过程，当然这个过程会是比较复杂的。可以从内核中找到创建socket的代码，并且socket的创建和其他的listen，bind等操作分离开来。socket函数完成正确的操作是返回值大于0的文件描述符，当返回小于0的值时，操作错误。同样是返回一个文件描述符，但是会因为三个参数组合不同，对于数据具体的工作流程不同，对于应用层编程来说，这些也是不可见的。         socket有三个参数，family代表一个协议族，比较熟知的就是AF_INET，PF_PACKET等；第二个参数是协议类型，常见类型是SOCK_STREAM,SOCK_DGRAM, SOCK_RAW, SOCK_PACKET等；第三个参数是具体的协议，对于标准套接字来说，其值是0，对于原始套接字来说就是具体的协议值。 套接字绑定函数： intbind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);         功能介绍：bind函数主要应用于服务器模式一端，其主要的功能是将addrlen长度 structsockaddr类型的myaddr地址与sockfd文件描述符绑定到一起，在sockaddr中主要包含服务器端的协议族类型，网络地址和端口号等。在客户端模式中不需要使用bind函数。当bind函数返回0时，为正确绑定，返回-1，则为绑定失败。         bind函数的第一个参数sockfd是在创建socket套接字时返回的文件描述符。         bind函数的第二个参数是structsockaddr类型的数据结构，由于structsockaddr数据结构类型不方便设置，所以通常会通过对tructsockaddr_in进行地质结构设置，然后进行强制类型转换成structsockaddr类型的数据。 监听函数：int listen(int sockfd, int backlog);        功能介绍：listen的操作就是当有较多的client发起connect时，server端不能及时的处理已经建立的连接，这时就会将connect连接放在等待队列中缓存起来。这个等待队列的长度有listen中的backlog参数来设定。listen和accept函数是服务器模式特有的函数，客户端不需要这个函数。当listen运行成功时，返回0；运行失败时，返回值位-1.        参数说明：sockfd是前面socket创建的文件描述符;backlog是指server端可以缓存连接的最大个数，也就是等待队列的长度。请求接收函数：int accept(int sockfd, structsockaddr *client_addr, socklen_t *len);        功能介绍：接受函数accept其实并不是真正的接受，而是客户端向服务器端监听端口发起的连接。对于TCP来说，accept从阻塞状态返回的时候，已经完成了三次握手的操作。Accept其实是取了一个已经处于connected状态的连接，然后把对方的协议族，网络地址以及端口都存在了client_addr中，返回一个用于操作的新的文件描述符，该文件描述符表示客户端与服务器端的连接，通过对该文件描述符操作，可以向client端发送和接收数据。同时之前socket创建的sockfd，则继续监听有没有新的连接到达本地端口。返回大于0的文件描述符则表示accept成功，否则失败。        参数说明：sockfd是socket创建的文件描述符；client_addr是本地服务器端的一个structsockaddr类型的变量，用于存放新连接的协议族，网络地址以及端口号等；第三个参数len是第二个参数所指内容的长度，对于TCP来说其值可以用sizeof(structsockaddr_in)来计算大小，说要说明的是accept的第三个参数要是指针的形式，因为这个值是要传给协议栈使用的。客户端请求连接函数： intconnect(int sock_fd, struct sockaddr *serv_addr,int addrlen);        功能介绍：连接函数connect是属于client端的操作函数，其目的是向服务器端发送连接请求，这也是从客户端发起TCP三次握手请求的开始，服务器端的协议族，网络地址以及端口都会填充到connect函数的serv_addr地址当中。当connect返回0时说明已经connect成功，返回值是-1时，表示connect失败。        参数说明：connect的第一个参数是socket创建的文件描述符；第二个参数是一个structsockaddr类型的指针，这个参数中设置的是要连接的目标服务器的协议族，网络地址以及端口号；第三个参数表示第二个参数内容的大小，与accept不同，这个值不是一个指针。</code></pre><p> 在服务器端和客户端建立连接之后是进行数据间的发送和接收，主要使用的接收函数是recv和read，发送函数是send和write。因为对于socket套接字来说，最终实际操作的是文件描述符，所以可以使用对文件进行操作的接收和发送函数对socket套接字进行操作。read和write函数是文件编程里的知识，所以这里不再做多与的赘述。</p><h5 id="简单连接服务器代码："><a href="#简单连接服务器代码：" class="headerlink" title="简单连接服务器代码："></a>简单连接服务器代码：</h5><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 3399#define SIZE 1024int createSocket(){//返回一个内核的socket码    int listen_socket=socket(AF_INET,SOCK_STREAM,0);    if(listen_socket==-1){        perror(&quot;socket&quot;);        return -1;    }    struct sockaddr_in addr;    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;  /* Internet地址族 */    addr.sin_port = htons(PORT);  /* 端口号 */    addr.sin_addr.s_addr = htonl(INADDR_ANY);   /* IP地址 */    int ref=intbind(listen_socket,(struct sockaddr *)&amp;addr,sizeof(addr));    if(ref==1){        perror(&quot;bind&quot;);        return -1;    }    ref=listen(listen_socket,5);//放置等待队列，并非接收用户请求    if(ref == -1){        perror(&quot;listen&quot;);        return -1;    }    return listen_socket;}void listenWait_socket(int socket_id){    struct sockaddr_in cliaddr;    int addrlen = sizeof(cliaddr);    printf(&quot;等待客户端连接。。。。\n&quot;);    int client_socket=accept(socket_id,(struct sockaddr *)&amp;cliaddr, &amp;addrlen);    if(client_socket == -1)    {        perror(&quot;accept&quot;);        return -1;    }    return client_socket;}void handle_socket(int listen_socket, int client_socket){    char buf[SIZE];    while(1)    {        int ret = read(client_socket, buf, SIZE-1);        if(ret == -1)        {            perror(&quot;read&quot;);            break;        }        if(ret == 0)        {            break;        }        buf[ret]=&quot;\0&quot;;        for(i = 0; i &lt; ret; i++)        {            buf[i] = buf[i] + &apos;A&apos; - &apos;a&apos;;        }        printf(&quot;%s\n&quot;, buf);        write(client_socket, buf, ret);        if(strncmp(buf, &quot;end&quot;, 3) == 0)        {            break;        }    }    close(client_socket);    }}int main(){    int socket_listen=createSocket();    int socket_client=listenWait_socket(socket_listen);    hanld_client(socket_listen, socket_client);      close(listen_socket);    return 0;}</code></pre><h5 id="多线程并发服务器代码："><a href="#多线程并发服务器代码：" class="headerlink" title="多线程并发服务器代码："></a>多线程并发服务器代码：</h5><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#define PORT 9990#define SIZE 1024int Creat_socket()         //创建套接字和初始化以及监听函数{    int listen_socket = socket(AF_INET, SOCK_STREAM, 0);      //创建一个负责监听的套接字      if(listen_socket == -1)    {        perror(&quot;socket&quot;);        return -1;    }    struct sockaddr_in addr;    memset(&amp;addr, 0, sizeof(addr));    addr.sin_family = AF_INET;  /* Internet地址族 */    addr.sin_port = htons(PORT);  /* 端口号 */    addr.sin_addr.s_addr = htonl(INADDR_ANY);   /* IP地址 */    int ret = bind(listen_socket, (struct sockaddr *)&amp;addr, sizeof(addr));    //连接    if(ret == -1)    {        perror(&quot;bind&quot;);        return -1;    }    ret = listen(listen_socket, 5);   //监听    if(ret == -1)    {        perror(&quot;listen&quot;);        return -1;    }    return listen_socket;}int wait_client(int listen_socket){    struct sockaddr_in cliaddr;    int addrlen = sizeof(cliaddr);    printf(&quot;等待客户端连接。。。。\n&quot;);    int client_socket = accept(listen_socket, (struct sockaddr *)&amp;cliaddr, &amp;addrlen);     //创建一个和客户端交流的套接字    if(client_socket == -1)    {        perror(&quot;accept&quot;);        return -1;    }    printf(&quot;成功接收到一个客户端：%s\n&quot;, inet_ntoa(cliaddr.sin_addr));    return client_socket;}void hanld_client(int listen_socket, int client_socket)    //信息处理函数,功能是将客户端传过来的小写字母转化为大写字母{    char buf[SIZE];    while(1)    {        int ret = read(client_socket, buf, SIZE-1);        if(ret == -1)        {            perror(&quot;read&quot;);            break;        }        if(ret == 0)        {            break;        }        buf[ret] = &apos;\0&apos;;        int i;        for(i = 0; i &lt; ret; i++)        {            buf[i] = buf[i] + &apos;A&apos; - &apos;a&apos;;        }        printf(&quot;%s\n&quot;, buf);        write(client_socket, buf, ret);        if(strncmp(buf, &quot;end&quot;, 3) == 0)        {            break;        }    }    close(client_socket);}void handler(int sig){    while (waitpid(-1,  NULL,   WNOHANG) &gt; 0)    {        printf (&quot;成功处理一个子进程的退出\n&quot;);    }}int main(){    int listen_socket = Creat_socket();    signal(SIGCHLD,  handler);    //处理子进程，防止僵尸进程的产生    while(1)    {        int client_socket = wait_client(listen_socket);   //多进程服务器，可以创建子进程来处理，父进程负责监听。        int pid = fork();        if(pid == -1)        {            perror(&quot;fork&quot;);            break;        }        if(pid &gt; 0)        {            close(client_socket);            continue;        }        if(pid == 0)        {            close(listen_socket);            hanld_client(listen_socket, client_socket);            break;        }    }    close(listen_socket);    return 0;｝</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;%E5%A5%97%E6%8E%A5%E5%AD%97.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。&quot;&gt;&lt;a href=&quot;#套接字：源IP地址和目的IP地址以及源端口号和目的
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://cnawesome.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://cnawesome.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络2.0</title>
    <link href="https://cnawesome.github.io/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/"/>
    <id>https://cnawesome.github.io/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/</id>
    <published>2020-02-23T09:13:19.000Z</published>
    <updated>2020-03-03T02:12:06.486Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="病毒与木马"><a href="#病毒与木马" class="headerlink" title="病毒与木马"></a>病毒与木马</h4><p>灰鸽子木马 控制中病毒的用户电脑</p><h4 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h4><pre><code>对称加密 效率高，秘钥相同。非对称密钥：加密秘钥与解密秘钥不同，效率低。    解密方法：公钥加密，私钥解密            私钥加密，公钥解密非对称密钥的制作：            一串随机数-&gt;使用函数分成-&gt;一对私钥和公钥公钥可以在网上传，私钥要保留好效率高的方法：用私钥加密对称密钥</code></pre><p>加密算法标准DES<br>    属于分组密码</p><p>DES 加密步骤：将文件分组，一组一组进行加密。将加密后的每一组合并成新的文件。<br>DES算法公开取决于秘钥长度。</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>作用：防止抵赖，防止更改</p><p><img src="%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt=""><br>发送给别人后，别人同样的方法，将文件单向散列后，用公钥解密，如果摘要一样，文件没有被修改。</p><p>证书颁发机构CA<br>作用：防止使用不合法的公钥私钥。确保为企业颁发证书，确认身份真实，用户需要信任CA机构。</p><p>打开认证单元：        cmd-&gt;mmc-&gt;添加管理单元</p><h4 id="Internet安全协议"><a href="#Internet安全协议" class="headerlink" title="Internet安全协议"></a>Internet安全协议</h4><p>ssl 安全套接字 在应用层和传输层之间，在传输层之前给应用层加密</p><p>功能：服务器鉴别<br>      客户端鉴别<br>      加密ssl会话</p><h4 id="网络层安全-IPsec"><a href="#网络层安全-IPsec" class="headerlink" title="网络层安全 IPsec"></a>网络层安全 IPsec</h4><p><img src="%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%9B%BE.jpg" alt=""></p><p>SA是构成IPsec的基础，是连个通信实体协商建立的协议（利用IKE协议）<br><img src="SA.jpg" alt=""></p><p>AH 签名协议不加密<br>ESP 签名加密协议<br><img src="AH.jpg" alt=""><br><img src="ESP.jpg" alt=""><br>可以在本地安全策略配置</p><h4 id="数据链路层安全"><a href="#数据链路层安全" class="headerlink" title="数据链路层安全"></a>数据链路层安全</h4><p>ppp 身份验证协议</p><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>一种特殊编程的路由</p><p>类型： 网络层防火墙<br>      应用层防火墙</p><h4 id="internet上的音频"><a href="#internet上的音频" class="headerlink" title="internet上的音频"></a>internet上的音频</h4><p>流媒体服务<br>    录播<br>    直播</p><p>！整体组网考虑网络速度很关键</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;网络安全&quot;&gt;&lt;a href=&quot;#网络安全&quot; class=&quot;headerlink&quot; title=&quot;网络安全&quot;&gt;&lt;/a&gt;网络安全&lt;/h3&gt;&lt;h4 id=&quot;病毒与木马&quot;&gt;&lt;a href=&quot;#病毒与木马&quot; class=&quot;headerlink&quot; title=&quot;病毒
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>算法设计1.0</title>
    <link href="https://cnawesome.github.io/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://cnawesome.github.io/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-23T07:44:40.000Z</published>
    <updated>2020-03-06T23:39:28.226Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h6 id="来自清华大学邓骏辉课程"><a href="#来自清华大学邓骏辉课程" class="headerlink" title="来自清华大学邓骏辉课程"></a>来自清华大学邓骏辉课程</h6><h4 id="图灵机介绍："><a href="#图灵机介绍：" class="headerlink" title="图灵机介绍："></a>图灵机介绍：</h4><p><img src="%E5%9B%BE%E7%81%B5%E6%9C%BA.jpg" alt=""></p><p>定性计算</p><p>定量计算</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p><img src="%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B0%BAjpg" alt=""><br><img src="%E6%8C%87%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" alt=""><br><img src="%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%B0%B4%E5%B2%AD.jpg" alt=""></p><p>算法分析要两个方面考虑：<br>                        定性计算<br>                        定量计算</p><p>算法分析<br>    确定执行程序的复杂度<br>    封底估算</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img src="%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92.jpg" alt=""></p><p><img src="%E4%BA%8C%E5%88%86%E9%80%92%E5%BD%92.jpg" alt=""></p><p><img src="%E5%88%86%E6%B2%BB.jpg" alt=""></p><p><img src="%E5%87%8F%E6%B2%BB.jpg" alt=""></p><h3 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a>2.向量</h3><p>1.抽象数据类型（ADT）<br>    数据类型+一组操作（方法，接口）<br>2.数据结构<br>    使用ADT实现功能</p><p>ADT向量的操作<br>    构造与析构<br>    扩容</p><p>无序向量<br>    插入<br>    区间删除<br>    查找<br>    单元素删除（区间删除特例）<br>    遍历</p><p>有序向量<br>    排序效率可以更高<br>    查找效率可以更高</p><h4 id="有序向量的查找算法"><a href="#有序向量的查找算法" class="headerlink" title="有序向量的查找算法"></a>有序向量的查找算法</h4><p>有序二分查找<br><img src="%E6%9F%A5%E6%89%BE%E6%8E%A5%E5%8F%A3.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEA.jpg" alt=""></p><p>语义定义：<br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%AD%E4%B9%89%E5%AE%9A%E4%B9%89.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6%E5%88%86%E6%9E%90.jpg" alt=""><br>二分查找具体复杂度：1.(log2n)</p><p>二分查找改进版本A：<br><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95.jpg" alt=""><br>左侧查找成本更低所以使用<br>二分查找改进：用斐波拉切做分割中间点，接下来的中间分隔点都是斐波拉切形式<br><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6.jpg" alt=""><br><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt=""></p><p><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%AD%E7%82%B9.jpg" alt=""><br>有点玄乎，不过没逻辑漏洞<br>概率确实是越来越大</p><p>把查找比作化区域捞鱼<br>比如你在湖里捞鱼和在河里捞鱼，捞上来的概率是一样的，或者说是不可知的。<br>但如果你在里面捞，同时记住你刚才捞过区域，那下次换一个区域再捞，概率确实更大</p><p>二分查找改进版本B：<br>在原版本中舍弃能在查找中间点的同时确定是否是要查找的数，实现左右递归查找的成本平衡<br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACB.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACB%E4%BB%A3%E7%A0%81.jpg" alt=""></p><p>二分查找版本C：<br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACC.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACC%E5%88%86%E6%9E%90.jpg" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>改进一下：每次扫描完确定最后一个，在某一次扫描碰巧扫描过都已经排序好了，直接完成排序<br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BA.jpg" alt=""><br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BA%E5%9B%BE.jpg" alt=""></p><p>改进2：<br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.jpg" alt=""><br>如图：某种情况下，前面一小部分有逆序，后面一大部分已经顺序，但按改进A依然得继续扫描到前面小部分位置知道前面都顺序了。<br>前面小部分虽然逆序，但通过冒泡排序进过最多r次排序就能是整个扫描区都顺序。<br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%902.jpg" alt=""></p><p>在知道前面一些位置已经顺序，不再按冒泡排序的规律，直接将后面的已排序队头指向已经顺序的第一个<br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%903.jpg" alt=""><br><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E4%BB%A3%E7%A0%81.jpg" alt=""></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86.jpg" alt=""><br><img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81.jpg" alt=""></p><p><img src="%E5%BD%92%E5%B9%B6%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt=""><br>归并的过程就像比武招亲，两队打擂台。</p><p><img src="%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0.jpg" alt=""><br><img src="%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E5%9B%BE.jpg" alt=""></p><p>二分归并性能分析：<br><img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;算法设计&quot;&gt;&lt;a href=&quot;#算法设计&quot; class=&quot;headerlink&quot; title=&quot;算法设计&quot;&gt;&lt;/a&gt;算法设计&lt;/h3&gt;&lt;h6 id=&quot;来自清华大学邓骏辉课程&quot;&gt;&lt;a href=&quot;#来自清华大学邓骏辉课程&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://cnawesome.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络1.0</title>
    <link href="https://cnawesome.github.io/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/"/>
    <id>https://cnawesome.github.io/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-03-12T03:32:04.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h3><p>许多主机连接-&gt;网络<br>许多网络连接-&gt;互联网<br>做大的互联网-&gt;因特网</p><h4 id="因特网3部曲"><a href="#因特网3部曲" class="headerlink" title="因特网3部曲"></a>因特网3部曲</h4><pre><code>1.ARPANET向互联网发展 始于19832.3级结构的因特网 主干网-&gt;地区网-&gt;用户3.多层次ISP（互联网运营商）结构互联网</code></pre><h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><pre><code>电路交换，占线分组交换 ，不占线</code></pre><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2.jpg" alt></p><h4 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB.jpg" alt></p><h4 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h4><p>速率：连接在计算机网络上的主机在数字信道上传输数据的速率。每秒多少个位数。</p><p>带宽：数字信道所能传输的最高速率。</p><p>吞吐量：单位时间通过某个网络（所有信道）的数据量。</p><p>时延：<br>    发送时延：数据块长度/信道带宽<br>    传播时延：信道长度/信号在信道上的传播速率<br>    处理时延：<br>    排队时延：</p><h4 id="ISO七层架构"><a href="#ISO七层架构" class="headerlink" title="ISO七层架构"></a>ISO七层架构</h4><pre><code>应用层：产生网络流量或用户交互的应用程序表示层：加密 压缩 开发人员会话层：服务器和客户端建立会话传输层：可靠传输建立会话网络层：ip地址编址 选择最佳路径 差错控制 流量控制 传输管理数据链路层：封装数据 添加物理层地址 差错控制 流量控制 传输管理物理层：电压 接口</code></pre><h3 id="数据通信知识"><a href="#数据通信知识" class="headerlink" title="数据通信知识"></a>数据通信知识</h3><p>码元：在使用时间域的波形表示数字信号，代表不同离散数值的基本波形<br>信道：传输数据的媒介</p><p>数据无论是数字或模拟，为了传输必须转化为信号。<br>数字数据编码方式，即用什么表示数字信号表示1，什么表示数字信号0；<br>    不同的数据编码：<br>                二进制编码<br>                非归零码<br>                曼彻斯特编码<br>                差分曼彻斯特编码<br>                4B/5B编码                </p><p>基带信号：来自信源的信号。<br>带通信号：经过载波调制能发送更远。</p><p>调制方法：<br>调幅<br>调频<br>调相</p><p>波特 数据传输的速率</p><p>信噪比<br>    C=W log2 （1+s/n） b/s<br>    w是信道的带宽<br>    s为信道上所传信号的平均功率<br>    n为信道上的高斯噪声功率</p><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h3><h4 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h4><p>在理想低通的信道中，极限码元传输速率为 2w baud ，w是理想低通信道的带宽，单位hz</p><h4 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h4><p>双绞线 屏蔽双绞线 非屏蔽双绞线<br>同轴电缆<br>光纤</p><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><p>频分信道复用<br>时分信道复用<br>码分信道复用<br>波分信道复用</p><h4 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h4><p>脉码调制PCM 模拟转数字</p><h4 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h4><p>xDSL<br>DMT</p><h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h3><h4 id="数据链路层使用信道有两种类型："><a href="#数据链路层使用信道有两种类型：" class="headerlink" title="数据链路层使用信道有两种类型："></a>数据链路层使用信道有两种类型：</h4><p>1.点对点信道<br>2.广播信道 一点多</p><p>链路：一条点对点的物理线路段，中间没有任何其他交换节点</p><p>数据链路层传输的是帧</p><p>帧 -&gt; 帧头+帧尾+物理层地址+校验码</p><p>数据链路层要解决的问题：<br>1.封装成帧<br>2.透明传输（有转义字符，避免中间数据干扰）</p><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>CRC循环允余：只允许无差错接受，出错会要求发送方重传，而不是中间重传<br>实现可靠传输：差错检测+确认+重传机制</p><h4 id="如何组帧："><a href="#如何组帧：" class="headerlink" title="如何组帧："></a>如何组帧：</h4><pre><code>字符计数法：在帧头部使用一个计数字段老表明帧内字符数。    缺点:计数字段出错，帧分界出错。字符填充的首尾定界法：使用一些特定字符定界一个帧的开始和结束比特填充的首尾标志法：以特定的比特流作为一帧的开始与结束。违规编码法:一般在物理层使用，利用非传输信号格式的信号来表示一帧的开始与结束。</code></pre><h4 id="点到点协议"><a href="#点到点协议" class="headerlink" title="点到点协议"></a>点到点协议</h4><p>ppp协议（电话网等，一般）<br>    支持多种网络协议<br>    链路协议</p><p>ppp协议三个组成部分<br>1.数据链路层协议支持异步串行或同步串行介质<br>2.使用LCP链路控制协议建立维护链路连接<br>3.网络控制协议NCP允许点对点连接的多种协议<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE.jpg" alt></p><h4 id="ppp实现透明传输"><a href="#ppp实现透明传输" class="headerlink" title="ppp实现透明传输"></a>ppp实现透明传输</h4><pre><code>差错处理    零比特填充</code></pre><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>不能随意延长网线</p><h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><pre><code>数据发送到接收这个时间段，乘坐争用期。没有发生数据碰撞算发送成功。时间为2t（实际为端到端往返时间）以太网最短有效帧 64字节</code></pre><h5 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h5><pre><code>基本退避时间 2t定义参数kk=Min(重传次数，10)从【0，1，...,（2的k次方-1）】随机选一个数，记为r重传所需的延时 为 2t*r</code></pre><p>为了使数据链路层更好的适应多种局域网标准<br>局域网的数据链路层分为两个子层：<br>        逻辑链路控制LLC<br>        媒体接入控制MAC<br>以太网提供的是不可靠的服务，尽最大努力传输</p><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E6%9C%80%E5%A4%A7%E5%8C%96.jpg" alt></p><p>mac地址<br>    前24位指定厂家<br>    mac地址接受以太网单播，多播，广播</p><p>交换机生成树算法<br>多个交换机互联后，通过优先级实现根交换机和生成树</p><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>LAN和VLAN<br>LAN是交换机网络<br>VLAN划分LAN局域网,更小的LAN</p><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><p>网络层应该像传输层提供什么服务？<br>1.虚电路服务<br>2.数据报服务<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.jpg" alt></p><p>现在互联网使用的是数据报服务<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%99%9A%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt></p><h4 id="网际协议-ip"><a href="#网际协议-ip" class="headerlink" title="网际协议 ip"></a>网际协议 ip</h4><p>物理层中继器：集线器转换器<br>数据链路层中继器：网桥<br>网络层中继器：路由器<br>网络层以上中继器：网关</p><h4 id="IP层次化"><a href="#IP层次化" class="headerlink" title="IP层次化"></a>IP层次化</h4><p>ip=网络层+主机层</p><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E5%85%B7%E4%BD%93.jpg" alt></p><p>保留的私网地址<br>    10.0.0.0<br>    172.16.0.0–172.31.0.0<br>    192.168.0.0–192.168.255.0</p><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%BD%9C%E7%94%A8.jpg" alt></p><p>子网掩码：判断两个网址是否在同一网段</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>子网掩码把主机层位分给网络层位</p><p>变长子网划分<br>判断变长子网的主机的网段，主机位归零，网络位做与运算</p><p>超网<br>合并同一物理层上的网段</p><h4 id="ip与mac"><a href="#ip与mac" class="headerlink" title="ip与mac"></a>ip与mac</h4><p>ip地址：决定目标地址<br>mac地址：决定下一跳</p><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BC%A0%E8%BE%93%E6%97%B6ip%E4%B8%8Emac.jpg" alt></p><p>两个计算机跨网段通信，在网络层是透明的，数据链路层不断更改mac地址，传输数据帧</p><h4 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h4><p>arp广播询问主机ip地址</p><p>arp欺骗：利用arp 修改ip地址对应的mac地址，实现截获发送给该ip地址的数据包。</p><h4 id="rarp-逆向arp协议"><a href="#rarp-逆向arp协议" class="headerlink" title="rarp 逆向arp协议"></a>rarp 逆向arp协议</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/rarp.jpg" alt></p><p>偏移量：字节数除以8的偏移量，代表关于8个字节的偏移量为多少。</p><p>路由：<br>沿途路由器必须知道到目标网络的下一跳给哪个接口<br>默认路由 0.0.0.0 就是网关</p><p>网关的目的确定一条指定的路线</p><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/icmp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/icmp%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.jpg" alt></p><h4 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h4><p>RIP：动态路由协议，周期性广播30秒，最大跳数16<br>OPSF：内部网关协议，触发式更新，支持多区域，开放式<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ospf.jpg" alt></p><p>BGP：外部网关协议</p><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>访问远程服务器，远程服务器分配私网地址，让其访问<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/vpn.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/vpn%E7%AA%97%E5%8F%A3.jpg" alt></p><h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>通过公有网络时，把私有网址转换为公有网络地址。</p><p>PAT 端口地址转换<br>    外网的人访问内网的web服务器端口，使用PAT,</p><p>应用层准备数据-&gt;传输层分块数据-&gt;网络层打包数据(发片)-&gt;数据链路层封装成帧</p><p>ip协议：<br>rip：（动态路由协议）周期性广播路由表，<br>ospf</p><h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h3><p>TCP:可靠传输，传输的文件需要分段，建立会话<br>UDP：不需要会话，不分段，不可靠传输 例如：多播，广播</p><p>netstat 查看会话</p><p>-an 查看侦听端口</p><p>提供进程中间联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-计算机网络概述&quot;&gt;&lt;a href=&quot;#1-计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;1.计算机网络概述&quot;&gt;&lt;/a&gt;1.计算机网络概述&lt;/h3&gt;&lt;p&gt;许多主机连接-&amp;gt;网络&lt;br&gt;许多网络连接-&amp;gt;互联网&lt;br&gt;做大的互联网-
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://cnawesome.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis学习3</title>
    <link href="https://cnawesome.github.io/2020/02/02/Mybatis%E5%AD%A6%E4%B9%A03/"/>
    <id>https://cnawesome.github.io/2020/02/02/Mybatis%E5%AD%A6%E4%B9%A03/</id>
    <published>2020-02-01T23:57:28.000Z</published>
    <updated>2020-03-09T10:31:06.793Z</updated>
    
    <content type="html"><![CDATA[<p>1.mybatis的curd（基于代理dao的方式）<br>2.mybatis的参数深入及结果集的深入<br>3.mybatis种基于传统dao方式<br>4.mybatis中配置（主配置文件）<br>    properties标签<br>    typeAliases标签</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.mybatis的curd（基于代理dao的方式）&lt;br&gt;2.mybatis的参数深入及结果集的深入&lt;br&gt;3.mybatis种基于传统dao方式&lt;br&gt;4.mybatis中配置（主配置文件）&lt;br&gt;    properties标签&lt;br&gt;    typeAliases标
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java基础2</title>
    <link href="https://cnawesome.github.io/2020/02/01/java%E5%9F%BA%E7%A1%802/"/>
    <id>https://cnawesome.github.io/2020/02/01/java%E5%9F%BA%E7%A1%802/</id>
    <published>2020-02-01T12:50:25.000Z</published>
    <updated>2020-03-06T23:39:28.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>this关键字：<br>    1.代表对象<br>    2.调用对象构造</p><p>垃圾回收机制：<br>fn：不一定销毁类的存储</p><p>java复用类<br>    1.组合复用<br>    2.继承复用</p><p>类被当作字符串输出时，调用tostring()；</p><p>静态方法不具备多态性</p><p>java单继承</p><p>多继承是接口；</p><p>实现类+已有类+接口；<br>接口=不实现方法+静态，最终变量；</p><p>stringbld 可变字符串</p><p>java类型信息</p><p>类型<br>每一个类都是class的一个对象；</p><p>反射：java能获得不知道的类的结构和方法（运行时）</p><p>限定类名，就是类名全称，带包路径的用点隔开，例如: java.lang.String。<br>非限定(non-qualified)类名也叫短名，就是我们平时说的类名，不带包的，例如：String。</p><h2 id="类全名、二进制名、全限定名是一个东西。"><a href="#类全名、二进制名、全限定名是一个东西。" class="headerlink" title="类全名、二进制名、全限定名是一个东西。"></a>类全名、二进制名、全限定名是一个东西。</h2><p>类全名：java.lang.Thread（用于日常的沟通表达）<br>二进制名：java.lang.Thread（Java 语言规范中的定义）<br>全限定名：java/lang/Thread（class 文件结构中的二进制名格式，在描述符中使用，只有非数组引用类型有）</p><p>由于历史原因，class 文件结构中的二进制名格式，跟 java 语言规范中定义的二进制名格式有所不同。</p><p>Java 语言规范中定义的二进制名格式，使用 . 作为分隔符。<br>class 文件结构中的二进制名格式，使用 / 作为分隔符。</p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><p>分为字段描述符、方法描述符。<br>字段描述符，其实就是类型描述符，分为原始类型描述符、非数组引用类型描述符、数组引用类型描述符。</p><p>原始类型描述符：C、D、F、I、J、S、Z<br>非数组引用类型描述符：L全限定名;<br>数组引用类型描述符：[自己元素类型的描述符<br>如：<br>int 的描述符：I<br>Thread 的描述符：Ljava/lang/Thread;<br>Thread[][][] 的描述符：[[[Ljava/lang/Thread;（是几维数组，就有几个 [）</p><h2 id="JAVA的JVM的内存可分为3个区：堆-heap-、栈-stack-和方法区-method"><a href="#JAVA的JVM的内存可分为3个区：堆-heap-、栈-stack-和方法区-method" class="headerlink" title="JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)"></a>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</h2><p>堆区:<br>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身<br>栈区:<br>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中<br>2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。<br>方法区:<br>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p><p><img src="jvm%E8%BF%90%E8%A1%8C%E6%97%B6.ng" alt=""></p><p>一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。<br>接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：<br>Sample test1=new Sample(“测试1”);<br>语句很简单啦，就是让java虚拟机创建一个Sample实例，并且呢，使引用变量test1引用这个实例。貌似小case一桩哦，就让我们来跟踪一下Java虚拟机，看看它究竟是怎么来执行这个任务的：<br>1、 Java虚拟机一看，不就是建立一个Sample实例吗，简单，于是就直奔方法区而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到@@， 这会儿的方法区里还没有Sample类呢。可Java虚拟机也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的类型信息存放在方法区里。<br>2、 好啦，资料找到了，下面就开始干活啦。Java虚拟机做的第一件事情就是在堆区中为一个新的Sample实例分配内存, 这个Sample实例持有着指向方法区的Sample类的类型信息的引用。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址， 其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample实例的数据区里。<br>3、 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方 法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位 于“=”前的Test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，它被会添加到了执行main()方法的主线程的JAVA方 法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，它持有指向Sample实例的引用。<br>OK，到这里为止呢，JAVA虚拟机就完成了这个简单语句的执行任务。参考我们的行动向导图，我们终于初步摸清了JAVA虚拟机的一点点底细了，COOL！<br>接下来，JAVA虚拟机将继续执行后续指令，在堆区里继续创建另一个Sample实例，然后依次执行它们的printName()方法。当JAVA虚拟机 执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample 实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指 令。</p><p>c 控制反转：解决程序合<br>依赖注入：依赖关系的维护由来</p><p>接口与抽象类的关系<br>        No.    区别点        抽象类                                    接口<br>        1    定义            包含一个抽象方法的类                        抽象方法和全局常量的集合<br>        2    组成            构造方法、抽象方法、普通方法、常量、变量        常量、抽象方法<br>        3    使用            子类继承抽象类(extends)                    子类实现接口(implements)<br>        4    关系            抽象类可以实现多个接口                    接口不能继承抽象类，但允许继承多个接口<br>        5    常见            设计模式    模板设计                            工厂设计、代理设计<br>        6    对象                    都通过对象的多态性产生实例化对象<br>        7    局限            抽象类有单继承的局限                        接口没有此局限<br>        8    实际            作为一个模板                                是作为一个标准或是表示一种能力<br>        9    选择                    如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限<br>        10    特殊                    一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类<br>————————————————</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;this关键字：&lt;br&gt;    1.代表对象&lt;br&gt;    2.调用对象构造&lt;/p&gt;
&lt;p&gt;垃圾回收机制：&lt;br&gt;fn：不一定销毁类的存储&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://cnawesome.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://cnawesome.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis学习(2)</title>
    <link href="https://cnawesome.github.io/2020/02/01/Mybatis%E5%AD%A6%E4%B9%A02/"/>
    <id>https://cnawesome.github.io/2020/02/01/Mybatis%E5%AD%A6%E4%B9%A02/</id>
    <published>2020-02-01T03:07:45.000Z</published>
    <updated>2020-03-09T10:30:57.514Z</updated>
    
    <content type="html"><![CDATA[<p>自定义的mybatis通过例.1看到的类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自定义的mybatis通过例.1看到的类&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="https://cnawesome.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>爱情公寓观感</title>
    <link href="https://cnawesome.github.io/2020/01/31/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93%E8%A7%82%E6%84%9F/"/>
    <id>https://cnawesome.github.io/2020/01/31/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93%E8%A7%82%E6%84%9F/</id>
    <published>2020-01-31T12:10:05.000Z</published>
    <updated>2020-03-10T12:36:52.707Z</updated>
    
    <content type="html"><![CDATA[<p>大力大力你真棒</p><h3 id="大力的模拟家庭实验"><a href="#大力的模拟家庭实验" class="headerlink" title="大力的模拟家庭实验"></a>大力的模拟家庭实验</h3><pre><code>财务计划：总资产 -固定投资-日常开销-应急备用        总资产的70%作备用金，投资金。        剩下是使用金。</code></pre><h3 id="大力的知识储存"><a href="#大力的知识储存" class="headerlink" title="大力的知识储存"></a>大力的知识储存</h3><pre><code>喷嚏传播的速度是120公里每秒，2秒能传播整个房间。感冒在痊愈前传染更强。量子纠缠，量子描述物质或物质量的最小单位，量子纠缠描述的是两个物质不论距离多远，一方变化都会影响另一方，爱因斯坦称之为诡异的互动性</code></pre><p>(1-COSt)/SINt = SINt/(1+COSt)</p><p>两个看似不同的表现但实质上是同一个东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大力大力你真棒&lt;/p&gt;
&lt;h3 id=&quot;大力的模拟家庭实验&quot;&gt;&lt;a href=&quot;#大力的模拟家庭实验&quot; class=&quot;headerlink&quot; title=&quot;大力的模拟家庭实验&quot;&gt;&lt;/a&gt;大力的模拟家庭实验&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;财务计划：总资产 -固定投资-日常开销
      
    
    </summary>
    
    
      <category term="生活" scheme="https://cnawesome.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://cnawesome.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Matlap学习</title>
    <link href="https://cnawesome.github.io/2020/01/31/Matlap%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cnawesome.github.io/2020/01/31/Matlap%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-01-31T09:20:35.000Z</published>
    <updated>2020-03-06T23:39:28.216Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵处理<br>科学计算</p><h2 id="专题预览"><a href="#专题预览" class="headerlink" title="专题预览"></a>专题预览</h2><p>专题一： matlap基础知识<br>专题二： matlap矩阵处理<br>专题三： matlap程序流程控制<br>专题四： matlap绘图<br>专题五： 数据分析和多项式计算<br>专题六： 数值微积分与方程求解<br>专题七： matlap符号计算<br>专题八： matlap图形用户界面<br>专题九： simulink系统仿真<br>专题十： 外部程序接口</p><h3 id="专题一：-matlap基础知识"><a href="#专题一：-matlap基础知识" class="headerlink" title="专题一： matlap基础知识"></a>专题一： matlap基础知识</h3><p>… //续行符</p><p><img src="matlap%E7%95%8C%E9%9D%A2.png" alt=""></p><h4 id="数值数据类型分类"><a href="#数值数据类型分类" class="headerlink" title="数值数据类型分类"></a>数值数据类型分类</h4><pre><code>整型，浮点型，复数型format 只改变数据输出形式，不改变存储和计算。函数的调用格式: 函数名（参数）常用函数的应用    &gt;&gt;sin()    &gt;&gt;abs(-4) //绝对值，复数的模，字符串deascll值    &gt;&gt;round（）四舍五入取整    //求1到100之间的所有素数    &gt;&gt; x=1:100    &gt;&gt; k=isprime(x)    &gt;&gt; k1=find(k)    &gt;&gt; p=x(k1)</code></pre><h4 id="变量及其操作"><a href="#变量及其操作" class="headerlink" title="变量及其操作"></a>变量及其操作</h4><pre><code>变量是内存单元的一个抽象。以字母开头区分大小写。标准函数名必须小写。赋值语句    变量=表达式    表达式</code></pre><p>who ,whos 输出所有变量</p><h4 id="内存变量文件"><a href="#内存变量文件" class="headerlink" title="内存变量文件"></a>内存变量文件</h4><p>save ，创建内存变量文件<br>load，</p><h4 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h4><pre><code>基本数据对象建立矩阵1.直接输入法    A=[1,2,3;4,5,6,;7,8,9]2.利用要建立好的矩阵建立更好的矩阵。    A=[1,2,3]    B=[4,5,6]    C=[A,B;B,A]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;矩阵处理&lt;br&gt;科学计算&lt;/p&gt;
&lt;h2 id=&quot;专题预览&quot;&gt;&lt;a href=&quot;#专题预览&quot; class=&quot;headerlink&quot; title=&quot;专题预览&quot;&gt;&lt;/a&gt;专题预览&lt;/h2&gt;&lt;p&gt;专题一： matlap基础知识&lt;br&gt;专题二： matlap矩阵处理&lt;br&gt;专题三：
      
    
    </summary>
    
    
      <category term="生活" scheme="https://cnawesome.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="matlap" scheme="https://cnawesome.github.io/categories/%E7%94%9F%E6%B4%BB/matlap/"/>
    
    
      <category term="matlap" scheme="https://cnawesome.github.io/tags/matlap/"/>
    
  </entry>
  
</feed>
