<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux内核2.0</title>
    <url>/2020/04/16/linux%E5%86%85%E6%A0%B82-0/</url>
    <content><![CDATA[<h3 id="80x86保护模式及其编程"><a href="#80x86保护模式及其编程" class="headerlink" title="80x86保护模式及其编程"></a>80x86保护模式及其编程</h3><pre><code>-本书介绍的linux擦欧总系统基于intel公司80x86
及其相关外围硬件组成的pc机。</code></pre><p>80x86 参考书籍： 《IA-32 intal体系结构软件开发者手册》<br>，《系统编程指南》</p>
<h4 id="80x86-系统寄存器和系统指令"><a href="#80x86-系统寄存器和系统指令" class="headerlink" title="80x86 系统寄存器和系统指令"></a>80x86 系统寄存器和系统指令</h4><h5 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h5><p>标志寄存器： EFLAGS的系统标志和IOPL字段用于控制i/o访问，可屏蔽硬件中断，调试，任务切换以及虚拟-8086模式。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br>内存管理寄存器：<br>处理器提供四个内存管理寄存器（GDTR，LDTR，IDTR和TR），用于指定分段内存管理所使用的系统表的基地址。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br>控制寄存器：（CR0，CR1，CR2和CR3），用于控制和确定处理器的操作模式以及当前执行的任务的特性。<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt></p>
<h5 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A42.jpg" alt></p>
<h5 id="保存模式内存管理"><a href="#保存模式内存管理" class="headerlink" title="保存模式内存管理"></a>保存模式内存管理</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A22.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A23.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E4%BF%9D%E6%8A%A4.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%9C%B0%E5%9D%80%E4%BF%9D%E6%8A%A42.jpg" alt></p>
<p>虚拟地址 采用 段结构<br>段地址 映射到 线性地址<br>线性地址 映射到 物理地址<br>线性地址 可采用 页表结构</p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%892.jpg" alt></p>
<h5 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h5><p>段描述表 分为 GDT(全局描述表) 和 LDT(局部描述表)<br>虚拟内存中，一般是GDT，一半是LDT。<br>GDT任务共享<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A82.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A83.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A84.jpg" alt></p>
<h5 id="段选择符"><a href="#段选择符" class="headerlink" title="段选择符"></a>段选择符</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A64.jpg" alt></p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/80x86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%AB%AF%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A64.jpg" alt></p>
<p>段选择符 指向 段描述符表 向内寻找 段描述符 找到对应的空间</p>
<pre><code>-------2020.4.17  这段主要是介绍内存的管理，段内存的寻址
至101页</code></pre><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B2.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B3.jpg" alt></p>
<h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B62.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B63.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B64.jpg" alt></p>
<h5 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h5><pre><code>二级页表有点难懂</code></pre><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%842.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%843.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%844.jpg" alt></p>
<h5 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h5><p>段级保护和页级保护</p>
<h4 id="中断可异常处理"><a href="#中断可异常处理" class="headerlink" title="中断可异常处理"></a>中断可异常处理</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E4%B8%AD%E6%96%AD%E6%BA%90.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E6%BA%90.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%80%E5%90%AF%EF%BC%8C%E7%A6%81%E6%AD%A2%E4%B8%AD%E6%96%AD.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A82.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A62.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%862.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%863.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%864.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%865.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%866.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/8086%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%867.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%862.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%863.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt><br>任务状态段：<br>用于恢复一个任务执行的处理器状态信息被保存在称为任务状态段TSS的段中。<br>TSS段中个字段分为两大类： 动态字段和静态字段<br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.jpg" alt></p>
<p><a href="任务管理数据结构动态字段.jpg"></a><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86tss%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt></p>
<p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%93%BE.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%93%BE2.jpg" alt><br>保护模式系统表：一个代码段和数据段的GDT，支持分页机制的页目录和页表，每个应用程序的段和LDT表段。<br>保护模式异常和中断初始化：如见初始化设置一个保护模式IDT，IDT门描述符，任务门，TSS以及相关代码，数据和堆栈段<br>分页机制初始化：控制寄存器CR0的PG标志设置。<br>多任务初始化：TSS及TSS段描述符。</p>
<h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F.jpg" alt><br><img src="/2020/04/16/linux%E5%86%85%E6%A0%B82-0/%E5%88%87%E6%8D%A2%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F2.jpg" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux内核1.0</title>
    <url>/2020/04/15/linux%E5%86%85%E6%A0%B81-0/</url>
    <content><![CDATA[<pre><code>---------- 再一次看内核书籍，这一次一定要努力看完</code></pre><h3 id="1-linux的由来"><a href="#1-linux的由来" class="headerlink" title="1.linux的由来"></a>1.linux的由来</h3><p>由unix，minix，gun计划，posix标准，internet网络发展过来。</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC2.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6.jpg" alt><br>bootimage 是软盘印象image的引导启动文件。<br>包括磁盘引导扇区代码，操作系统加载程序和内核执行代码。</p>
<p>磁盘引导扇区代码：<br>    pc的ram bios启动-&gt;默认启动驱动器的引导扇区代码-&gt;操作系统加载程序和内核执行代码读入内存-&gt;操作系统加载程序进行初始化内核-&gt;最终加载陈旭把控制权交给内核代码</p>
<p>内核代码正常运行需要文件系统的支持。</p>
<p>rootimage 向内和提供基本的根文件系统。</p>
<p>这两个盘合起来相当于一个可启动的dos操作系统盘。</p>
<p>as86.tar.Z 是16位汇编器连接程序软件包<br>Ǆlinux-0.11.tar.Z 压缩的内核源代码</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linnux%E7%9B%AE%E5%BD%95.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E5%8F%82%E8%80%83%E7%9A%84%E4%B9%A6.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%AF%9E%E7%94%9F.jpg" alt></p>
<h3 id="微型计算机组成结构"><a href="#微型计算机组成结构" class="headerlink" title="微型计算机组成结构"></a>微型计算机组成结构</h3><h4 id="i-o端口寻址"><a href="#i-o端口寻址" class="headerlink" title="i/o端口寻址"></a>i/o端口寻址</h4><p>cpu访问i/o接口控制器或其上的信息，需要首先指定他们的地址。这种地址成为i/o端口</p>
<p>i/o控制器 包含：访问数据的数据端口，输出命令的命令端口，访问控制器状态的状态端口。</p>
<p>端口地址的设置方法：1.统一编制：2.独立编址<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%AB%AF%E5%8F%A3%E7%BB%9F%E4%B8%80%E7%BC%96%E5%9D%80.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%AB%AF%E5%8F%A3%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80.jpg" alt></p>
<p>Linux下 在/proc/ioports 可以查看相关控制器或设置使用的i/o地址范围</p>
<h4 id="接口访问控制"><a href="#接口访问控制" class="headerlink" title="接口访问控制"></a>接口访问控制</h4><p>pc机接口数据传输控制方式：<br>    1.程序循环查询方式<br>    2.中断处理方式<br>    3.DMA传输方式</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.jpg" alt></p>
<h3 id="主存，bios和cmos存储器"><a href="#主存，bios和cmos存储器" class="headerlink" title="主存，bios和cmos存储器"></a>主存，bios和cmos存储器</h3><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>计算机上电-&gt;内存地址初始化（除去0xA0000到0xFFFFF 640K到1M 和  0xFFFE0000 到0xFFFFFFFF 4g处的最后一64k，这两个区域特定用于i/o设备和bios程序）</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/at%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9F%9F.jpg" alt></p>
<h4 id="bios"><a href="#bios" class="headerlink" title="bios"></a>bios</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/bios.jpg" alt><br>计算机上电-&gt; 内存地址初始化-&gt; cpu自动把代码段寄存器cs设置为0xF000，段基地址为 0xFFFF0000，段长度为64kb-&gt; ip=0xFFF0,cpu代码指向 0xFFFFFFF0 ，系统ram bios程序存放位置-&gt; bios在该位置存放一条jmp跳转指令转入bios内开始执行-&gt; bios执行初始化后将bios代码与数据复制到内存低端1M末端的64k处-&gt; 跳转到该位置让cpu静茹真正的实地址模式工作-&gt; 将操作系统引导程序加载到内存0x7c00处，继续执行引导程序<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/bios%E6%89%A7%E8%A1%8C.jpg" alt></p>
<h4 id="cmos"><a href="#cmos" class="headerlink" title="cmos"></a>cmos</h4><p>存储系统硬件信息和时钟信息</p>
<h3 id="控制器和控制卡"><a href="#控制器和控制卡" class="headerlink" title="控制器和控制卡"></a>控制器和控制卡</h3><p>—–2020.4.15</p>
<h4 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h4><p>ibm pc/at 80x86 兼容微机使用两片级联的8259A可编程中断控制芯片醉成中断控制器。如图2-6.</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%9B%BE2-6.jpg" alt></p>
<p>计算机初始化时，<br>    -&gt; rom bios 对两片8259芯片初始化<br>    -&gt; 同时，把15个中断优先级分配给时钟定时器，键盘，串行口，打印口，等设备控制器使用<br>    -&gt; 同时，在内存开始处0x000-0xFFF区域建立一个中断向量表。</p>
<p>linux对此做了重新的设置。</p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%AE%9A%E6%97%B6%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt></p>
<h4 id="键盘控制器"><a href="#键盘控制器" class="headerlink" title="键盘控制器"></a>键盘控制器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt><br>键盘控制器=键盘的键盘编码器+主机的键盘控制器</p>
<p>键盘编码器收集按键按下松开的状态信息（即扫描码）-&gt;  主机键盘控制器接收到键盘扫描码（11为的串行信息）后进行解码-&gt; 转换位pc/xt标准键盘兼容的系统扫描码-&gt; 通过中断控制器IRQ1引脚向cpu发送中断请求-&gt; 响应该中断请求后，调用键盘中断处理程序来读取控制器的xt键盘扫描码-&gt; 解码后把数据发送给操作系统的键盘数据队列中</p>
<h4 id="串行控制卡"><a href="#串行控制卡" class="headerlink" title="串行控制卡"></a>串行控制卡</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E4%B8%B2%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8.jpg" alt></p>
<h4 id="磁盘控制器"><a href="#磁盘控制器" class="headerlink" title="磁盘控制器"></a>磁盘控制器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%98.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%982.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%983.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E7%A3%81%E7%9B%984.jpg" alt></p>
<h3 id="内核编程语言和环境（阅读源码的准备工作）"><a href="#内核编程语言和环境（阅读源码的准备工作）" class="headerlink" title="内核编程语言和环境（阅读源码的准备工作）"></a>内核编程语言和环境（阅读源码的准备工作）</h3><h4 id="as86汇编器"><a href="#as86汇编器" class="headerlink" title="as86汇编器"></a>as86汇编器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96%E5%99%A8%E4%BB%8B%E7%BB%8D.jpg" alt></p>
<p>as86汇编语句：赋值语句，伪操作符语句，机器指令语句<br>汇编器编译的产生的目标文件起码包含三个段或区：正文段，数据段，未初始化数据段</p>
<p>简单的引导扇区启动程序：<br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A5.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A.jpg" alt></p>
<h4 id="gun-as汇编器"><a href="#gun-as汇编器" class="headerlink" title="gun as汇编器"></a>gun as汇编器</h4><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%951.jpg" alt><br>as汇编器有简单的预处理功能</p>
<h5 id="指令语句，操作数和寻址"><a href="#指令语句，操作数和寻址" class="headerlink" title="指令语句，操作数和寻址"></a>指令语句，操作数和寻址</h5><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%93%8D%E4%BD%9C%E7%A0%81%E5%91%BD%E5%90%8D.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E6%93%8D%E4%BD%9C%E7%A0%81%E5%89%8D%E7%BC%80.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E5%91%BD%E4%BB%A4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/gas%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%9916%E4%BD%8D.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/ld%E8%BF%9E%E6%8E%A5%E5%99%A8%E5%8C%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D.jpg" alt></p>
<h3 id="c语言环境"><a href="#c语言环境" class="headerlink" title="c语言环境"></a>c语言环境</h3><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96%E7%BB%84%E5%90%88%E8%AF%AD%E5%8F%A5.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/as86%E6%B1%87%E7%BC%96bootsec%E5%AE%9E%E4%BE%8B%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8c%E5%87%BD%E6%95%B01.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8c%E5%87%BD%E6%95%B02.jpg" alt></p>
<p>汇编调用c函数，将参数入栈，call函数名即调用带有参数的函数</p>
<p>这里看的云里雾里的，不太行</p>
<h4 id="linux目标文件格式"><a href="#linux目标文件格式" class="headerlink" title="linux目标文件格式"></a>linux目标文件格式</h4><p>本书介绍:<br>    编译器申城目标文件结构-&gt; 链接器把目标文件模块组合，生成二进制可执行映像文件</p>
<pre><code>二进制代码文件image生成原理与过程</code></pre><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F2.jpg" alt></p>
<pre><code>执行头部分：包含有关整体结构信息。
代码区：由编译器或汇编器生成的二进制指令代码和数据信息。
数据区：由编译器或汇编器生成的数据信息。
代码重定部分：含有供链接程序使用的记录数据。
数据重定位部分：用于数据段重定位。
符号表部分：同样含有供链接程序使用的记录数据。
字符串表部分：含有与符号命相对应的字符串</code></pre><p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F4.jpg" alt></p>
<p><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C2.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C3.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C4.jpg" alt><br><img src="/2020/04/15/linux%E5%86%85%E6%A0%B81-0/linux%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%93%8D%E4%BD%9C5.jpg" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学1.0</title>
    <url>/2020/04/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61-0/</url>
    <content><![CDATA[<hr>
]]></content>
  </entry>
  <entry>
    <title>ubuntu 操作</title>
    <url>/2020/04/08/ubuntu-%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>whoami 用来查看当前用户名</p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>APT管理软件：高级报管理工具</p>
<p>软件更新，升级<br>    sudo apt-get update 或者 sudo apt-get upgrade<br>软件安装<br>    sudo apt-get install 软件包名</p>
<p>软件删除<br>    sudo apt-get remove</p>
<p>搜索软件包<br>    sudo apt-get search 软件包名</p>
<p>显示该包的依赖信息<br>    sudo apt-get depends 软件包名</p>
<h4 id="dpkg-command"><a href="#dpkg-command" class="headerlink" title="dpkg command"></a>dpkg command</h4><p>安装dpkg命令：<br>    sudo dpkg -i deb 包名</p>
<p>shutdown 关机命令<br>    -t 告诉init多久后关机<br>    -r 重新启动<br>    -k 不是真正的关机，只是警告信息<br>    -h 关机后关闭电源</p>
<p>halt 命令 关闭系统</p>
<p>putty 远程登录<br>    pputty以中国远程登陆工具，功能强大</p>
<pre><code>1。在服务器端安装openssh-server
openssh服务器组件sshd持续监听老子客户端工具的连接请求。

在ubuntu安装 openssh-serve

sudo apt-get install opensssh-server

2.客户端安装putty</code></pre><h2 id="ubuntu-文件管理"><a href="#ubuntu-文件管理" class="headerlink" title="ubuntu 文件管理"></a>ubuntu 文件管理</h2><p>在linux里，一切都看作文件<br>在linux中没有磁盘的逻辑分区，任何一种类的文件系统被创建后都需要挂载到某个特定的目录才能使用。</p>
<p>linux用磁盘块管理内存空间。磁盘块=超级节点+i-节点+数据块</p>
<p>cat命令：显示文件或追加文件<br>cat -n 编号输出文件<br>cat可以用于输出重定向，将现有的文件内容重定向到已有的文件。如果目标文件不存在，创建该文件。<br>    cat a1.txt&gt;a2.txt<br>    cat a1.txt&gt;&gt;a2.txt 表示追加重定向</p>
<p>more显示输出内容，根据窗口大小调整分页 </p>
<p>less 显示文件</p>
<p>head 显示文件前n行，不带选项时默认显示前10行<br>tail 显示文件后n行</p>
<p>echo 输出字符串到基本输出，在显示器的输出</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>一个由标准输入</p>
<h3 id="linux-多用户"><a href="#linux-多用户" class="headerlink" title="linux 多用户"></a>linux 多用户</h3><p>liunx用户分类：<br>    1.超级用户<br>    2.系统用户（一些系统进程的使用名）<br>    3.普通用户</p>
<p>每一个用户都只能属于一个基本用户组，可以属于多个附加组。</p>
<p>quote 磁盘配额</p>
<p>物理内存时系统提供的内存大小。<br>linux的虚拟内存时利用磁盘空间的一块逻辑内存<br>用作虚拟内存的磁盘空间称为交换空间<br>swap时linux下的虚拟内存分区，作用是在物理内存使用完之后，将磁盘空间即swap分区当作内存来使用。</p>
<p>gcc 编译流程：预编译，编译，汇编（生成目标文件），链接（生成可执行文件）</p>
<p>gdb程序调试工具</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计4.0</title>
    <url>/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/</url>
    <content><![CDATA[<h3 id="散列-hashing"><a href="#散列-hashing" class="headerlink" title="散列 hashing"></a>散列 hashing</h3><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%8E%9F%E7%90%86.jpg" alt></p>
<p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E4%BE%8B.jpg" alt></p>
<p>三列表长度：90001</p>
<p>n/m ：装填因子</p>
<p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81.jpg" alt></p>
<p>散列冲突处理方式：<br>    1.选择有效的散列函数<br>    2.多槽位<br>    3.</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%BB%BB%E5%8A%A1.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E9%99%A4%E4%BD%99%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0MAD%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%8A%98%E5%8F%A0%E6%B3%95.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95.jpg" alt></p>
<h4 id="多槽位"><a href="#多槽位" class="headerlink" title="多槽位"></a>多槽位</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E5%A4%9A%E6%A7%BD%E4%BD%8D.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E7%8B%AC%E7%AB%8B%E9%93%BE.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E6%95%A3%E5%88%97%E8%A1%A8%E5%86%B2%E7%AA%81%E7%8B%AC%E7%AB%8B%E9%93%BE%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" alt></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E6%80%A7.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%A0%86%E5%BA%8F%E6%80%A7.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p>按优先级排序，需要一个优先级队列来实现</p>
<h4 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h4><p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/04/02/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A14-0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p>删除操作：为什么不用左子树根节点？<br>如果用左子树根节点换根节点，也必然会出现顺序错误，在调整顺序的操作上比起用最后一个节点来说，多余了一些操作。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>c++笔记</title>
    <url>/2020/03/26/c-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="define宏定义"><a href="#define宏定义" class="headerlink" title="define宏定义"></a>define宏定义</h3><p>ANSI标准五个预定义的宏名<br>    <strong>LINE</strong> 表示该行代码的所在行号<br>    <strong>FILE</strong> 表示源文件的文件名<br>    <strong>DATE</strong> 表示源文件被编译的日期，格式(月/日/年)<br>    <strong>TIME</strong> 表示源文件被编译成目标代码的时间，格式(时:分:秒)<br>    <strong>STDC</strong> 表示编译器是否标准，标准时表示常量1，非标准则表示其它数字</p>
<p>宏定义可以使用在函数身上：</p>
<pre><code>#define INFO(msg) info_debug(__FILE__, __LINE__, __DATE__, __TIME__, msg) 

void info_debug(const char* filename, int line, const char* date, const char* time, const char* msg)
{
    printf_s(&quot;info_debug %s:%d (%s-%s):%s&quot;, filename, line, date, time, msg);
}

int main()
{
    INFO(&quot;Hello world!\n&quot;);
    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>宏定义的细节<br>    1）对于有参数的宏定义，宏定义时，在宏名与带参数的括号之间不应加空格，否则将空格以后的字符都作为替代字符串的一部分。<br>    2）带参数的宏定义只是进行简单的字符替换，宏展开则是在编译前进行的，在展开时并不分配内存单元，不进行值的传递处理，因此替换不会占用运行时间，只占用编译时间。<br>    3）宏不存在类型问题，宏名无类型，宏的参数也无类型，只是一个符号代表，展开时代入指定的字符串即可，宏定义时，字符串可以是任何类型的数据。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>错误集</title>
    <url>/2020/03/23/%E9%94%99%E8%AF%AF%E9%9B%86/</url>
    <content><![CDATA[<p>ifndef 的作用<br>    当有很多头文件时，一般都需要用它<br>    它可以防止头文件被一个源文件多次包含出现冲突<br>    不是防止两个源文件包含同一个头文件</p>
]]></content>
  </entry>
  <entry>
    <title>Android学习日记1.0</title>
    <url>/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/</url>
    <content><![CDATA[<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/newPJ.jpg" alt></p>
<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/moudle.jpg.jpg" alt></p>
<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80.jpg" alt><br><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/manifest.jpg" alt></p>
<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/mainactivity.jpg" alt></p>
<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/r%E6%96%87%E4%BB%B6.jpg" alt><br>android R文件出现问题可以 clear 恢复。</p>
<p><img src="/2020/03/21/Android%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01-0/r%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3.jpg" alt></p>
<p>res/：包含应用资源，例如可绘制对象文件、布局文件和 UI 字符串。</p>
<p>raw/：用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！其实和Assets差不多，不过这里面的资源会在R文件那里生成一个资源id而已。</p>
<p>AVD：安卓模拟器</p>
<p>viewgroup是抽象类，一般使用它的子类</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计3.0</title>
    <url>/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/</url>
    <content><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD.jpg" alt><br>v 顶点 ，e 边<br>|v| 顶点个数 ，|e| 边数</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%97%A0%E5%90%91%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%9C%89%E5%90%91%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E6%9C%89%EF%BC%8C%E6%97%A0%E5%90%91%E5%9B%BE.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E8%B7%AF%E5%BE%84.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E8%BE%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E6%93%8D%E4%BD%9C.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E6%93%8D%E4%BD%9C%E5%85%B7%E4%BD%93.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E9%A1%B6%E7%82%B9%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%A1%B6%E7%82%B9%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E9%A1%B6%E7%82%B9%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt><br>在图中插入一个新的节点</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E8%BE%B9%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E8%BE%B9%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h4 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS 广度优先遍历"></a>BFS 广度优先遍历</h4><p>把图化为树，把非线性变为半线性。<br>正如把树通过遍历化为队列，把半线性化为了线性。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS.jpg" alt></p>
<p>图的广度优先遍历类似与树的层次遍历。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E4%BB%A3%E7%A0%811.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84BFS%E8%BF%87%E7%A8%8B1.jpg" alt></p>
<p>简单的实现，不建议模仿</p>
<pre><code>void BFS(Graph g,int n){// 广度优先遍历
    if(g.v[n].vs==UNDISCOVER||g.v[n].vs==DISCOVER){
        g.v[n].vs=VISITED;
    }
    for (int i = 0; i &lt;MAX ; i++) //入栈相邻节点
    {
           if(g.e[i][n].hasEdge == 1 &amp;&amp; g.v[i].vs==UNDISCOVER){
                g.v[i].vs=VISITED;
                Vquene[k++]=i;
           }
    }
    for (int j = k+1; j &lt; MAX; j++)
    {
        Vquene[j]=-1;
    }

    if(Vquene[0]!=-1){
        printf(&quot;next node number:%d\n&quot;,Vquene[0]);
        int num=Vquene[0];
        for (int p = 0; p &lt;MAX; p++)
        {
            Vquene[p]=Vquene[p+1];
        }

        BFS(g,num);
}</code></pre><p>按BFS广度优先遍历出来的节点到节点的距离时最短路径。</p>
<h4 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h4><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/DFS%E4%BB%8B%E7%BB%8D.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84DFS%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84DFS%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82.jpg" alt></p>
<p>分为有向图和无向图的DFS</p>
<p>dTime 刚访问时间  Ftime 结束访问时间</p>
<h4 id="嵌套引理"><a href="#嵌套引理" class="headerlink" title="嵌套引理"></a>嵌套引理</h4><p>祖先节点 与 子孙节点的依据活跃期判断： 祖先的活跃期必然大于子孙的活跃期<br>连个节点无关，活跃期不相交<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84dtime.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E5%9B%BE%E7%9A%84%E6%B4%BB%E8%B7%83%E6%9C%9F%E7%9A%84%E5%BA%94%E7%94%A8.jpg" alt></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E8%AF%8D%E6%9D%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E9%A1%BA%E5%BA%8F%E6%80%A7.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8E%A5%E5%8F%A3.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%9F%A5%E6%89%BE%E6%8E%A5%E5%8F%A3%E5%9B%BE.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7%E5%8F%98%E6%8D%A2%E5%9B%BE1.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B%E5%9B%BEjpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A4%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A41%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A41%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A42%E5%9B%BE.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E5%88%A0%E9%99%A42%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h4 id="BBST-平衡二叉树"><a href="#BBST-平衡二叉树" class="headerlink" title="BBST 平衡二叉树"></a>BBST 平衡二叉树</h4><p>适度平衡准则，任何一个树节点在BBST外，都可以变换到BBST内部。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/BST%E7%AD%89%E4%BB%B7.jpg" alt></p>
<p>####AVL树</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8E%A5%E5%8F%A3.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%A4%B1%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avlzigzag.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E9%80%82%E5%BA%A6%E5%B9%B3%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%8D%95%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%8F%8C%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%8F%92%E5%85%A5%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%88%A0%E9%99%A4%E5%8F%8C%E6%97%8B.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl%E6%A0%B8%E5%BF%83ro%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p>拥有 链表和向量的特点，并且有很好的很低复杂度。</p>
<p>AVL中，一个节点的删除，只可能是一个节点失衡；而一个节点的插入，可能导致多个节点失衡。</p>
<p>####3+4重构</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl3+4%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/avl3+4%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h4 id="高级搜索树"><a href="#高级搜索树" class="headerlink" title="高级搜索树"></a>高级搜索树</h4><p>伸张树：为了更宽松的使用avl的性质。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E6%95%B4%E6%80%9D%E8%B7%AF.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%B1%80%E9%83%A8%E6%80%A7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A01.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A02.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E4%BC%B8%E5%BC%A0%E6%A0%91%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%BC%A03.jpg" alt></p>
<p>伸张树自适应调整策略并非最佳策略</p>
<h4 id="B-TREE（高级搜索树）"><a href="#B-TREE（高级搜索树）" class="headerlink" title="B-TREE（高级搜索树）"></a>B-TREE（高级搜索树）</h4><p>原因：数据越来越多，让内存看起来越来越小</p>
<p>又称平衡多路搜索树</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E8%8A%82%E7%82%B9.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E9%98%B6%E6%95%B0.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E8%AF%A2%E6%95%88%E6%9E%9C.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E7%B4%A7%E5%87%91%E8%A1%A8%E7%A4%BA.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9C%80%E5%B0%8F%E6%A0%91%E9%AB%98.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9C%80%E5%A4%A7%E6%A0%91%E9%AB%98.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91.jpg" alt><br>利用向量来表示<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91tree%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E6%9F%A5%E6%89%BE%E5%A4%B1%E8%B4%A5.jpg" alt><br>b树的查找失败，必然是在外部的叶子节点。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E5%88%86%E8%A3%82.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E4%B8%8B%E6%BA%A2%E6%97%8B%E8%BD%AC.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/b%E6%A0%91%E4%B8%8B%E6%BA%A2%E5%90%88%E5%B9%B6.jpg" alt></p>
<h4 id="红黑树（高级搜索树）"><a href="#红黑树（高级搜索树）" class="headerlink" title="红黑树（高级搜索树）"></a>红黑树（高级搜索树）</h4><p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%80%E8%87%B4%E6%80%A7%E7%BB%93%E6%9E%84.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B3%E8%81%94%E6%80%A7.jpg" alt></p>
<p>目的：为了使各个版本的BST能更快的访问，更小的空间。</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B3%E8%81%94%E6%80%A7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BA%A2%E4%B8%8E%E9%BB%91.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%91%E4%B8%8A%E6%8F%90%E5%8D%87.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%90%91%E4%B8%8A%E6%8F%90%E5%8D%871.jpg" alt><br>红色节点向上提升与黑节点平齐。<br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%9124%E6%A0%91.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg" alt></p>
<p>红黑树的变化要依赖于b树的结构</p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A51.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A52.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A52%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A53%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A54%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A54%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A55%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A56%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A57%E5%8F%8C%E7%BA%A2%E4%BF%AE%E6%AD%A3%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt></p>
<p><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A41.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B7.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B72.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A42%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B73.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A43%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A43%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B72.jpg" alt><br><img src="/2020/03/19/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A13-0/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A44%E5%8F%8C%E9%BB%91%E7%BC%BA%E9%99%B71.jpg" alt></p>
<h3 id="end-at-2019-4-2"><a href="#end-at-2019-4-2" class="headerlink" title="end at 2019.4.2"></a>end at 2019.4.2</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode配置编译环境</title>
    <url>/2020/03/18/vscode%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<hr>
]]></content>
  </entry>
  <entry>
    <title>电路分析</title>
    <url>/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BD%95%E4%B8%BA%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E5%85%83%E4%BB%B6.jpg" alt></p>
<p>一个电路可能有不同的电路模型<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%B7%AF%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E7%94%B5%E8%B7%AF.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8F%82%E6%95%B0%E7%94%B5%E8%B7%AF.jpg" alt><br>主要研究集总参数电路。</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%B3%A2%E6%AE%B5.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%BD%A2%E6%88%90.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E7%A3%81%E8%83%BD%E9%87%8F.jpg" alt></p>
<h4 id="电路分类："><a href="#电路分类：" class="headerlink" title="电路分类："></a>电路分类：</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%A8%E6%80%81%E7%94%B5%E9%98%BB.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%9C%89%E6%BA%90%E6%97%A0%E6%BA%90.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E6%97%B6%E5%8F%98%E6%97%B6%E4%B8%8D%E5%8F%98%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%94%B5%E8%B7%AF.jpg" alt></p>
<h4 id="电路变量"><a href="#电路变量" class="headerlink" title="电路变量"></a>电路变量</h4><p>为了定量描述电路性能，引入电路变量.<br>分为基本变量和复合变量<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E5%8E%8B%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%BD%A2%E6%88%90.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E6%96%B9%E5%90%91.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E6%B5%81%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg" alt></p>
<p>基本变量如：电流，电压等。<br>复合变量如：功率，能量等。</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%85%B3%E8%81%94%E5%8F%82%E8%80%83%E6%96%B9%E5%90%91.jpg" alt></p>
<p>电路的实际方向不好确定，使用参考方向，参考方向可以任意指定。</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%9F%E7%8E%87%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8A%9F%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%83%BD%E9%87%8F%E8%AE%A1%E7%AE%97.jpg" alt><br>阻值和功率是电阻的属性。<br>超过电阻的额定功率会导致电阻损坏。</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E7%94%B5%E9%98%BB%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt><br>电阻不论是关联和非关联，都是吸收功率。</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%8F%97%E6%8E%A7%E6%BA%90%E6%98%AF%E5%90%A6%E4%B8%BA%E4%BA%8C%E7%AB%AF.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E6%9C%AF%E8%AF%AD.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E5%AE%9A%E5%BE%8B.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/kvl.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%B9%BF%E4%B9%89kvl.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%B9%BF%E4%B9%89kcl.jpg" alt></p>
<p>###电阻等效变换</p>
<h4 id="2b法"><a href="#2b法" class="headerlink" title="2b法"></a>2b法</h4><p>列出所有原件方程，kcl方程，kvl方程<br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/2b%E6%B3%95.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E8%B7%AF%E7%94%B5%E9%98%BB%E5%90%B8%E6%94%B6%E4%B8%8E%E5%8F%91%E5%87%BA.jpg" alt></p>
<h3 id="电路的等效变换"><a href="#电路的等效变换" class="headerlink" title="电路的等效变换"></a>电路的等效变换</h3><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A2.jpg" alt><br>0值电压源等效于0值电阻等效于短路</p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%B8%B2%E5%B9%B6%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E4%B8%B2%E8%81%94.jpg" alt></p>
<p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E5%B9%B6%E8%81%94.jpg" alt></p>
<pre><code>---2020/4/10</code></pre><h4 id="y型电路和三角形电路"><a href="#y型电路和三角形电路" class="headerlink" title="y型电路和三角形电路"></a>y型电路和三角形电路</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E6%8E%A8%E5%AF%BC.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E6%8E%A8%E5%AF%BC2.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/y%E5%9E%8B%E5%92%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E7%94%B5%E8%B7%AF%E7%9A%84%E5%8F%98%E6%8D%A2.jpg" alt></p>
<h3 id="电压等效变换"><a href="#电压等效变换" class="headerlink" title="电压等效变换"></a>电压等效变换</h3><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E4%B8%B2%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E7%90%86%E6%83%B3%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E5%B9%B6%E8%81%94.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E8%A1%A8%E6%8D%A2.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A22.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AE%9E%E9%99%85%E7%8B%AC%E7%AB%8B%E6%BA%90%E7%9A%84%E7%AD%89%E6%95%88%E5%8F%98%E6%8D%A23.jpg" alt></p>
<p>求和电路源串联的电压源的电流时，电压源的电流看作0.</p>
<h4 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E7%89%B9%E6%80%A7.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%E8%B4%9F%E5%8F%8D%E9%A6%88.jpg" alt></p>
<p>在特定的情况下，只能用加压求流，或加流求压。</p>
<pre><code>----2020/4/14</code></pre><h4 id="二端口"><a href="#二端口" class="headerlink" title="二端口"></a>二端口</h4><p><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E4%BA%92%E6%98%93%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt><br><img src="/2020/03/14/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E7%AB%AF%E5%8F%A3.jpg" alt></p>
<pre><code>----2020/4/20</code></pre>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>普通生物学</title>
    <url>/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="生物膜的特性"><a href="#生物膜的特性" class="headerlink" title="生物膜的特性"></a>生物膜的特性</h3><p>1.生物膜具有流动性<br>2.膜蛋白分布不对称<br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C%E7%9A%84%E7%BB%84%E6%88%90.jpg" alt><br>生物膜处于动态运动中</p>
<p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%94%9F%E7%89%A9%E8%86%9C%E7%9A%84%E8%9B%8B%E7%99%BD%E8%B4%A8.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%B4%A8%E5%9F%BA%E8%B4%A8.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%86%9C%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD.jpg" alt></p>
<p>膜蛋白的作用：<br>    1.作为膜转运蛋白，选择性的介导小分子物质的跨膜运输。<br>    2.具有酶的功能<br>    3.作为细胞表面的受体，与激素结合之后将型号传递到胞内<br>    4.糖蛋白的糖链可有哦为细胞之间的识别标志。<br>    5.形成细胞之间的连接<br>    6。作为细胞骨架的连接点。</p>
<p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%86%9C%E8%BD%AC%E8%BF%90%E8%9B%8B%E7%99%BD.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E8%B7%A8%E8%86%9C%E8%BF%90%E8%BE%93%E7%AE%80%E5%8D%95%E6%89%A9%E6%95%A3.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E5%B0%8F%E5%88%86%E5%AD%90%E8%B7%A8%E8%86%9C%E8%BF%90%E8%BE%93.jpg" alt></p>
<p>载体蛋白：通过改变自身构件，转运</p>
<p>小分子的跨膜运输：<br>    简单扩散<br>    被动运输<br>    主动运输</p>
<h4 id="细胞连接"><a href="#细胞连接" class="headerlink" title="细胞连接"></a>细胞连接</h4><p>细胞间或细胞-基质见的接触部位形成特殊的连接结构，叫细胞连接。 </p>
<p><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.jpg" alt><br><img src="/2020/03/14/%E6%99%AE%E9%80%9A%E7%94%9F%E7%89%A9%E5%AD%A6/%E7%BB%86%E8%83%9E%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F1.jpg" alt></p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis(1)</title>
    <url>/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h3><p>什么是框架<br>框架是整个或部分系统的可重用设计，表现为一组抽象构件及抽象构件实例之间加护的方法。（抽象方法，或者实例方法）。<br>它是软件开发中解决问题的一套方案。</p>
<p>mybatis 持久层框架</p>
<p>springnvc 表现层框架</p>
<p>spring 不属于这三个框架</p>
<p>三层架构<br>        表现层：张世数据<br>        业务层：处理业务需求<br>        持久层：数据库交互 </p>
<p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/01%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt></p>
<p>持久层技术解决方案<br>    jdbc技术：<br>            connection<br>            preparedstatement<br>            resultset<br>    jdbc开发不够便捷 </p>
<p>持久层连接数据库池过程<br>    1，加载驱动<br>    2，创建连接<br>    3，创建statement<br>    …</p>
<p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/02%E6%8C%81%E4%B9%85%E5%B1%82%E6%80%BB%E5%9B%BE.jpg" alt><br>Mybatis 通过xml或注解的方式 执行各种statment，并通过java对象和sql的动态参数进行映射形成最终sql语句，最后通过mabatis执行sql语句并返回。<br>利用ORM思想，对jdbc进行封装，屏蔽了jdbc api底层的访问问题</p>
<p>ORM （object relational  mapping）对象关系映射<br>即把数据库的表与实体类及实体类的属性对应起来，让我们可以操作实体类就实现数据表。</p>
<p>如何做到？<br>目前，我们需要把实体类的属性与数据库的字段名保持一致。</p>
<h3 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h3><p>1，创建maven工程，xml 添加依赖坐标（在官网上找依赖语句），同时写上数据库依赖，日志依赖，junit依赖等。<br>2，创建实体类<br>3，创建mybatis主配置文件（SqlMapConfig.xml）<br>4，创建映射配置文件(UserDao.xml)</p>
<p>环境搭建的注意事项:<br>1,创建UserDao.xml和UserDao.java是，名称是为了和我们之前的知识保持一致。在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper。所以UserDAO和UserMapper是一样的。</p>
<p>2.在idea创建目录是，它和包是不一样的 ，包创建时：comit.dao 是三级结构<br>    目录创建时 com.it.dao是一级目录。</p>
<p>3.mybatis的映射配置文件位置必须和dao接口的包结构相同。</p>
<p>4.映射文件的mapper标签namespace属性的取值必须是 dao接口的全限定类名。</p>
<p>5.映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法类,resulttype取值为应用接口的对象。</p>
<p>作用：按3，4，5配置后，无需再写dao的实现类，由mybatis直接实现。</p>
<p>UserDao.xml<br><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/UserDaoxml.PNG" alt></p>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!-- mybatis主配置文件 -->
<configuration>
    <!-- 配制环境 -->
    <environments default="mysql">
        <!-- 配置mysql的环境 -->
        <environments id="mysql">
            <!-- 配置事务类型 -->
            <transactionManager type="JDBC"></transactionManager>
            <!-- 配置数据源（连接池） -->
            <dateSource type="POOLED">
                <!-- 配置连接数据库的四个基本信息 -->
                <property name="driver" value="com.mysql.jdbc.Driver"></property>
                <property name="url" value="jdbc：mysql：//localhost:3306/eesy_mybatis"></property>
                <property name="username" value="root"></property>
                <property name="passsword" value="123456"></property>
            </dateSource>


<pre><code>    &lt;/environments&gt;
&lt;/environments&gt;
&lt;!-- 使用配置文件实现maybatis数据库操作，指定映射配置文件的位置，映射配置文件指的是每个dao的独立配置文件 --&gt;    
&lt;mappers&gt;
    &lt;mapper resource=&quot;com.itz.dao.UserDao.xml&quot; /&gt;
&lt;/mappers&gt;
或者
&lt;!-- 使用注解实现maybatis数据库操作，移除UserDao.xml，在dao接口方法上使用@select注解，指定sql语句。在mapper中，指定class属性是dao接口的全限定类名 --&gt;    
&lt;mappers&gt;
    &lt;mapper resource=&quot;com.itz.dao.UserDao&quot; /&gt;
&lt;/mappers&gt;</code></pre></environments></environments></configuration>

<p>环境搭建好后</p>
<h4 id="test步骤"><a href="#test步骤" class="headerlink" title="test步骤"></a>test步骤</h4><p>1.读取配置文件<br>    inputStream in=Pesources.getResourceAsStream(“SqlMapConfig.xml”);</p>
<pre><code>2.创建SqlSessionFactory工厂方法
SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();
SqlSEssionFatctory factory=builder.build(in);

3.使用工厂产生SqlSeession对象
SqlSession session= factory.openSession(); 

4.使用SqlSession创建Dao接口的代理对象
UserDao userDao=session.getMapper(UserDao.class);//UserDao是接口，包含未实现方法

5.使用代理对象执行方法
list&lt;User&gt; users=userDao.fandAll();
dor(User user:users) {syste.out.println(user);}//打印所有的user

6.释放资源
session.close();
in.close();</code></pre><p>读取配置文件，准备一个工厂生产一个为我们提供dao实现的对象，有了这个dao就能实现查询数据库等操作。，实现功能，最后释放资源。</p>
<p>mybatis两种数据库访问方式，xml方式和注解方式，见上。</p>
<h4 id="mybatis也可以实现dao实现。"><a href="#mybatis也可以实现dao实现。" class="headerlink" title="mybatis也可以实现dao实现。"></a>mybatis也可以实现dao实现。</h4><p>在test步骤中改变第3,4步，使用工厂创建dao对象<br>UserDao userdao = new UserDaoImpl(factory);<br>去掉session.close();</p>
<pre><code>编写UserDaoImpl类继承UsreDao接口

private SqlSessionFactory factory；

public UserDaoImpl（SqlSessionFactory factory）
｛
    this.factory=factory;
｝

public findAll()
{
    1.使用工厂创建SqlSession对象
    SqlSession session = factory.openSession();
    2.使用session查询所有方法
    List&lt;user&gt; users=session.selectList(satement:&quot;com.itz.dao.UserDao.fandAll&quot;);//需要namespace+id，才能定位要执行的sql语句。
    3.返回查询结果
    return users；

}

例.1
1.读取配置文件
inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//1.读取配置文件时，有相对路径（src.com....），绝对路径(d:mai/it/...),部署后都不能用。2.使用类加载器，他只能读取类路径的配置文件；使用ServletContext对象的getRealPath（）。

2.创建SqlSessionFactory工厂方法
SqlSessionFatoryBuilder builder=new SqlSessionFatoryBuilder();
SqlSEssionFatctory factory=builder.build(in);//创建工厂，Myabtis用了构建者模式，in代表什么呢？？？

3.使用工厂产生SqlSeession对象
SqlSession session= factory.openSession(); //如果用new 实现，每次更换实现方法是都需要改动实现方法名。重新部署，浪费时间。

4.使用SqlSession创建Dao接口的代理对象
UserDao userDao=session.getMapper(UserDao.class);//getmapper代理模式

5.使用代理对象执行方法
list&lt;User&gt; users=userDao.fandAll();
for(User user:users) {syste.out.println(user);}//打印所有的user

6.释放资源
session.close();
in.close();

实现功能只需把上面例.1修改
inputStream in=Pesources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;).session.getMapper(UserDao.class);

list&lt;User&gt; users=userDao.fandAll();
for(User user:users) {syste.out.println(user);}

session.close();
in.close();

例.1的2,3,4,5是为了更灵活的使用满足需求。</code></pre><p><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E7%9A%84%E5%88%86%E6%9E%90.png" alt></p>
<h3 id="自定义Mybatis的分析"><a href="#自定义Mybatis的分析" class="headerlink" title="自定义Mybatis的分析"></a>自定义Mybatis的分析</h3><pre><code>mybatis 使用代理dao的方式增删改查时做了什么？
    1.创建代理对象
    2.在代理对象中调用selectList。</code></pre><p>mybatis执行过程<br><img src="/2020/03/11/Mybatis%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%AE%9A%E4%B9%89Mybatis%E5%88%86%E6%9E%90.png" alt></p>
<h3 id="JDBC是Java提供的一个操作数据库的API；"><a href="#JDBC是Java提供的一个操作数据库的API；" class="headerlink" title="JDBC是Java提供的一个操作数据库的API；"></a>JDBC是Java提供的一个操作数据库的API；</h3><p>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
<p>MyBatis是对JDBC的封装。相对于JDBC，MyBatis有以下优点：</p>
<ol>
<li>优化获取和释放</li>
</ol>
<p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
<p>2.SQL统一管理，对数据库进行存取操作</p>
<p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。</p>
<p>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p>
<p>3.生成动态SQL语句</p>
<p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。</p>
<p>Mybatis可以在配置文件中通过使用<if test="””"></if>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p>
<select id="getCountByInfo" parametertype="User" resulttype="int">
        select count(*) from user
        <where>
            <if test="nickname!=null">
                and nickname = #{nickname} 
            </if>
            <if test="email!=null">
                and email = #{email} 
            </if>
        </where>

</select>

<p>就是通过昵称或email或者二者的组合查找用户数。</p>
<p>4.能够对结果集进行映射</p>
<p>我们在使用JDBC进行查询时，返回一个结果集ResultSet,我们要从结果集中取出结果封装为需要的类型</p>
<p>在Mybatis中我们可以设置将结果直接映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。像上个例子中就是将结果映射为int类型。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>java项目基础知识</title>
    <url>/2020/03/11/java%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>学习项目时<br>构件新项目使用到maven了解类似maven的内容</p>
<p>Maven是一个软件项目管理工具</p>
<p>创建项目时可选择该种模式开发项目，是一种为了开发管理的工具。</p>
<p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>Maven(翻译为”专家”，”内行”)是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。</p>
<p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p>
<p>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p>
<p>1.项目构建<br>项目构建过程包括【清理项目】→【编译项目】→【测试项目】→【生成测试报告】→【打包项目】→【部署项目】这几个步骤，这六个步骤就是一个项目的完整构建过程。</p>
<p>2.依赖管理<br>依赖指的是jar包之间的相互依赖，比如我们搭建一个Struts2的开发框架时，光光有struts2-core-2.3.16.3.jar这个jar包是不行的，struts2-core-2.3.16.3.jar还依赖其它的jar包，依赖管理指的就是使用Maven来管理项目中使用到的jar包，Maven管理的方式就是“自动下载项目所需要的jar包，统一管理jar包之间的依赖关系”。</p>
<p>3.使用Maven的好处<br>　　Maven中使用约定，约定java源代码代码必须放在哪个目录下，编译好的java代码又必须放到哪个目录下，这些目录都有明确的约定。<br>  Maven的每一个动作都拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程<br>　　只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮我们处理其他事情<br>　　使用Maven可以进行项目高度自动化构建，依赖管理(这是使用Maven最大的好处)，仓库管理。</p>
<p>4.Maven项目的目录约定<br>MavenProjectRoot(项目根目录)<br>   |—-src<br>   |     |—-main<br>   |     |         |—-java ——存放项目的.java文件<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |     |—-test<br>   |     |         |—-java ——存放所有测试.java文件，如JUnit测试类<br>   |     |         |—-resources ——存放项目资源文件，如spring, hibernate配置文件<br>   |—-target ——项目输出位置<br>   |—-pom.xml —-用于标识该项目是一个Maven项目</p>
<p>pom.xml文件中的内容如下：</p>
 <?xml version="1.0" encoding="UTF-8"?>
<p>  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 
  http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>      <!--所有的Maven项目都必须配置这四个配置项--><br>      <modelVersion>4.0.0</modelVersion><br>      <!--groupId指的是项目名的项目组，默认就是包名--><br>      <groupId>cn.gacl.maven.hello</groupId><br>     <!--artifactId指的是项目中的某一个模块，默认命名方式是"项目名-模块名"--><br>     <artifactId>hello-first</artifactId><br>     <!--version指的是版本，这里使用的是Maven的快照版本--><br>     <version>SNAPSHOT-0.0.1</version><br> </project></p>
<p>编写好java代码后，使用Maven编译完成之后，在项目根目录下会生成一个target文件夹</p>
<p>在终端使用”mvn clean”命令清除编译结果，也就是把编译生成的target文件夹删掉</p>
<p>Maven中心仓库下载到本地的jar包的默认存放在”${user.home}/.m2/repository”中，${user.home}表示当前登录系统的用户目录(如”C:\Users\gacl”)，我们可以自己设置下载到本地时的jar包的存放目录，在“E:\”目录下创建一个“repository”文件夹，找到apache-maven-3.2.3\conf目录下的settings.xml文件，编辑setting.xml文件在后面加上代码 <localRepository>E:/repository</localRepository></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程</title>
    <url>/2020/03/11/java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<pre><code>runnable 无返回类型 
callable 有返回类型</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>//申请线程池<br>ExecutorServide service = Executors.newFixedCachedPool();//线程受线程池指挥拿取任务<br>ExecutorServide service = Executors.newCacheThreadPool();<br>ScheduleExecutorServide service = Executor.newScheduleThreadPool();//已一定的频率执行线程</p>
<p>//关闭线程池<br>service.shutdown();</p>
<p>WorkStealPool//线程窃取，线程主动去拿任务执行</p>
<p>static class R implentments runnable{ //runnable 任务实现类<br>        int time;</p>
<pre><code>R(int t){

    this.time=t;


}

    public void run (){
            timeUnit.MILLISECONDS.sleep(500);

    }

    system.out.println(time+&quot; &quot;+Thread.currentThread().getName());</code></pre><p>}</p>
<p>service.execute(new R(1000));//开启线程执行runable任务</p>
<h3 id="处理大型数组求和问题"><a href="#处理大型数组求和问题" class="headerlink" title="处理大型数组求和问题"></a>处理大型数组求和问题</h3><p>1.ForkJoinPool方式</p>
<p>public class T1_ForkJoinPool {<br>    static int[]nums= new int[1000000];<br>    static final int MAX_NUM=50000;<br>    static Random r=new Random();</p>
<pre><code>static {
    for(int i=0;i&lt;nums.length;i++) 
    {
        nums[i]=r.nextInt();
    }

    System.out.println(Arrays.stream(nums).sum());//stream api,把数组转化为流

}

static class AddTask extends RecursiveAction{ //继承forkjoin类
    int start,end;

    AddTask(int s,int e) {
        start=s;
        end=e;
    }
    @Override
    protected void compute() {
        if(end-start&lt;=MAX_NUM) 
        {
            long sum = 0L;
            for(int i=start;i&lt;end;i++) sum += nums[i];
            System.out.println(&quot;from:&quot;+start+&quot; to:&quot;+end+&quot;=&quot;+sum);

        }
        else
        {
            int middle=start+(end-start)/2;

            AddTask subTask1=new AddTask(start, middle);
            AddTask subTask2=new AddTask(middle, end);
            subTask1.fork();
            subTask2.fork();

        }

    }




}

public static void main(String[] args) throws IOException {
    ForkJoinPool fjp=new ForkJoinPool();
    AddTask task=new AddTask(0, nums.length);
    fjp.execute(task);

    System.in.read();
}</code></pre><p>}</p>
<p>大多数使用的线程池来自于threadpoolExecutor</p>
<p>//自定义线程池<br>public class threadpoolExecutor｛｝</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java笔记1</title>
    <url>/2020/03/11/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能.</p>
<p>代理模式包含如下角色：</p>
<pre><code>ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。

RealSubject：真实主题角色，是实现抽象主题接口的类。

Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</code></pre><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p>
<p>###静态代理<br>在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类.</p>
<p>代码案例：</p>
<p>复制代码<br>// 接口<br>    interface IStar {<br>        void sing();<br>    }</p>
<pre><code>// 真实对象
class LDHStar implements IStar {
    @Override
    public void sing() {
        System.out.println(&quot;刘德华唱歌&quot;);
    }

}

// 代理类需要有真实对象的控制权 (引用)
class ProxyManger implements IStar {

    // 真实对象的引用
    private IStar star;

    public ProxyManger() {
        super();
    }

    public ProxyManger(IStar star) {
        super();
        this.star = star;
    }

    @Override
    public void sing() {</code></pre><p>　　　　　　System.out.println(“唱歌前准备”);<br>    　　　 star.sing();<br>   　　　　System.out.println(“善后工作”);        }<br>    }<br>class Test{<br>public static void main(String[] args) {<br>            // 创建明星对象<br>            IStar ldh = new LDHStar();<br>            ProxyManger proxy = new ProxyManger(ldh);<br>            proxy.sing();<br>        }<br>}</p>
<p>静态代理总结:<br>优点：<br>可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:<br>因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。</p>
<h4 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect</p>
<p>复制代码<br>//目标类接口<br>interface IDog{<br>    void run();<br>}<br>//目标类<br>class GunDog implements IDog{</p>
<pre><code>@Override
public void run() {
    System.out.println(&quot;猎狗在跑&quot;);
}</code></pre><p>}<br>class DogUtils{<br>    public static void method1() {<br>        System.out.println(“增强方式一”);<br>    }</p>
<pre><code>public static void method2() {
    System.out.println(&quot;增强方式二&quot;);
}</code></pre><p>}<br>class MyInvocationHandle implements InvocationHandler{<br>    private Object target;<br>    public void setTarget(Object target) {<br>        this.target = target;<br>    }<br>    @Override<br>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>            DogUtils.method1();<br>            method.invoke(target, args);<br>            DogUtils.method2();<br>            return null;<br>    }<br>}<br>    //生产代理对象的工厂****<br> class MyProxyFactory{<br>    public static Object getProxy(Object target) {<br>        MyInvocationHandle handle = new MyInvocationHandle();<br>        handle.setTarget(target);<br>        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle);<br>        return proxy;<br>    }<br> }<br>public class ProxyDemo {<br>    public static void main(String[] args) {<br>      IDog dog = new GunDog();<br>      IDog proxy =(IDog) MyProxyFactory.getProxy(dog);<br>      proxy.run();<br>    }</p>
<p>总结：<br>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。</p>
<h4 id="基于接口的动态代理-1"><a href="#基于接口的动态代理-1" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h4><p>动态代理的特点：<br>字节码随用随创建，随用随加载。<br>作用：不更改源码的情况下，对功能加强。<br>分类：<br>    基于接口的动态代理，<br>    基于类的动态代理，</p>
<p>基于接口的动态代理，<br>    涉及的类：proxy，提供者：jdk官方</p>
<p>如何创建代理对象：<br>    使用proxy类的newProxyInstance();<br>创建对象的要求：<br>    被代理类至少实现一个接口，否则不能使用。</p>
<p>newProxyInstance()的参数：<br>    classLoader：类加载器，用于加载代理对象字节码，和被代理对象使用相同类加载器。<br>    class【】数组：用与让代理对象和被代理对象有相同的方法。<br>    InvactionHandler：用于提供增强的代码，如何代理，一般使用匿名内部类</p>
<p>Producer Producer = Proxy.wProxyInstance(producer.getClass().getClassLoader(),<br>                    producer.getClass().getInterfaces(),<br>                    new InvactionHandler(){</p>
<pre><code>    /*该匿名内部类的invoke()作用是：执行该被代理对象的任何接口的方法都经过该方法
        proxy :代理对象的引用
        method：当前执行的方法
         args：当前执行的方法所需的参数

    */
    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{
        //提供增强的代码

    }


}

    )</code></pre><p>####基于子类的动态代理</p>
<p>Cglib代理<br>上面的静态代理和动态代理模式有个相同点就是都要求目标对象是实现一个接口的对象,然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象,</p>
<p>这时就可以使用继承目标类以目标对象子类的方式实现代理,这种方法就叫做:Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>
<p>使用JDK动态代理有一个限制,就是被代理的对象必须实现一个或多个接口,若想代理没有实现接口的类,就需要使用Cglib实现.</p>
<p>由于Cglib是第三方提供的所以使用的时候需要导入相关的jar包<br>cglb<br>asm</p>
<p>代码案例：</p>
<p>复制代码<br>public class CglibProxy {</p>
<pre><code>public static void main(String[] args) {

    int[] arr = new int[100000];
    for (int i = 0; i &lt; arr.length; i++) {
        arr[i] = (int) (Math.random() * 1000);
    }
    //实例化一个增强器，也就是cglib中的一个class generator
    Enhancer enhancer = new Enhancer();
    //设置目标类
    enhancer.setSuperclass(ArraySort2.class);
    //设置拦截对象，这里直接使用匿名内部类写法
    enhancer.setCallback(new MethodInterceptor() {
        @Override
        public Object intercept(Object object , Method method, Object[] args, MethodProxy proxy) throws Throwable {
            String sortName = method.getName();
            switch (sortName) {
            case &quot;bubbleSort&quot;:
                sortName = &quot;冒泡排序&quot;;
                break;
            case &quot;selectSort&quot;:
                sortName = &quot;选择排序&quot;;
                break;
            case &quot;quickSort&quot;:
                sortName = &quot;快速排序&quot;;
                break;
            default:
                break;
            }
            long start = System.currentTimeMillis();
            //此处一定要使用proxy的invokeSuper方法来调用目标类的方法
            proxy.invokeSuper(object, args);
            long end = System.currentTimeMillis();
            System.out.println(&quot;本次&quot; + sortName + &quot;的执行时间为: &quot; + (end -start) + &quot;ms&quot;);
            return null;
        }

    });
    //生成代理类并返回一个实例
    ArraySort2 arraySort = (ArraySort2) enhancer.create();
    arraySort.bubbleSort(arr);
    arraySort.selectSort(arr);
    arraySort.quickSort(arr);
}</code></pre><p>}<br>class ArraySort2{<br>    public void quickSort(int[] arr) {<br>        Arrays.sort(arr);<br>    }<br>    public void selectSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            for (int j = i+1; j &lt; arr.length; j++) {<br>                if (arr[i] &gt; arr[j]) {<br>                    int temp = 0;<br>                    temp = arr[i];<br>                    arr[i] = arr[j];<br>                    arr[j] = temp;<br>                }<br>            }<br>        }<br>    }<br>    public void bubbleSort(int[] arr) {<br>        for (int i = 0; i &lt; arr.length - 1; i++) {<br>            for (int j = 0; j &lt; arr.length - 1 - i; j++) {<br>                if (arr[j] &gt; arr[j + 1]) {<br>                    int temp = 0;<br>                    temp = arr[j];<br>                    arr[j] = arr[j + 1];<br>                    arr[j + 1] = temp;<br>                }<br>            }<br>        }<br>    }<br>}</p>
<p>基于子类的动态代理<br>    涉及的类：Enhancer，提供者：第三方Cglib</p>
<p>如何创建代理对象：<br>    使用Enhancer类的create方法;<br>创建对象的要求：<br>    被代理类不能是最终类。</p>
<p>create()的参数：<br>    class：用于指定被代理对象字节码。<br>    callback：用于提供增强的代码，如何代理，一般使用callbac的子类接口方法MethodInterceptor()</p>
<p>Enhancer.create(producer.getClass(),new MethodInterceptor(){</p>
<pre><code> /*该匿名内部类的intercept(()作用是：执行该被代理对象的任何接口的方法都经过该方法
                    proxy :代理对象的引用
                    method：当前执行的方法
                     args：当前执行的方法所需的参数

                */
public Object intercept(Object proxy,Method method,Object[] args) throws Throwable    </code></pre><p>}<br>)</p>
<h3 id="Java虚拟机类加载机制"><a href="#Java虚拟机类加载机制" class="headerlink" title="Java虚拟机类加载机制"></a>Java虚拟机类加载机制</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的</p>
<p><img src="/2020/03/11/java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD.ng" alt></p>
<p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。</p>
<p>加载<br>通过全限定类名来获取定义此类的二进制字节流。<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。<br>验证<br>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。<br>此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。<br>元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。<br>第二阶段，保证不存在不符合 Java 语言规范的元数据信息。<br>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。<br>符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。<br>可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p>准备<br>为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>解析<br>虚拟机将常量池内的符号引用替换为直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<p>初始化<br>到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 <clinit>() 方法的过程。</clinit></p>
<p><clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <init>() ,<clinit>() 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 <clinit>()，虚拟机会保证在子类的 <clinit>() 方法执行之前，父类的 <clinit>() 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></clinit></clinit></clinit></init></clinit></p>
<p><clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法。</clinit></clinit></p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法，其他线程都需要阻塞等待，直到活动线程执行 <clinit>() 方法完毕。</clinit></clinit></clinit></p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<p>遇到new、getstatic 和 putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应场景是：使用 new 实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。<br>对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。（而一个接口在初始化时，并不要求其父接口全部都完成了初始化）<br>虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），<br>虚拟机会先初始化这个主类。<br>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>第5种情况，我暂时看不懂。</p>
<p>以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</p>
<p>通过子类引用父类的静态字段，不会导致子类初始化。<br>通过数组定义来引用类，不会触发此类的初始化。MyClass[] cs = new MyClass[10];<br>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p>
<p>将 class 文件二进制数据放入方法区内，然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。</p>
<p>目前类加载器却在类层次划分、OSGi、热部署、代码加密等领域非常重要，我们运行任何一个 Java 程序都会涉及到类加载器。</p>
<h4 id="类的唯一性和类加载器"><a href="#类的唯一性和类加载器" class="headerlink" title="类的唯一性和类加载器"></a>类的唯一性和类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。</p>
<p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。<br>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、 isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
<p>Bootstrap 类加载器是用 C++ 实现的，是虚拟机自身的一部分，如果获取它的对象，将会返回 null；扩展类加载器和应用类加载器是独立于虚拟机外部，为 Java 语言实现的，均继承自抽象类 java.lang.ClassLoader ，开发者可直接使用这两个类加载器。</p>
<p>Application 类加载器对象可以由 ClassLoader.getSystemClassLoader() 方法的返回，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>双亲委派模型对于保证 Java 程序的稳定运作很重要，例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</p>
<h4 id="自定义类加载器分为两步："><a href="#自定义类加载器分为两步：" class="headerlink" title="自定义类加载器分为两步："></a>自定义类加载器分为两步：</h4><p>继承 java.lang.ClassLoader<br>重写父类的 findClass() 方法<br>针对第 1 步，为什么要继承 ClassLoader 这个抽象类，而不继承 AppClassLoader 呢？<br>因为它和 ExtClassLoader 都是 Launcher 的静态内部类，其访问权限是缺省的包访问权限。<br>static class AppClassLoader extends URLClassLoader{…}</p>
<p>第 2 步，JDK 的 loadCalss() 方法在所有父类加载器无法加载的时候，会调用本身的 findClass() 方法来进行类加载，因此我们只需重写 findClass() 方法找到类的二进制数据即可。</p>
<p>下面我自定义了一个简单的类加载器，并加载一个简单的类。</p>
<p>首先是需要被加载的简单类：</p>
<p>// 存放于D盘根目录<br>public class Test {</p>
<pre><code>public static void main(String[] args) {
    System.out.println(&quot;Test类已成功加载运行！&quot;);
    ClassLoader classLoader = Test.class.getClassLoader();
    System.out.println(&quot;加载我的classLoader：&quot; + classLoader);
    System.out.println(&quot;classLoader.parent：&quot; + classLoader.getParent());
}</code></pre><p>}<br>并使用 javac -encoding utf8 Test.java 编译成 Test.class 文件。</p>
<p>类加载器代码如下：</p>
<p>import java.io.*;</p>
<p>public class MyClassLoader extends ClassLoader {<br>    @Override<br>    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br>        // 加载D盘根目录下指定类名的class<br>        String clzDir = “D:\“ + File.separatorChar<br>                + name.replace(‘.’, File.separatorChar) + “.class”;<br>        byte[] classData = getClassData(clzDir);</p>
<pre><code>    if (classData == null) {
        throw new ClassNotFoundException();
    } else {
        return defineClass(name, classData, 0, classData.length);
    }
}

private byte[] getClassData(String path) {
    try (InputStream ins = new FileInputStream(path);
         ByteArrayOutputStream baos = new ByteArrayOutputStream()
    ) {

        int bufferSize = 4096;
        byte[] buffer = new byte[bufferSize];
        int bytesNumRead = 0;
        while ((bytesNumRead = ins.read(buffer)) != -1) {
            baos.write(buffer, 0, bytesNumRead);
        }
        return baos.toByteArray();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return null;
}</code></pre><p>}<br>使用类加载器加载调用 Test 类：</p>
<p>public class MyClassLoaderTest {<br>    public static void main(String[] args) throws Exception {<br>        // 指定类加载器加载调用<br>        MyClassLoader classLoader = new MyClassLoader();<br>        classLoader.loadClass(“Test”).getMethod(“test”).invoke(null);<br>    }<br>}<br>输出信息：</p>
<p>Copy<br>Test.test()已成功加载运行！<br>加载我的classLoader：class MyClassLoader<br>classLoader.parent：class sun.misc.Launcher$AppClassLoader</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础（下）</title>
    <url>/2020/03/11/git%E5%AD%A6%E4%B9%A02-0/</url>
    <content><![CDATA[<p>本地仓库使用如下命令初始化：</p>
<p>$ git init<br>之后使用如下命令添加远程库：</p>
<p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:hahah/ftpmanage.git<br>然后使用</p>
<p>$ git push -u origin master<br>出现如下错误：</p>
<p>error: src refspec master does not match any.<br>error: failed to push some refs to ‘git@github.com:hahaha/ftpmanage.git’<br>原因：</p>
<p>本地仓库为空</p>
<p>解决方法：使用如下命令 添加文件；</p>
<p>$ git add add.php </p>
<p>$ git commit -m “init files”</p>
<p>$ git pull origin master</p>
<p>远程上传成功！</p>
<h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p>
<p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p>
<p>创建分支命令：</p>
<p>git branch (branchname)</p>
<p>切换分支命令:</p>
<p>git checkout (branchname)</p>
<p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>
<p>合并分支命令:</p>
<p>git merge </p>
<p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p>
<p>开始前我们先创建一个测试目录：</p>
<p>$ mkdir gitdemo<br>$ cd gitdemo/<br>$ git init<br>Initialized empty Git repository…<br>$ touch README<br>$ git add README<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) 3b58100] 第一次版本提交<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README</p>
<h3 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h3><pre><code> 列出分支
列出分支基本命令：</code></pre><p>git branch<br>没有参数时，git branch 会列出你在本地的分支。</p>
<p>$ git branch</p>
<ul>
<li>master<br>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</li>
</ul>
<p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p>
<p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。</p>
<p>$ git branch testing<br>$ git branch</p>
<ul>
<li>master<br>testing<br>现在我们可以看到，有了一个新分支 testing。</li>
</ul>
<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>
<p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p>
<p>$ ls<br>README<br>$ echo ‘runoob.com’ &gt; test.txt<br>$ git add .<br>$ git commit -m ‘add test.txt’<br>[master 3e92c19] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>$ ls<br>README        test.txt<br>$ git checkout testing<br>Switched to branch ‘testing’<br>$ ls<br>README<br>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<p>$ git checkout -b newtest<br>Switched to a new branch ‘newtest’<br>$ git rm test.txt<br>rm ‘test.txt’<br>$ ls<br>README<br>$ touch runoob.php<br>$ git add .<br>$ git commit -am ‘removed test.txt、add runoob.php’<br>[newtest c1501a2] removed test.txt、add runoob.php<br> 2 files changed, 1 deletion(-)<br> create mode 100644 runoob.php<br> delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>
<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<p>删除分支<br>删除分支命令：</p>
<p>git branch -d (branchname)<br>例如我们要删除 testing 分支：</p>
<p>$ git branch</p>
<ul>
<li>master<br>testing<br>$ git branch -d testing<br>Deleted branch testing (was 85fc7e7).<br>$ git branch</li>
<li>master<br>分支合并<br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</li>
</ul>
<p>git merge<br>$ git branch</p>
<ul>
<li>master<br>newtest<br>$ ls<br>README        test.txt<br>$ git merge newtest<br>Updating 3e92c19..c1501a2<br>Fast-forward<br>runoob.php | 0<br>test.txt   | 1 -<br>2 files changed, 1 deletion(-)<br>create mode 100644 runoob.php<br>delete mode 100644 test.txt<br>$ ls<br>README        runoob.php<br>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</li>
</ul>
<p>合并完后就可以删除分支:</p>
<p>$ git branch -d newtest<br>Deleted branch newtest (was c1501a2).<br>删除后， 就只剩下 master 分支了：</p>
<p>$ git branch</p>
<ul>
<li>master</li>
</ul>
<p>合并冲突<br>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>
<p>$ git branch</p>
<ul>
<li>master<br>$ cat runoob.php<br>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</li>
</ul>
<?php
echo 'runoob';
?>
<p>创建 change_site 分支：</p>
<p>$ git checkout -b change_site<br>Switched to a new branch ‘change_site’<br>$ vim runoob.php<br>$ head -3 runoob.php<br><?php
echo 'runoob';
?><br>$ git commit -am ‘changed the runoob.php’<br>[change_site 7774248] changed the runoob.php<br> 1 file changed, 3 insertions(+)</p>
<p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>$ cat runoob.php<br>$ vim runoob.php    # 修改内容如下<br>$ cat runoob.php<br><?php
echo 1;
?><br>$ git diff<br>diff –git a/runoob.php b/runoob.php<br>index e69de29..ac60739 100644<br>— a/runoob.php<br>+++ b/runoob.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo 1;
+?><br>$ git commit -am ‘修改代码’<br>[master c68142b] 修改代码<br> 1 file changed, 3 insertions(+)<br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p>
<p>$ git merge change_site<br>Auto-merging runoob.php<br>CONFLICT (content): Merge conflict in runoob.php<br>Automatic merge failed; fix conflicts and then commit the result.</p>
<p>$ cat runoob.php     # 代开文件，看到冲突内容<br>&lt;?php<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>echo 1;<br>=======<br>echo ‘runoob’;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>change_site<br>?&gt;<br>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>$ vim runoob.php<br>$ cat runoob.php<br><?php
echo 1;
echo 'runoob';
?><br>$ git diff<br>diff –cc runoob.php<br>index ac60739,b63d7d7..0000000<br>— a/runoob.php<br>+++ b/runoob.php<br>@@@ -1,3 -1,3 +1,4 @@@<br>  &lt;?php<br> +echo 1;</p>
<ul>
<li>echo ‘runoob’;<br>?&gt;<br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</li>
</ul>
<p>$ git status -s<br>UU runoob.php<br>$ git add runoob.php<br>$ git status -s<br>M  runoob.php<br>$ git commit<br>[master 88afe0e] Merge branch ‘change_site’<br>现在我们成功解决了合并中的冲突，并提交了结果。</p>
<p>##Git 查看提交历史<br>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p>
<p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p>
<p>$ git log<br>commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)<br>Merge: c68142b 7774248<br>Author: runoob <a href="mailto:&#116;&#101;&#115;&#x74;&#x40;&#x72;&#117;&#110;&#x6f;&#x6f;&#98;&#46;&#99;&#111;&#x6d;">&#116;&#101;&#115;&#x74;&#x40;&#x72;&#117;&#110;&#x6f;&#x6f;&#98;&#46;&#99;&#111;&#x6d;</a><br>Date:   Fri May 3 15:55:58 2019 +0800</p>
<pre><code>Merge branch &apos;change_site&apos;</code></pre><p>commit c68142b562c260c3071754623b08e2657b4c6d5b<br>Author: runoob <a href="mailto:&#116;&#x65;&#115;&#116;&#64;&#114;&#117;&#110;&#111;&#111;&#98;&#x2e;&#x63;&#111;&#109;">&#116;&#x65;&#115;&#116;&#64;&#114;&#117;&#110;&#111;&#111;&#98;&#x2e;&#x63;&#111;&#109;</a><br>Date:   Fri May 3 15:52:12 2019 +0800</p>
<pre><code>修改代码</code></pre><p>commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)<br>Author: runoob <a href="mailto:&#x74;&#101;&#x73;&#116;&#x40;&#x72;&#x75;&#x6e;&#111;&#x6f;&#x62;&#x2e;&#99;&#111;&#109;">&#x74;&#101;&#x73;&#116;&#x40;&#x72;&#x75;&#x6e;&#111;&#x6f;&#x62;&#x2e;&#99;&#111;&#109;</a><br>Date:   Fri May 3 15:49:26 2019 +0800</p>
<pre><code>changed the runoob.php</code></pre><p>commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00<br>Author: runoob <a href="mailto:&#x74;&#101;&#115;&#116;&#64;&#114;&#x75;&#110;&#x6f;&#x6f;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#101;&#115;&#116;&#64;&#114;&#x75;&#110;&#x6f;&#x6f;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a><br>Date:   Fri May 3 15:35:32 2019 +0800<br>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p>
<p>$ git log –oneline<br>$ git log –oneline<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>c68142b 修改代码<br>7774248 (change_site) changed the runoob.php<br>c1501a2 removed test.txt、add runoob.php<br>3e92c19 add test.txt<br>3b58100 第一次版本提交<br>这告诉我们的是，此项目的开发历史。</p>
<p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add runoob.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 第一次版本提交<br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</li>
</ul>
<p>你也可以用 –reverse 参数来逆向显示所有日志。</p>
<p>$ git log –reverse –oneline<br>3b58100 第一次版本提交<br>3e92c19 add test.txt<br>c1501a2 removed test.txt、add runoob.php<br>7774248 (change_site) changed the runoob.php<br>c68142b 修改代码<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>
<p>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in<br>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p>
<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p>
<p>$ git log –oneline –before={3.weeks.ago} –after={2010-04-18} –no-merges<br>5469e2d Git 1.7.1-rc2<br>d43427d Documentation/remote-helpers: Fix typos and improve language<br>272a36b Fixup: Second argument may be any arbitrary string<br>b6c8d2d Documentation/remote-helpers: Add invocation section<br>5ce4f4e Documentation/urls: Rewrite to accomodate transport::address<br>00b84e9 Documentation/remote-helpers: Rewrite description<br>03aa87e Documentation: Describe other situations where -z affects git diff<br>77bc694 rebase-interactive: silence warning when no commits rewritten<br>636db2c t3301: add tests to use –format=”%N”</p>
<p>Git 标签<br>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p>
<p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p>
<p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p>
<p>$ git tag -a v1.0<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add runoob.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 第一次版本提交<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li>
</ul>
<p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p>
<p>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the runoob.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add runoob.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 (tag: v0.9) 第一次版本提交<br>如果我们要查看所有标签可以使用以下命令：</li>
</ul>
<p>$ git tag<br>v0.9<br>v1.0<br>指定标签信息命令：</p>
<p>git tag -a <tagname> -m “runoob.com标签”<br>PGP签名标签命令：</tagname></p>
<p>git tag -s <tagname> -m “runoob.com标签”</tagname></p>
<p>Git 远程仓库(Github)<br>Git 并不像 SVN 那样有个中心服务器。</p>
<p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p>
<p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 Github 简明教程。</p>
<p>添加远程库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p>
<p>git remote add [shortname] [url]<br>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com/注册。" target="_blank" rel="noopener">https://github.com/注册。</a></p>
<p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p>
<p>使用以下命令生成 SSH Key：</p>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“<br>后面的 <a href="mailto:your_email@youremail.com">your_email@youremail.com</a> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。</p>
<p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p>
<p>左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p>
<p>添加成功后界面如下所示</p>
<p>为了验证是否成功，输入以下命令：</p>
<p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Hi tianqixin! You’ve successfully authenticated, but GitHub does not provide shell access.<br>以下命令说明我们已成功连上 Github。</p>
<p>之后登录后点击” New repository “ 如下图所示：</p>
<p>之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p>创建成功后，显示如下信息：</p>
<p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p>
<p>$ mkdir runoob-git-test                     # 创建测试目录<br>$ cd runoob-git-test/                       # 进入测试目录<br>$ echo “# 菜鸟教程 Git 测试” &gt;&gt; README.md     # 创建 README.md 文件并写入内容<br>$ ls                                        # 查看目录下的文件<br>README<br>$ git init                                  # 初始化<br>$ git add README.md                         # 添加文件<br>$ git commit -m “添加 README.md 文件”        # 提交并备注信息<br>[master (root-commit) 0205aab] 添加 README.md 文件<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p>
<h1 id="提交到-Github"><a href="#提交到-Github" class="headerlink" title="提交到 Github"></a>提交到 Github</h1><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git<br>$ git push -u origin master<br>以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。</p>
<p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p>
<p>查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p>
<p>git remote<br>实例<br>$ git remote<br>origin<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p>
<p>提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p>
<p>1、从远程仓库下载新分支与数据：</p>
<p>git fetch<br>该命令执行完后需要执行git merge 远程分支到你所在的分支。</p>
<p>2、从远端仓库提取数据并尝试合并到当前分支：</p>
<p>git merge<br>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p>
<p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p>
<p>接下来我们在 Github 上点击” README.md” 并在线修改它:</p>
<p>然后我们在本地更新修改。</p>
<p>$ git fetch origin<br>remote: Counting objects: 3, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>From github.com:tianqixin/runoob-git-test<br>   0205aab..febd8ed  master     -&gt; origin/master<br>以上信息”0205aab..febd8ed master -&gt; origin/master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p>
<p>$ git merge origin/master<br>Updating 0205aab..febd8ed<br>Fast-forward<br> README.md | 1 +<br> 1 file changed, 1 insertion(+)<br>查看 README.md 文件内容：</p>
<p>$ cat README.md </p>
<h1 id="菜鸟教程-Git-测试"><a href="#菜鸟教程-Git-测试" class="headerlink" title="菜鸟教程 Git 测试"></a>菜鸟教程 Git 测试</h1><h2 id="第一次修改内容"><a href="#第一次修改内容" class="headerlink" title="第一次修改内容"></a>第一次修改内容</h2><p>推送到远程仓库<br>推送你的新分支与数据到某个远端仓库命令:</p>
<p>git push [alias] [branch]<br>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p>
<p>$ touch runoob-test.txt      # 添加文件<br>$ git add runoob-test.txt<br>$ git commit -m “添加到远程”<br>master 69e702d] 添加到远程<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 runoob-test.txt</p>
<p>$ git push origin master    # 推送到 Github<br>重新回到我们的 Github 仓库，可以看到文件以及提交上来了：</p>
<p>删除远程仓库<br>删除远程仓库你可以使用命令：</p>
<p>git remote rm [别名]<br>实例<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p>
<h1 id="添加仓库-origin2"><a href="#添加仓库-origin2" class="headerlink" title="添加仓库 origin2"></a>添加仓库 origin2</h1><p>$ git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git</p>
<p>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p>
<h1 id="删除仓库-origin2"><a href="#删除仓库-origin2" class="headerlink" title="删除仓库 origin2"></a>删除仓库 origin2</h1><p>$ git remote rm origin2<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/runoob-git-test.git (push)</p>
<p>##Git 服务器搭建<br>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p>
<p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p>
<p>接下来我们将以 Centos 为例搭建 Git 服务器。</p>
<p>1、安装Git<br>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>$ yum install git<br>接下来我们 创建一个git用户组和用户，用来运行git服务：</p>
<p>$ groupadd git<br>$ useradd git -g git<br>2、创建证书登录<br>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<p>如果没有该文件创建它：</p>
<p>$ cd /home/git/<br>$ mkdir .ssh<br>$ chmod 755 .ssh<br>$ touch .ssh/authorized_keys<br>$ chmod 644 .ssh/authorized_keys<br>3、初始化Git仓库<br>首先我们选定一个目录作为Git仓库，假定是/home/gitrepo/runoob.git，在/home/gitrepo目录下输入命令：</p>
<p>$ cd /home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo/<br>$ cd gitrepo</p>
<p>$ git init –bare runoob.git<br>Initialized empty Git repository in /home/gitrepo/runoob.git/<br>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p>
<p>$ chown -R git:git runoob.git<br>4、克隆仓库<br>$ git clone <a href="mailto:git@192.168.45.4">git@192.168.45.4</a>:/home/gitrepo/runoob.git<br>Cloning into ‘runoob’…<br>warning: You appear to have cloned an empty repository.<br>Checking connectivity… done.<br>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git基础（上）</title>
    <url>/2020/03/11/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h2><p>Git 是一个开源的分布式版本控制系统，<br>                                用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<h4 id="Git与SVN区别"><a href="#Git与SVN区别" class="headerlink" title="Git与SVN区别"></a>Git与SVN区别</h4><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p>
<p>Git 与 SVN 区别点：</p>
<pre><code>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。

2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。

3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。

4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。

5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</code></pre><p><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/001.jpg" alt></p>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>本章节我们将为大家介绍 Git 的工作流程。</p>
<p>一般工作流程如下：</p>
<pre><code>克隆 Git 资源作为工作目录。
在克隆的资源上添加或修改文件。
如果其他人修改了，你可以更新资源。
在提交前查看修改。
提交修改。
在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</code></pre><p><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/002.png" alt></p>
<h2 id="Git工作区、暂存区和版本库"><a href="#Git工作区、暂存区和版本库" class="headerlink" title="Git工作区、暂存区和版本库"></a>Git工作区、暂存区和版本库</h2><p>基本概念</p>
<p>我们先来理解下Git 工作区、暂存区和版本库概念</p>
<p>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：<br><img src="/2020/03/11/git%E5%AD%A6%E4%B9%A0/003.jpg" alt></p>
<h2 id="git创建仓库"><a href="#git创建仓库" class="headerlink" title="git创建仓库"></a>git创建仓库</h2><p>git init<br>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p>
<p>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>
<p>使用方法<br>使用当前目录作为Git仓库，我们只需使它初始化。</p>
<p>git init<br>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为Git仓库 。/////</p>
<p>git init newrepo<br>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<p>$ git add *.c<br>$ git add README<br>$ git commit -m ‘初始化项目版本’<br>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<p>git clone //常用<br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p>
<p>克隆仓库的命令格式为：</p>
<p>git clone <repo><br>如果我们需要克隆到指定的目录，可以使用以下命令格式：</repo></p>
<p>git clone <repo> <directory><br>参数说明：</directory></repo></p>
<p>repo:Git 仓库。<br>directory:本地目录。<br>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<p>$ git clone git://github.com/schacon/grit.git<br>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：<br>$ git clone git://github.com/schacon/grit.git mygrit</p>
<h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><p>获取与创建项目命令<br>git init<br>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p>
<p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 runoob 项目：</p>
<p>$ mkdir runoob<br>$ cd runoob/<br>$ git init<br>Initialized empty Git repository in /Users/tianqixin/www/runoob/.git/</p>
<h1 id="在-www-runoob-git-目录初始化空-Git-仓库完毕。"><a href="#在-www-runoob-git-目录初始化空-Git-仓库完毕。" class="headerlink" title="在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。"></a>在 /www/runoob/.git/ 目录初始化空 Git 仓库完毕。</h1><p>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p>
<p>ls -a<br>.    ..    .git<br>git clone<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p>
<p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p>
<p> git clone [url]<br>[url] 为你想要复制的项目，就可以了。</p>
<p>例如我们克隆 Github 上的项目：</p>
<p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:schacon/simplegit.git<br>Cloning into ‘simplegit’…<br>remote: Counting objects: 13, done.<br>remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13<br>Receiving objects: 100% (13/13), done.<br>Resolving deltas: 100% (2/2), done.<br>Checking connectivity… done.<br>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p>
<p>$ cd simplegit/<br>$ ls<br>README   Rakefile lib<br>上述操作将复制该项目的全部记录。</p>
<p>$ ls -a<br>.        ..       .git     README   Rakefile lib<br>$ cd .git<br>$ ls<br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p>
<hr>
<p>基本快照<br>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。</p>
<p>git status</p>
<p>$ touch README<br>$ touch hello.php<br>$ ls<br>README        hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$<br>/////git status 命令用于查看项目的当前状态。/////</p>
<p>接下来我们执行 git add 命令来添加文件：</p>
<p>$ git add README hello.php<br>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p>
<p>$ git status -s<br>A  README<br>A  hello.php<br>$<br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。</p>
<p>现在我们修改 README 文件：</p>
<p>$ vim README<br>在 README 添加以下内容：# Runoob Git 测试，然后保存退出。</p>
<p>再执行一下 git status：</p>
<p>$ git status -s<br>AM README<br>A  hello.php<br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 git add 命令将其添加到缓存中：</p>
<p>$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p>
<p>git status<br>//////git status 以查看在你上次提交之后是否有修改。//////</p>
<p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p>
<p>$ git status<br>On branch master</p>
<p>Initial commit</p>
<p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</file></p>
<pre><code>new file:   README
new file:   hello.php</code></pre><p>git diff<br>执行 git diff 来查看执行 git status 的结果的详细信息。</p>
<p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p>
<p>尚未缓存的改动：git diff<br>查看已缓存的改动： git diff –cached<br>查看已缓存的与未缓存的所有改动：git diff HEAD<br>显示摘要而非整个 diff：git diff –stat<br>在 hello.php 文件中输入以下内容：</p>
<?php
echo '菜鸟教程：www.runoob.com';
?>
<p>$ git status -s<br>A  README<br>AM hello.php</p>
<p>$ git diff<br>diff –git a/hello.php b/hello.php<br>index e69de29..69b5711 100644<br>— a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo '菜鸟教程：www.runoob.com';
+?></p>
<p>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p>
<p>接下来我们来查看下 git diff –cached 的执行效果：</p>
<p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff –cached<br>diff –git a/README b/README<br>new file mode 100644<br>index 0000000..8f87495<br>— /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+# Runoob Git 测试<br>diff –git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..69b5711<br>— /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo '菜鸟教程：www.runoob.com';
+?></p>
<p>git commit<br>////使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。/////</p>
<p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p>
<p>$ git config –global user.name ‘runoob’<br>$ git config –global user.email <a href="mailto:test@runoob.com">test@runoob.com</a><br>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p>
<p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) d32cf1f] 第一次版本提交<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php</p>
<p>现在我们已经记录了快照。如果我们再执行 git status:</p>
<p>$ git status</p>
<h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><p>nothing to commit (working directory clean)<br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。</p>
<p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p>
<h1 id="Please-enter-the-commit-message-for-your-changes-Lines-starting"><a href="#Please-enter-the-commit-message-for-your-changes-Lines-starting" class="headerlink" title="Please enter the commit message for your changes. Lines starting"></a>Please enter the commit message for your changes. Lines starting</h1><h1 id="with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit"><a href="#with-‘-’-will-be-ignored-and-an-empty-message-aborts-the-commit" class="headerlink" title="with ‘#’ will be ignored, and an empty message aborts the commit."></a>with ‘#’ will be ignored, and an empty message aborts the commit.</h1><h1 id="On-branch-master-1"><a href="#On-branch-master-1" class="headerlink" title="On branch master"></a>On branch master</h1><h1 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</file></h1><p>#</p>
<h1 id="modified-hello-php"><a href="#modified-hello-php" class="headerlink" title="modified:   hello.php"></a>modified:   hello.php</h1><p>#<br>~<br>~<br>“.git/COMMIT_EDITMSG” 9L, 257C<br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>
<p>git commit -a<br>我们先修改 hello.php 文件为以下内容：</p>
<?php
echo '菜鸟教程：www.runoob.com';
echo '菜鸟教程：www.runoob.com';
?>
<p>再执行以下命令：</p>
<p>git commit -am ‘修改 hello.php 文件’<br>[master 71ee2cb] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)</p>
<p>git reset HEAD<br>git reset HEAD 命令用于取消已缓存的内容。</p>
<p>我们先改动文件 README 文件，内容如下：</p>
<h1 id="Runoob-Git-测试"><a href="#Runoob-Git-测试" class="headerlink" title="Runoob Git 测试"></a>Runoob Git 测试</h1><h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p>hello.php 文件修改为：</p>
<?php
echo '菜鸟教程：www.runoob.com';
echo '菜鸟教程：www.runoob.com';
echo '菜鸟教程：www.runoob.com';
?>
<p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p>
<p>$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.php<br>$ git reset HEAD hello.php<br>Unstaged changes after reset:<br>M    hello.php<br>$ git status -s<br>M  README<br> M hello.php<br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p>
<p>$ git commit -m ‘修改’<br>[master f50cfda] 修改<br> 1 file changed, 1 insertion(+)<br>$ git status -s<br> M hello.php<br>可以看到 hello.php 文件的修改并未提交。</p>
<p>这时我们可以使用以下命令将 hello.php 的修改提交：</p>
<p>$ git commit -am ‘修改 hello.php 文件’<br>[master 760f74d] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>$ git status<br>On branch master<br>nothing to commit, working directory clean</p>
<p>/////简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。////</p>
<p>git rm<br>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作<br>git rm <file></file></p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f<br>git rm -f <file></file></p>
<p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可<br>git rm –cached <file></file></p>
<p>如我们删除 hello.php文件：</p>
<p>$ git rm hello.php<br>rm ‘hello.php’<br>$ ls<br>README</p>
<p>不从工作区中删除文件：<br>$ git rm –cached README<br>rm ‘README’<br>$ ls<br>README</p>
<p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：<br>git rm –r * </p>
<p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。<br>git mv<br>git mv 命令用于移动或重命名一个文件、目录、软连接。</p>
<p>我们先把刚移除的 README 添加回来：</p>
<p>$ git add README<br>然后对其重名:</p>
<p>$ git mv README  README.md<br>$ ls<br>README.md</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树（c版本）</title>
    <url>/2020/03/11/c%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>btree.h  //二叉树头文件，用于声明数据类型和相关函数</p>
<pre><code>#ifndef __BTREE_H__
#define __BTREE_H__

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef char dataype_bt;  //声明二叉树中存放的数据类型，便于后续更改

typedef struct btreenode{   //二叉树的节点结构：存放的数据 该节点的左子节点地址及右子节点地址。注意和单链表的区别，二叉树是非线性存储，单链表是线性存储
    dataype_bt data;
    struct btreenode *lchild,*rchild;
}btree_node,*btree_pnode;

extern btree_pnode create_btree1(void);    //通过递归方法创建一个二叉树
extern void create_btree(btree_pnode *T);  //通过递归方法创建一个二叉树（功能同上）
extern void pre_order(btree_pnode t);    //采用递归方法先序遍历
extern void unpre_order(btree_pnode t);  //采用非递归方法先序遍历
extern void mid_order(btree_pnode t);    //采用递归方法中序遍历
extern void post_order(btree_pnode t);   //采用递归方法后序遍历
extern void level_order(btree_pnode t);  //层次遍历
extern void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t);   //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述
#endif




btree.c  //二叉树相关函数的实现方法

#include &quot;btree.h&quot;
#include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲
#include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲

btree_pnode create_btree1(void)        //通过递归方法创建一个二叉树
{
    dataype_bt ch;
    btree_pnode new;
    scanf(&quot;%c&quot;,&amp;ch);
    if(&apos;#&apos;==ch)
    {
        return NULL;
    }
    else
    {
        //创建根结点
        new=(btree_pnode)malloc(sizeof(btree_node));
        if(NULL==new)
        {
            perror(&quot;malloc&quot;);
            exit(-1);
        }
        new-&gt;data=ch;
        //用相同方法创建左子数
        new-&gt;lchild=create_btree1();
        //用相同方法创建右子数
        new-&gt;rchild=create_btree1();
    }
    return new;
}

void create_btree(btree_pnode *T)          //通过递归方法创建一个二叉树（功能同上）
{
    dataype_bt ch;
    scanf(&quot;%c&quot;,&amp;ch);
    if(&apos;#&apos;==ch)
    {
        return ;
    }
    else{
        //创建根结点
        (*T)=(btree_pnode)malloc(sizeof(btree_node));
        if(NULL==(*T))
        {
            perror(&quot;malloc&quot;);
            exit(-1);
        }
        (*T)-&gt;data=ch;
        //用相同方法创建左子数
        create_btree(&amp;((*T)-&gt;lchild));
        //用相同方法创建右子数
        create_btree(&amp;((*T)-&gt;rchild));
    }
}

void pre_order(btree_pnode t)          //采用递归方法先序遍历
{
    if(t!=NULL)
    {
        //访问根结点
        printf(&quot;%c&quot;,t-&gt;data);
        //先序遍历左子树
        pre_order(t-&gt;lchild);
        //先序遍历右子树
        pre_order(t-&gt;rchild);
    }
}

void unpre_order(btree_pnode t)          //采用非递归方法先序遍历
{
    linklist top;//top为指向栈顶结点的指针

    top=stack_create();//初始化链式栈
    /*
        该函数包含的头文件 和 实现方法如下：
        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲
        linklist stack_create()
        {
            linklist s;

            if((s=(linklist)malloc(sizeof(listnode)))==NULL){
                puts(&quot;malloc failed&quot;);
                return NULL;
            }
            s-&gt;next=NULL;

            return s;
        }
    */
    while(t!=NULL || !(stack_empty(top))){
        /*
            该函数包含的头文件 和 实现方法如下：
            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲
            int stack_empty(linklist s)  //判断栈是否为空（1表示空，0表示非空）
            {
                return (s-&gt;next==NULL ? 1:0);
            }
        */
        if(t!=NULL){
            printf(&quot;%c&quot;,t-&gt;data);
            if(t-&gt;rchild !=NULL)
                stack_push(top,t-&gt;rchild);  //入栈
            /*
                该函数包含的头文件 和 实现方法如下：
                #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲
                int stack_push(linklist s,datatype_ls value)  //入栈
                {
                    linklist p;
                    if((p=(linklist)malloc(sizeof(listnode)))==NULL)
                    {
                        puts(&quot;malloc failed&quot;);
                        return -1;
                    }

                    p-&gt;data = value;
                    p-&gt;next=s-&gt;next;
                    s-&gt;next = p;

                    return 0;
                }
            */
            t=t-&gt;lchild;
        }else
            t=stack_pop(top);   //出栈
        /*
            该函数包含的头文件 和 实现方法如下：
            #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲
            datatype_ls stack_pop(linklist s)    //出栈
            {
                linklist p;
                datatype_ls ret;

                p=s-&gt;next;
                s-&gt;next=p-&gt;next;
                ret=p-&gt;data;

                free(p);
                p=NULL;

                return ret;
            }
        */
    }

    stack_free(top);   //释放栈
    /*
        该函数包含的头文件 和 实现方法如下：
        #include &quot;linkstack.h&quot;   //链式栈的头文件，关于链式栈的相关函数实现方法请查看博主相关链式栈的文章，这里不做细讲
        void stack_free(linklist s)    //释放栈
        {
            linklist p;

            printf(&quot;free:&quot;);
            p=s;
            while(p)
            {
                s=s-&gt;next;
                printf(&quot;%d &quot;,p-&gt;data);
                free(p);
                p=s;
            }
            putchar(10);    //10 表示 回车符（&apos;\n&apos;）

        }
    */
}

void mid_order(btree_pnode t)           //采用递归方法中序遍历
{
    if(t!=NULL)
    {
        //中序遍历左子树
        mid_order(t-&gt;lchild);
        //访问根结点
        printf(&quot;%c&quot;,t-&gt;data);
        //中序遍历右子树
        mid_order(t-&gt;rchild);
    }
}

void post_order(btree_pnode t)          //采用递归方法后序遍历
{
    if(t!=NULL)
    {
        //后序遍历左子树
        post_order(t-&gt;lchild);
        //后序遍历右子树
        post_order(t-&gt;rchild);
        //访问根结点
        printf(&quot;%c&quot;,t-&gt;data);
    }
}

void level_order(btree_pnode t)        //层次遍历
{
    link_pqueue q;
    init_linkqueue(&amp;q);//初始化链式队列
    /*
        该函数包含的头文件 和 实现方法如下：
        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲
        void init_linkqueue(link_pqueue *Q)     //创建队列
        {
            //申请front和rear的空间
            *Q=(link_pqueue)malloc(sizeof(link_queue));
            if((*Q)==NULL)
            {
                perror(&quot;malloc&quot;);
                exit(-1);
            }
            //申请头结点空间
            (*Q)-&gt;front=(linkqueue_pnode)malloc(sizeof(linkqueue_node));
            if((*Q)-&gt;front==NULL)
            {
                perror(&quot;malloc&quot;);
                exit(-1) ;
            }

            (*Q)-&gt;front-&gt;next=NULL;
            (*Q)-&gt;rear=(*Q)-&gt;front;

            return;
        }
    */

    while(t!=NULL)
    {
        //访问t指向的结点数据
        printf(&quot;%c&quot;,t-&gt;data);
        //当t的左指针不为空，则入队
        if(t-&gt;lchild!=NULL)
            in_linkqueue(t-&gt;lchild,q);
        /*
            该函数包含的头文件 和 实现方法如下：
            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲
            bool in_linkqueue(datatype data,link_pqueue q)   //入队
            {
                linkqueue_pnode  new;

                //申请数据结点空间
                new=(linkqueue_pnode)malloc(sizeof(linkqueue_node));
                if(new==NULL)
                {
                    puts(&quot;入队失败！&quot;);
                    return false;
                }
                //将数据存储在申请的空间
                new-&gt;data=data;

                //将new指向的结点插入到链式队列中
                new-&gt;next=q-&gt;rear-&gt;next;            //这里等价于new-&gt;next = NULL;
                q-&gt;rear-&gt;next=new;         

                //让rear指针指向新的队尾结点
                q-&gt;rear=q-&gt;rear-&gt;next;          //等价于q-&gt;rear = new;

                return true;
            }
        */
        //当t的右指针不为空，则入队
        if(t-&gt;rchild!=NULL)
            in_linkqueue(t-&gt;rchild,q);
        //队列不为空，则出队
        if(!is_empty_linkqueue(q))
            out_linkqueue(q,&amp;t);
        /*
            该函数包含的头文件 和 实现方法如下：
            #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲
            bool out_linkqueue(link_pqueue q,datatype *D)      //出队
            {
                linkqueue_pnode t;
                //判断队列是否空
                if(is_empty_linkqueue(q)){
                    printf(&quot;队列已空!\n&quot;);
                    return false;
                }

                //出队
                t=q-&gt;front;
                q-&gt;front =q-&gt;front-&gt;next;
                *D=q-&gt;front-&gt;data;
                free(t);

                return true;
            }
        */
        else
            break;
    }
    free_linkqueue(q);           //释放队列
    /*
        该函数包含的头文件 和 实现方法如下：
        #include &quot;linkqueue.h&quot;   //链式队列的头文件，关于链式队列的相关函数实现方法请查看博主相关链式队列的文章，这里不做细讲
        void free_linkqueue(link_pqueue q)           //释放队列
        {
            link_pqueue p;
            p = q-&gt;front;
            while(p)
            {
                q-&gt;front = q-&gt;front-&gt;next;
                free(p);
                p = q-&gt;front;
            }
            free(q);
        }
    */
}

void travel(char const *str,void (*pfun)(btree_pnode),btree_pnode t)      //将上面的函数作为参数传入该函数（函数的回调），实现二叉树的创建 和 遍历，其中参数str可以是回调函数的功能描述
{
    printf(&quot;%s&quot;,str);
    pfun(t);
    puts(&quot;&quot;);
}</code></pre><p>————————————————<br>版权声明：本文为CS80960356DN博主「许新天」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39148042/article/details/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39148042/article/details/</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/2020/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to my Chanal, This is my very first post. </p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="博客初体验"><a href="#博客初体验" class="headerlink" title="博客初体验"></a>博客初体验</h3><h4 id="new-blog-new-life"><a href="#new-blog-new-life" class="headerlink" title="new blog,new life"></a>new blog,new life</h4>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点（供考试）</title>
    <url>/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BE%9B%E8%80%83%E8%AF%95%EF%BC%89/</url>
    <content><![CDATA[<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>计算机网络的分类：</p>
<pre><code>按分布范围：
    1）广域网WAN
    2）城域网MAN（大多使用以太网技术，也可以成为局域网）
    3）局域网LAN
    4)个人区域网PAN（）

按传输技术：
    1）广播式网络（共享通信信道，发送报文所有人都能接收到）
    2）点对点网络（一对计算机通信）

按交换技术分：（交换技术指的是通信设备和主机之间交换信息所采用的数据格式，交换装置的方式）
    1）电路交换网络（在源节点与目标节点间建立一条专用的通信链路用来传输数据，该链路可以使虚拟的）
    2）报文交换网络（也称存储转发，将数据封装成报文，存储转发，每个报文单独选择到达目的地的路径）
    3）分组交换网络（也称包交换，将数据分成较短固定长度的数据块，把报文分块？以存储转发方式传输）

等;</code></pre><p>计算机网络性能指标：</p>
<pre><code>带宽：本来表示通信线路允许通过的信号频带范围，单位赫兹Hz。在计算机网络中，
    表示网络的通信线路传送数据的能力，即传送的最高数据率，单位b/s。

时延：数据从一端传输到另一端所需要的时间。
    发送时延：节点将分组的所有比特传输到链路上的时间。
        发送时延=分组长度/信道宽度
    传播时延：一个比特从链路的一端到另一端的所需时间。
        传播时延=信道长度/电磁波在信道传播的速率
    处理时延：数据在存储转发时处理的所需时间。
    排队时延：分组进入路由器在队列中等待处理的时间。

时延带宽积：发送端连续发送数据，当发送的第一个比特即将到达终点时，发送端已经发送出的数据数。
    时延带宽积=传播时延*信道带宽

往返时延：发送端发送数据，到发送端接收到接收端的确认，总共经过的时延。

吞吐量：单位时间内，通过某个网络的数据量。吞吐量受网络的带宽和额定速率限制。

速率：计算机网络中主机在数字信道上传送数据的速率。单位为b/s</code></pre><p>计算机网络中接口定义：同一节点中，相邻两层交换信息的接触点。</p>
<p>服务的定义：下层为紧邻的上层提供的功能调用。</p>
<p>计算机网络的服务：</p>
<pre><code>1）面向连接和面向无连接服务
    面向连接：通信前双方必须建立连接结束后释放连接。
    无连接：不需要现建立连接，尽最大努力交付，得不可靠传输。
2）可靠传输与不可靠传输
3）有应答服务和无应答服务
    有应答，接收方接收到数据向发送方给出相应的应答。</code></pre><p>码元：一个固定时长的信号波形，表示一位k进制数，代表不同离散数值的基本波形是数字信号的计量单位。</p>
<p>码元速率：单位时间传输的码元个数，码元速率与进制无关，单位波特每秒</p>
<p>信息传输速率：单位时间传输的二进制码元个数，单位比特每秒</p>
<p>码元传输速率与信息传输速率有一定关系：<br>    一个码元携带n bit 信息量（一个码元可表示一个k进制数，码元携带的是k进制在物理层需要的位数）<br>    m baud 的码元传输速率=m * n 的信息传输速率</p>
<p>电路交换，报文交换和分组交换<br>    1）电路交换：两个节点之间不许先建立一条专用的物理通信路径。传输期间一直被占用。<br>                三个阶段：连接建立，数据传输，连接释放<br>                优势：通信时延小，有序传输，没有冲突，适用范围广，实时性强，控制简单。</p>
<pre><code>2）报文交换：交换的单位是报文，报文携带目标地址等信息。采用存储转发机制。
            优点：无需建立连接，动态分配路线，提高线路可靠性，提高线路利用性，提供多目标服务。
3）分组交换：把大的报文进行分组，再加上必要的控制信息，节点接受的分组后，展示保存下来并排队等待传输。
            优点：无建立时延，线路利用率高，加速传输</code></pre><p>数据报与虚电路（分组交换的两种形式）<br>    分组交换很具器通信子网向端点系统提供服务，进一步可分为面向连接的虚电路方式和无连接的数据报形式，这两种服务都是网络层提供的。</p>
<pre><code>数据报:使用端系统的协议把报文拆成若干带有序号的数据单元形成数据报分组。

虚电路：把数据报方式与电路交换结合起来。分组发送以前，要求发送方与接收方建立一条逻辑上相连的电路，并且一点连接建立，虚电路所对应的物理路径也就确立了。
虚电路方式建立虚电路时，要选择一个没用过的虚电路号给该虚电路连接。虚电路网络中每个节点都维护一张虚电路表。</code></pre><p>物理层设备<br>    中继器：又称转发器，将信号整形放大在转发出去。<br>    集线器：多端口中继器，没有冲突检测。</p>
<p>数据链路层：为网络层服务，加强物理层功能，将物理层提供的可能出错的物理连接，改为无差错的数据链路，使之在网络层表现为无差错的数据链路。<br>    为网络层提供的服务：<br>                    1）无确认的无连接服务，发送数据帧不需要建立链路连接，目标接收到帧也不需要回应。<br>                    2）有确认的无连接服务。<br>                    3）有确认的面向连接服务。<br>    透明传输：不管什么样的数据都能在链路上传输，比如，某些内容中的数据与帧的标志相同需要做一些处理是指能传输。</p>
<p>组帧：帧定界，帧同步，透明传输等。</p>
<p>编码技术实现差错控制：<br>                1）自动重传请求 ARQ<br>                2)前向纠错 FEC</p>
<p>常见的检错编码:<br>            1)奇偶校验码<br>            2）循环允余码<br>流量控制：由接收方控制发送方的发送数据的速率。<br>    1）停止等待流量协议<br>    2）滑动窗口协议：滑动，每次把目标整体向后移动一位，窗口，指目标整体</p>
<p>可靠传输：<br>    自动重传分为三种：<br>        1）停等式<br>        2）后退N帧<br>        3）选择性重传</p>
<p>单帧滑动窗口停等协议：<br>接收方每收到一个帧都回应确认</p>
<p>多帧滑动窗口后退N帧协议：<br>不需要逐帧确认，确认一个，便确认了这个前面所有的。</p>
<p>多帧滑动窗口选择重传协议：只重传出现差错的数据帧和计时器潮湿的数据帧，这是接收窗口必须加大。</p>
<p>介质访问控制：为使用介质的每一个节点隔离来自同一个信道上其他节点传送的信号。</p>
<pre><code>常用的介质访问控制方法：
    1）信道划分
    2）随机划分
    3）轮询访问：令牌传递协议

信道划分：
    频分复用
    时分复用
    码分复用
    波分复用
随机访问介质访问控制：
    ALOHA:纯ALOHA发送无确认，等待重传；时隙ALOHA：把各站的时间同步起来
    CSMA：1-坚持CSMA：当侦听到信道忙时，继续侦听信道；非坚持CSMA：侦听到信道忙即放弃侦听；p-坚持CSMA，以概率P发送数据。
    CSMA/CD:冲突检测，先听后发，边听边发，冲突停发，随机重发
    CSMA/CS：碰撞避免</code></pre><p>计算机与局域网连接使用网络适配器即网卡，每个网卡都有一个唯一标志即MAC（介质控制访问）地址</p>
<p>令牌环网：令牌帧循环传递，有主机要发送数据时，当前令牌无其他数据，传递到该主机，该主机拿下令牌附加数据，传出去继续循环传递，传到目标主机，目标主机确认后，复制该数据，不做其他改动，令牌帧继续传递，传到发送主机，主机收回数据，令牌帧重新工作。</p>
<p> 广域网数据链路层控制协议：<br>     ppp协议：使用串行线路通信的面向字节的协议。<br>         三个组成部分：<br>                     1）链路控制协议LCP<br>                     2）网络控制协议NCP<br>                     3）一个将IP数据包封装到串行链路的方法</p>
<p>网桥：数据链路层设备，连接多个网段。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h4><p>静态路由和动态路由<br>    路由器转发分组是通过路由表转发的。静态理由手动设置，动态路由自动生成</p>
<pre><code>距离-向量路由算法：所有的节点都定期将它们的整个路由选择表传给所有与之直接连接的节点（相邻的节点）。
    路由表包含，每条路径的目的地（另一个节点），路径的代价（也称距离），常用的如RIP。
链路状态路由算法：主动测试所有的邻接节点的状态。定期将链路状态传递给其他节点。</code></pre><p>层次路由：网络增大，太多路由器不合适大型网络。<br>        内部网关协议：区域内的通信。<br>        外部网关协议：多区域的通信。</p>
<h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>ip数据报分片：链路层能承载的最大数据量成为u最大传输单元MTU，因为IP数据报封装在链路层数据报中，链路层严格限制ip数据包的长度。IP数据报长度大于链路层传输长度时，需要分片。<br>MF 标志是否是最后一个片，DF标志是否是分片，一个标志位表分片的报文。</p>
<p>NAT 网络地址转换 将专有网络地址转换为公有网络地址。</p>
<p>地址划分：子网划分，子网掩码，CIDR无分类编址<br>子网划分：不改变原有类型的网络，借用若干个主机号作为子网号。<br>CIDR消除传统的ABC类网络地址划分，使用网络前缀和主机号来划分地址。这个网络前缀号相同的ip地址称作罗路由聚合或者超网。</p>
<p>组播仅用于UDP<br>IGMP因特网组管理协议，通知本地网络的路由器要接收发送某一个组播组的分组。<br>ip组播地址使用D类地址<br>    两种形式：1）局域网内硬件组播<br>            2）因特组播<br>            组播地址=48位以太网mac地址=qian16位mac地址+32组播地址=前16为mac地址+5位组播地址+23mac地址<br>IGMP工作方式：<br>    1）某个主机加入新组播组时，该主机想组播组的组播地址发送IGMP报文，声明自己是成员。本地路由器收到后，将消息转发给因特网上其他组播路由器。<br>    2）本地组播路由器周期性探寻本地局域网的主机一边知道是否是组播组的成员。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层提供应用进程之间的逻辑通信。<br>网络层提供主机之间的通信。</p>
<p>复用：发送方不同的应用程序否可以使用一个传输层协议传送数据。<br>分用：接收方的传输层能剥去报文的首部后正确交付到目的进程。</p>
<p>传输层通过端口与应用层实现交付。通过端口号区分不同应用进程</p>
<p>端口只具有本地意义，分为两类：<br>    1）服务端使用端口<br>    2）客户端使用端口<br>在网络中通过采用接收方和发送方的 套接字组合 来识别端点。<br>所谓 套接字 就是一个通信端点。<br>    套接字=（ip地址，端口号）<br>它唯一的表示了网络中某个主机的某一个应用。</p>
<p>UDP数据报首部长度时固定的8b；</p>
<p>tcp时在不可靠的ip层之上实现的可靠数据传输协议<br>tcp面向连接，面向字节流<br>tcp的可靠传输如何保证？<br>1序号 确认，tcp连接传输的数据流每一个字节都编上序号，确认时总是确认收到的下一个报文段的数据的第一个字节的序号<br>2.重传</p>
<pre><code>------------------ 2020.4.13</code></pre>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计2.0</title>
    <url>/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/</url>
    <content><![CDATA[<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%8C%BA%E5%88%AB.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%8C%BA%E5%88%AB.jpg" alt></p>
<h3 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h3><p>列表循秩访问成本比向量循秩访问高</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E5%88%97%E8%A1%A8%E5%BE%AA%E7%A7%A9%E8%AE%BF%E9%97%AE%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6.jpg" alt></p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%8F%92%E5%85%A5.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%9F%BA%E4%BA%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9E%84%E9%80%A0.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%88%A0%E9%99%A4.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9E%90%E6%9E%84.jpg" alt></p>
<p>使元素唯一化<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96.jpg" alt></p>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E5%94%AF%E4%B8%80%E5%8C%96%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE.jpg" alt></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E4%B8%8E%E5%86%92%E6%B3%A1.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg" alt></p>
<p>1.比较要插入的数，确定位置<br>2.把该位置前所有元素向前挪一位<br>3.把元素插入该位置</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.jpg" alt></p>
<p>线性代数中的排列的逆序数：<br>  逆序数在插入算法中的作用，用逆序数来表示要转移的次数<br>  线性代数中的逆序数是用来确定行列式的值的正负号的。<br>  两者可能没什么关联。</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%86%E5%BA%8F%E5%AF%B9.jpg" alt><br>算法复杂度：最坏复杂度：n平方<br>           最好复杂度：n</p>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%9B%BE.jpg" alt><br>栈：后进先出 LIFO</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%8E%A5%E5%8F%A3.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E5%9C%BA%E5%90%88.jpg" alt></p>
<p>####进制转换</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E5%BA%94%E7%94%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%9E%84%E6%80%9D.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E6%9E%84%E6%80%9D%E4%BB%A3%E7%A0%81.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%9B%BE%E8%A7%A3.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97.jpg" alt></p>
<p>栈混洗的序列不唯一</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E7%94%84%E5%88%AB.jpg" alt></p>
<p>任何一个数如i，进栈后想要第一个出栈，原队列的i之前的数都得先进栈。<br>解释为什么不能出现 顺序：312</p>
<p>在栈内，pop一个元素后，在pop出一个元素必然是该栈内顶上的元素或者要入栈队列的第一个元素。<br>所以再一次pop的元素是剩下的队列的所有元素之一及栈顶元素。<br>栈顶元素下的栈内元素是不可动的。</p>
<p>栈的出栈也表先出先后顺序，嵌套顺序</p>
<p>栈混洗成功的充分必要条件</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E7%9A%84%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%88%E6%B7%B7%E6%B4%97%E4%B8%8E%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.jpg" alt><br>n个数的栈混洗有多少种，n对括号能成的表达式就有多少种。</p>
<h4 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%B8%8E%E9%82%A3%E7%AE%97%E7%AC%A6%E5%A4%84%E7%90%86.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%89%AB%E6%8F%8F%E4%B8%BB%E7%AE%97%E6%B3%95.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E7%AE%97%E6%9C%AF%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8.jpg" alt></p>
<p>逆波兰表达式RPN</p>
<p>将中缀表达式转换为RPN,可以使用间的的栈进出来实现中缀表达式的问题。</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/RPN%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" alt><br>中缀转RPN,操作数的顺序不会变</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E6%A0%B9%E6%A0%91.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%9C%89%E5%BA%8F%E6%A0%91.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E8%B7%AF%E5%BE%84.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E8%BF%9E%E9%80%9A.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B7%B1%E5%BA%A6.jpg" alt></p>
<p>父节点表示法<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E7%88%B6%E8%8A%82%E7%82%B9.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E7%88%B6%E4%BA%B2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%95%BF%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA.jpg" alt></p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E6%8F%8F%E8%BF%B0%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt></p>
<p>任何树都可以由二叉树实现<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E9%95%BF%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF%E7%B1%BB.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%AE%9E%E7%8E%B0.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%AE%9E%E7%8E%B0.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6%E6%9B%B4%E6%96%B0.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5.jpg" alt></p>
<p>为什么遍历可以一个不漏的全部访问并且只有一次？<br>不论是访问左子树，还是右子树，遍历时我们访问时可以把左子树看成一个整体，以先序遍历为例，遍历了根节点，遍历左子树，相当于把左子树的细节屏蔽，透明访问了左子树，在透明访问右子树，所以不会出现没有访问，或者顺序出错问题。</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%861.jpg" alt><br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%861%E5%9B%BE%E7%A4%BA.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%862%E6%80%9D%E8%B7%AF.jpg" alt><br>以先序遍历为例：<br>由图可知，节点遍历时总是先遍历左侧，不断访问左子树的左节点，直至没有左节点，不断回溯找到一个右节点，再重复不断访问左子树的左节点，不断循环。<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%862%E6%80%9D%E8%B7%AF2.jpg" alt><br>方法实施：自顶而下，依次遍历左侧的节点，然后自底向上的访问右子树。</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%862%E4%BB%A3%E7%A0%81.jpg" alt><br>    实现遍历左侧节点</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%862%E6%80%9D%E8%B7%AF.jpg" alt><br>    实现不断从栈中弹出一个右子树，并调用以实现代码进行左侧遍历</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%862%E6%BC%94%E7%A4%BA.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF.jpg" alt><br>按照这个思路，把该思路划分阶段，可以按左侧链的节点划分，每个节点是一个阶段。</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E7%BB%86%E8%8A%82.jpg" alt><br>把左侧链上的节点一次入栈</p>
<p>层次遍历：</p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%85%88%E5%BA%8F.jpg" alt><br>由中序遍历的根节点可以确定先序遍历的左子树和右子树<br><img src="/2020/03/06/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A12-0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E5%92%8C%E5%85%88%E5%BA%8F.jpg" alt><br>同理</p>
<p>==========</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络编程</title>
    <url>/2020/02/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2020/02/25/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%A5%97%E6%8E%A5%E5%AD%97.jpg" alt></p>
<h4 id="套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。"><a href="#套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。" class="headerlink" title="套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。"></a>套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。</h4><p>｛    流套接字：用于提供面向连接、可靠的数据传输服务。<br>    数据报套接字：提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传    输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。<br>    原始套接字(SOCKET_RAW)：允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。<br> ｝</p>
<h4 id="套接字基本函数："><a href="#套接字基本函数：" class="headerlink" title="套接字基本函数："></a>套接字基本函数：</h4><pre><code> 创建套接字：int socket(int family, int type, intprotocol);
         个人理解创建socket的过程其实就是一个获得文件描述符的过程，当然这个过程会是比较复杂的。可以从内核中找到创建socket的代码，并且socket的创建和其他的listen，bind等操作分离开来。socket函数完成正确的操作是返回值大于0的文件描述符，当返回小于0的值时，操作错误。同样是返回一个文件描述符，但是会因为三个参数组合不同，对于数据具体的工作流程不同，对于应用层编程来说，这些也是不可见的。

         socket有三个参数，family代表一个协议族，比较熟知的就是AF_INET，PF_PACKET等；第二个参数是协议类型，常见类型是SOCK_STREAM,SOCK_DGRAM, SOCK_RAW, SOCK_PACKET等；第三个参数是具体的协议，对于标准套接字来说，其值是0，对于原始套接字来说就是具体的协议值。


 套接字绑定函数： intbind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
         功能介绍：bind函数主要应用于服务器模式一端，其主要的功能是将addrlen长度 structsockaddr类型的myaddr地址与sockfd文件描述符绑定到一起，在sockaddr中主要包含服务器端的协议族类型，网络地址和端口号等。在客户端模式中不需要使用bind函数。当bind函数返回0时，为正确绑定，返回-1，则为绑定失败。

         bind函数的第一个参数sockfd是在创建socket套接字时返回的文件描述符。
         bind函数的第二个参数是structsockaddr类型的数据结构，由于structsockaddr数据结构类型不方便设置，所以通常会通过对tructsockaddr_in进行地质结构设置，然后进行强制类型转换成structsockaddr类型的数据。

 监听函数：int listen(int sockfd, int backlog);
        功能介绍：listen的操作就是当有较多的client发起connect时，server端不能及时的处理已经建立的连接，这时就会将connect连接放在等待队列中缓存起来。这个等待队列的长度有listen中的backlog参数来设定。listen和accept函数是服务器模式特有的函数，客户端不需要这个函数。当listen运行成功时，返回0；运行失败时，返回值位-1.

        参数说明：sockfd是前面socket创建的文件描述符;backlog是指server端可以缓存连接的最大个数，也就是等待队列的长度。

请求接收函数：int accept(int sockfd, structsockaddr *client_addr, socklen_t *len);
        功能介绍：接受函数accept其实并不是真正的接受，而是客户端向服务器端监听端口发起的连接。对于TCP来说，accept从阻塞状态返回的时候，已经完成了三次握手的操作。Accept其实是取了一个已经处于connected状态的连接，然后把对方的协议族，网络地址以及端口都存在了client_addr中，返回一个用于操作的新的文件描述符，该文件描述符表示客户端与服务器端的连接，通过对该文件描述符操作，可以向client端发送和接收数据。同时之前socket创建的sockfd，则继续监听有没有新的连接到达本地端口。返回大于0的文件描述符则表示accept成功，否则失败。

        参数说明：sockfd是socket创建的文件描述符；client_addr是本地服务器端的一个structsockaddr类型的变量，用于存放新连接的协议族，网络地址以及端口号等；第三个参数len是第二个参数所指内容的长度，对于TCP来说其值可以用sizeof(structsockaddr_in)来计算大小，说要说明的是accept的第三个参数要是指针的形式，因为这个值是要传给协议栈使用的。

客户端请求连接函数： intconnect(int sock_fd, struct sockaddr *serv_addr,int addrlen);
        功能介绍：连接函数connect是属于client端的操作函数，其目的是向服务器端发送连接请求，这也是从客户端发起TCP三次握手请求的开始，服务器端的协议族，网络地址以及端口都会填充到connect函数的serv_addr地址当中。当connect返回0时说明已经connect成功，返回值是-1时，表示connect失败。

        参数说明：connect的第一个参数是socket创建的文件描述符；第二个参数是一个structsockaddr类型的指针，这个参数中设置的是要连接的目标服务器的协议族，网络地址以及端口号；第三个参数表示第二个参数内容的大小，与accept不同，这个值不是一个指针。</code></pre><p> 在服务器端和客户端建立连接之后是进行数据间的发送和接收，主要使用的接收函数是recv和read，发送函数是send和write。因为对于socket套接字来说，最终实际操作的是文件描述符，所以可以使用对文件进行操作的接收和发送函数对socket套接字进行操作。read和write函数是文件编程里的知识，所以这里不再做多与的赘述。</p>
<h5 id="简单连接服务器代码："><a href="#简单连接服务器代码：" class="headerlink" title="简单连接服务器代码："></a>简单连接服务器代码：</h5><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;

#define PORT 3399
#define SIZE 1024

int createSocket(){//返回一个内核的socket码

    int listen_socket=socket(AF_INET,SOCK_STREAM,0);
    if(listen_socket==-1){
        perror(&quot;socket&quot;);
        return -1;
    }

    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;  /* Internet地址族 */
    addr.sin_port = htons(PORT);  /* 端口号 */
    addr.sin_addr.s_addr = htonl(INADDR_ANY);   /* IP地址 */

    int ref=intbind(listen_socket,(struct sockaddr *)&amp;addr,sizeof(addr));
    if(ref==1){
        perror(&quot;bind&quot;);
        return -1;
    }

    ref=listen(listen_socket,5);//放置等待队列，并非接收用户请求
    if(ref == -1){
        perror(&quot;listen&quot;);
        return -1;
    }

    return listen_socket;

}

void listenWait_socket(int socket_id){
    struct sockaddr_in cliaddr;
    int addrlen = sizeof(cliaddr);
    printf(&quot;等待客户端连接。。。。\n&quot;);

    int client_socket=accept(socket_id,(struct sockaddr *)&amp;cliaddr, &amp;addrlen);
    if(client_socket == -1)
    {
        perror(&quot;accept&quot;);
        return -1;
    }
    return client_socket;


}

void handle_socket(int listen_socket, int client_socket){
    char buf[SIZE];
    while(1)
    {
        int ret = read(client_socket, buf, SIZE-1);
        if(ret == -1)
        {
            perror(&quot;read&quot;);
            break;
        }
        if(ret == 0)
        {
            break;
        }
        buf[ret]=&quot;\0&quot;;
        for(i = 0; i &lt; ret; i++)
        {
            buf[i] = buf[i] + &apos;A&apos; - &apos;a&apos;;
        }

        printf(&quot;%s\n&quot;, buf);
        write(client_socket, buf, ret);
        if(strncmp(buf, &quot;end&quot;, 3) == 0)
        {
            break;
        }
    }
    close(client_socket);

    }





}



int main(){

    int socket_listen=createSocket();
    int socket_client=listenWait_socket(socket_listen);
    hanld_client(socket_listen, socket_client);
      close(listen_socket);

    return 0;

}</code></pre><h5 id="多线程并发服务器代码："><a href="#多线程并发服务器代码：" class="headerlink" title="多线程并发服务器代码："></a>多线程并发服务器代码：</h5><pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;

#define PORT 9990
#define SIZE 1024

int Creat_socket()         //创建套接字和初始化以及监听函数
{
    int listen_socket = socket(AF_INET, SOCK_STREAM, 0);      //创建一个负责监听的套接字  
    if(listen_socket == -1)
    {
        perror(&quot;socket&quot;);
        return -1;
    }
    struct sockaddr_in addr;
    memset(&amp;addr, 0, sizeof(addr));

    addr.sin_family = AF_INET;  /* Internet地址族 */
    addr.sin_port = htons(PORT);  /* 端口号 */
    addr.sin_addr.s_addr = htonl(INADDR_ANY);   /* IP地址 */

    int ret = bind(listen_socket, (struct sockaddr *)&amp;addr, sizeof(addr));    //连接
    if(ret == -1)
    {
        perror(&quot;bind&quot;);
        return -1;
    }

    ret = listen(listen_socket, 5);   //监听
    if(ret == -1)
    {
        perror(&quot;listen&quot;);
        return -1;
    }
    return listen_socket;
}

int wait_client(int listen_socket)
{
    struct sockaddr_in cliaddr;
    int addrlen = sizeof(cliaddr);
    printf(&quot;等待客户端连接。。。。\n&quot;);
    int client_socket = accept(listen_socket, (struct sockaddr *)&amp;cliaddr, &amp;addrlen);     //创建一个和客户端交流的套接字
    if(client_socket == -1)
    {
        perror(&quot;accept&quot;);
        return -1;
    }

    printf(&quot;成功接收到一个客户端：%s\n&quot;, inet_ntoa(cliaddr.sin_addr));

    return client_socket;
}

void hanld_client(int listen_socket, int client_socket)    //信息处理函数,功能是将客户端传过来的小写字母转化为大写字母
{
    char buf[SIZE];
    while(1)
    {
        int ret = read(client_socket, buf, SIZE-1);
        if(ret == -1)
        {
            perror(&quot;read&quot;);
            break;
        }
        if(ret == 0)
        {
            break;
        }
        buf[ret] = &apos;\0&apos;;
        int i;
        for(i = 0; i &lt; ret; i++)
        {
            buf[i] = buf[i] + &apos;A&apos; - &apos;a&apos;;
        }

        printf(&quot;%s\n&quot;, buf);
        write(client_socket, buf, ret);

        if(strncmp(buf, &quot;end&quot;, 3) == 0)
        {
            break;
        }
    }
    close(client_socket);
}

void handler(int sig)
{

    while (waitpid(-1,  NULL,   WNOHANG) &gt; 0)
    {
        printf (&quot;成功处理一个子进程的退出\n&quot;);
    }
}

int main()
{
    int listen_socket = Creat_socket();


    signal(SIGCHLD,  handler);    //处理子进程，防止僵尸进程的产生
    while(1)
    {
        int client_socket = wait_client(listen_socket);   //多进程服务器，可以创建子进程来处理，父进程负责监听。
        int pid = fork();
        if(pid == -1)
        {
            perror(&quot;fork&quot;);
            break;
        }
        if(pid &gt; 0)
        {
            close(client_socket);
            continue;
        }
        if(pid == 0)
        {
            close(listen_socket);
            hanld_client(listen_socket, client_socket);
            break;
        }
    }

    close(listen_socket);

    return 0;

｝</code></pre>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络2.0</title>
    <url>/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/</url>
    <content><![CDATA[<hr>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="病毒与木马"><a href="#病毒与木马" class="headerlink" title="病毒与木马"></a>病毒与木马</h4><p>灰鸽子木马 控制中病毒的用户电脑</p>
<h4 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h4><pre><code>对称加密 效率高，秘钥相同。

非对称密钥：加密秘钥与解密秘钥不同，效率低。
    解密方法：公钥加密，私钥解密
            私钥加密，公钥解密

非对称密钥的制作：
            一串随机数-&gt;使用函数分成-&gt;一对私钥和公钥

公钥可以在网上传，私钥要保留好
效率高的方法：用私钥加密对称密钥</code></pre><p>加密算法标准DES<br>    属于分组密码</p>
<p>DES 加密步骤：将文件分组，一组一组进行加密。将加密后的每一组合并成新的文件。<br>DES算法公开取决于秘钥长度。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>作用：防止抵赖，防止更改</p>
<p><img src="/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png" alt><br>发送给别人后，别人同样的方法，将文件单向散列后，用公钥解密，如果摘要一样，文件没有被修改。</p>
<p>证书颁发机构CA<br>作用：防止使用不合法的公钥私钥。确保为企业颁发证书，确认身份真实，用户需要信任CA机构。</p>
<p>打开认证单元：        cmd-&gt;mmc-&gt;添加管理单元</p>
<h4 id="Internet安全协议"><a href="#Internet安全协议" class="headerlink" title="Internet安全协议"></a>Internet安全协议</h4><p>ssl 安全套接字 在应用层和传输层之间，在传输层之前给应用层加密</p>
<p>功能：服务器鉴别<br>      客户端鉴别<br>      加密ssl会话</p>
<h4 id="网络层安全-IPsec"><a href="#网络层安全-IPsec" class="headerlink" title="网络层安全 IPsec"></a>网络层安全 IPsec</h4><p><img src="/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%9B%BE.jpg" alt></p>
<p>SA是构成IPsec的基础，是连个通信实体协商建立的协议（利用IKE协议）<br><img src="/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/SA.jpg" alt></p>
<p>AH 签名协议不加密<br>ESP 签名加密协议<br><img src="/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/AH.jpg" alt><br><img src="/2020/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2.0/ESP.jpg" alt><br>可以在本地安全策略配置</p>
<h4 id="数据链路层安全"><a href="#数据链路层安全" class="headerlink" title="数据链路层安全"></a>数据链路层安全</h4><p>ppp 身份验证协议</p>
<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>一种特殊编程的路由</p>
<p>类型： 网络层防火墙<br>      应用层防火墙</p>
<h4 id="internet上的音频"><a href="#internet上的音频" class="headerlink" title="internet上的音频"></a>internet上的音频</h4><p>流媒体服务<br>    录播<br>    直播</p>
<p>！整体组网考虑网络速度很关键</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计1.0</title>
    <url>/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<hr>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><h6 id="来自清华大学邓骏辉课程"><a href="#来自清华大学邓骏辉课程" class="headerlink" title="来自清华大学邓骏辉课程"></a>来自清华大学邓骏辉课程</h6><h4 id="图灵机介绍："><a href="#图灵机介绍：" class="headerlink" title="图灵机介绍："></a>图灵机介绍：</h4><p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%9B%BE%E7%81%B5%E6%9C%BA.jpg" alt></p>
<p>定性计算</p>
<p>定量计算</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B0%BAjpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%8C%87%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%B0%B4%E5%B2%AD.jpg" alt></p>
<p>算法分析要两个方面考虑：<br>                        定性计算<br>                        定量计算</p>
<p>算法分析<br>    确定执行程序的复杂度<br>    封底估算</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92.jpg" alt></p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E9%80%92%E5%BD%92.jpg" alt></p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%88%86%E6%B2%BB.jpg" alt></p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%87%8F%E6%B2%BB.jpg" alt></p>
<h3 id="2-向量"><a href="#2-向量" class="headerlink" title="2.向量"></a>2.向量</h3><p>1.抽象数据类型（ADT）<br>    数据类型+一组操作（方法，接口）<br>2.数据结构<br>    使用ADT实现功能</p>
<p>ADT向量的操作<br>    构造与析构<br>    扩容</p>
<p>无序向量<br>    插入<br>    区间删除<br>    查找<br>    单元素删除（区间删除特例）<br>    遍历</p>
<p>有序向量<br>    排序效率可以更高<br>    查找效率可以更高</p>
<h4 id="有序向量的查找算法"><a href="#有序向量的查找算法" class="headerlink" title="有序向量的查找算法"></a>有序向量的查找算法</h4><p>有序二分查找<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%9F%A5%E6%89%BE%E6%8E%A5%E5%8F%A3.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEA.jpg" alt></p>
<p>语义定义：<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%AD%E4%B9%89%E5%AE%9A%E4%B9%89.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6%E5%88%86%E6%9E%90.jpg" alt><br>二分查找具体复杂度：1.(log2n)</p>
<p>二分查找改进版本A：<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95.jpg" alt><br>左侧查找成本更低所以使用<br>二分查找改进：用斐波拉切做分割中间点，接下来的中间分隔点都是斐波拉切形式<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%AD%E7%82%B9.jpg" alt><br>有点玄乎，不过没逻辑漏洞<br>概率确实是越来越大</p>
<p>把查找比作化区域捞鱼<br>比如你在湖里捞鱼和在河里捞鱼，捞上来的概率是一样的，或者说是不可知的。<br>但如果你在里面捞，同时记住你刚才捞过区域，那下次换一个区域再捞，概率确实更大</p>
<p>二分查找改进版本B：<br>在原版本中舍弃能在查找中间点的同时确定是否是要查找的数，实现左右递归查找的成本平衡<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACB.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACB%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p>二分查找版本C：<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACC.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACC%E5%88%86%E6%9E%90.jpg" alt></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>改进一下：每次扫描完确定最后一个，在某一次扫描碰巧扫描过都已经排序好了，直接完成排序<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BA.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BA%E5%9B%BE.jpg" alt></p>
<p>改进2：<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.jpg" alt><br>如图：某种情况下，前面一小部分有逆序，后面一大部分已经顺序，但按改进A依然得继续扫描到前面小部分位置知道前面都顺序了。<br>前面小部分虽然逆序，但通过冒泡排序进过最多r次排序就能是整个扫描区都顺序。<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%902.jpg" alt></p>
<p>在知道前面一些位置已经顺序，不再按冒泡排序的规律，直接将后面的已排序队头指向已经顺序的第一个<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%903.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9BB%E4%BB%A3%E7%A0%81.jpg" alt></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81.jpg" alt></p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%BD%92%E5%B9%B6%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt><br>归并的过程就像比武招亲，两队打擂台。</p>
<p><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0.jpg" alt><br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E5%9B%BE.jpg" alt></p>
<p>二分归并性能分析：<br><img src="/2020/02/23/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.jpg" alt></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络1.0</title>
    <url>/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/</url>
    <content><![CDATA[<h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h2><p>许多主机连接-&gt;网络<br>许多网络连接-&gt;互联网<br>做大的互联网-&gt;因特网</p>
<h4 id="因特网3部曲"><a href="#因特网3部曲" class="headerlink" title="因特网3部曲"></a>因特网3部曲</h4><pre><code>1.ARPANET向互联网发展 始于1983
2.3级结构的因特网 主干网-&gt;地区网-&gt;用户
3.多层次ISP（互联网运营商）结构互联网</code></pre><h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><pre><code>电路交换，占线
分组交换 ，不占线</code></pre><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2.jpg" alt></p>
<h4 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB.jpg" alt></p>
<h4 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h4><p>速率：连接在计算机网络上的主机在数字信道上传输数据的速率。每秒多少个位数。</p>
<p>带宽：数字信道所能传输的最高速率。</p>
<p>吞吐量：单位时间通过某个网络（所有信道）的数据量。</p>
<p>时延：<br>    发送时延：数据块长度/信道带宽<br>    传播时延：信道长度/信号在信道上的传播速率<br>    处理时延：<br>    排队时延：</p>
<h4 id="ISO七层架构"><a href="#ISO七层架构" class="headerlink" title="ISO七层架构"></a>ISO七层架构</h4><pre><code>应用层：产生网络流量或用户交互的应用程序
表示层：加密 压缩 开发人员
会话层：服务器和客户端建立会话
传输层：可靠传输建立会话
网络层：ip地址编址 选择最佳路径 差错控制 流量控制 传输管理
数据链路层：封装数据 添加物理层地址 差错控制 流量控制 传输管理
物理层：电压 接口</code></pre><h3 id="数据通信知识"><a href="#数据通信知识" class="headerlink" title="数据通信知识"></a>数据通信知识</h3><p>码元：在使用时间域的波形表示数字信号，代表不同离散数值的基本波形<br>信道：传输数据的媒介</p>
<p>数据无论是数字或模拟，为了传输必须转化为信号。<br>数字数据编码方式，即用什么表示数字信号表示1，什么表示数字信号0；<br>    不同的数据编码：<br>                二进制编码<br>                非归零码<br>                曼彻斯特编码<br>                差分曼彻斯特编码<br>                4B/5B编码                </p>
<p>基带信号：来自信源的信号。<br>带通信号：经过载波调制能发送更远。</p>
<p>调制方法：<br>调幅<br>调频<br>调相</p>
<p>波特 数据传输的速率</p>
<p>信噪比<br>    C=W log2 （1+s/n） b/s<br>    w是信道的带宽<br>    s为信道上所传信号的平均功率<br>    n为信道上的高斯噪声功率</p>
<h2 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h2><h4 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h4><p>在理想低通的信道中，极限码元传输速率为 2w baud ，w是理想低通信道的带宽，单位hz</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9%E5%AE%9A%E7%90%86%E4%BC%AA%E8%AF%81%E6%98%8E.jpg" alt></p>
<h4 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h4><p>双绞线 屏蔽双绞线 非屏蔽双绞线<br>同轴电缆<br>光纤</p>
<h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><p>频分信道复用<br>时分信道复用<br>码分信道复用<br>波分信道复用</p>
<h4 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h4><p>脉码调制PCM 模拟转数字<br>    脉冲编码调制就是把一个时间连续，取值连续的模拟信号变换成时间离散，取值离散的数字信号后在信道中传输。脉冲编码调制就是对模拟信号先抽样，再对样值幅度量化，编码的过程。</p>
<pre><code>抽样，就是对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号，抽样必须遵循奈奎斯特抽样定理。该模拟信号经过抽样后还应当包含原信号中所有信息，也就是说能无失真的恢复原模拟信号。它的抽样速率的下限是由抽样定理确定的。抽样速率采用8KHZ。
量化，就是把经过抽样得到的瞬时值将其幅度离散，即用一组规定的电平，把瞬时抽样值用最接近的电平值来表示,通常是用二进制表示。
量化误差：量化后的信号和抽样信号的差值。量化误差在接收端表现为噪声，称为量化噪声。 量化级数越多误差越小，相应的二进制码位数越多，要求传输速率越高，频带越宽。 为使量化噪声尽可能小而所需码位数又不太多，通常采用非均匀量化的方法进行量化。 非均匀量化根据幅度的不同区间来确定量化间隔，幅度小的区间量化间隔取得小，幅度大的区间量化间隔取得大。
一个模拟信号经过抽样量化后，得到已量化的脉冲幅度调制信号，它仅为有限个数值。
编码，就是用一组二进制码组来表示每一个有固定电平的量化值。然而，实际上量化是在编码过程中同时完成的，故编码过程也称为模/数变换，可记作A/D。
    奈奎斯特抽样定理：若频带宽度有限的，要从抽样信号中无失真地恢复原信号，抽样频率应大于2倍信号最高频率</code></pre><h4 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h4><p>xDSL<br>    x数字用户线：使用的是数字用户技术<br>DMT</p>
<h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h2><h4 id="数据链路层使用信道有两种类型："><a href="#数据链路层使用信道有两种类型：" class="headerlink" title="数据链路层使用信道有两种类型："></a>数据链路层使用信道有两种类型：</h4><p>1.点对点信道<br>2.广播信道 一点多</p>
<p>链路：一条点对点的物理线路段，中间没有任何其他交换节点</p>
<p>数据链路层传输的是帧</p>
<p>帧 -&gt; 帧头+帧尾+物理层地址+校验码</p>
<p>数据链路层要解决的问题：<br>1.封装成帧<br>2.透明传输（有转义字符，避免中间数据干扰）</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>1.停止等待协议<br>发送方发出一个帧，接收方接受一个帧并反馈。没有反馈发送方就等待。</p>
<p>2.滑动窗口<br>有发送窗口发送一组连续的帧，接受窗口接受一个返回一个确认信息，并向后滑动一个帧位置。发送窗口向后滑动一个帧位置，继续发送串窗口内的帧数据；如果没有接受窗口的确认，发送给窗口不能移动。<br>    停止等待协议：发送窗口和接收窗口=1；<br>    后退N帧协议：发送窗口》=1；接收窗口=1；<br>    选择重传协议：发送窗口》1；接收窗口》1；</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>1.超时重传<br>2.自动重传请求<br>    停止等待协议<br>    后退N帧协议<br>    选择重传协议</p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>CRC循环允余：只允许无差错接受，出错会要求发送方重传，而不是中间重传<br>实现可靠传输：差错检测+确认+重传机制</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%BE%AA%E7%8E%AF%E5%85%81%E4%BD%99%E8%AE%A1%E7%AE%97.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%BE%AA%E7%8E%AF%E5%85%81%E4%BD%99%E8%AE%A1%E7%AE%971.jpg" alt><br>    一、CRC校验概念</p>
<pre><code>即循环冗余校验码（Cyclic Redundancy Check），是数据通信领域中最常用的一种查错校验码，循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。其特征是信息字段和校验字段的长度可以任意选定。

二、循环冗余校验码（CRC）的基本原理

在K位信息码后再拼接R位的校验码，整个编码长度为N位，因此，这种编码也叫（N，K）码。对于一个给定的（N，K）码，可以证明存在一个最高次幂为N-K=R的多项式G(x)。根据G(x)可以生成K位信息的校验码，而G(x)叫做这个CRC码的生成多项式。
多项式的系数成为crc运算的除数*
三、生成步骤

1、将生成多项式G(X)转换成对应的二进制数。
2、将信息码左移R（R为G（X）的阶）位，相当于给对应的信息多项式M(X)*X^R。也就是添加R个0，R为多项式的最高阶数
3、用生成多项式（二进制数）对信息码做除，即：（M(X)*X^R）/G(X)得到R位的余数。
4、将余数拼到信息码左移后空出的位置，得到完整的CRC码。

注意事项：
A、生成多项式的最高位和最低位必须为1。
B、当被传送信息（CRC码）任何一位发生错误时，被生成多项式做除后应该使余数不为0。
C、不同位发生错误时，应该使余数不同。
D、对余数继续做除，应使余数循环。
E、CRC校验码位数 = 生成多项式位数 - 1。

————————————————
版权声明：本文为CSDN博主「zhangfan_lovebk」的原创文章，遵循 CC 4.0 BY-SA 版权协议。</code></pre><h4 id="如何组帧："><a href="#如何组帧：" class="headerlink" title="如何组帧："></a>如何组帧：</h4><pre><code>字符计数法：在帧头部使用一个计数字段老表明帧内字符数。
    缺点:计数字段出错，帧分界出错。

字符填充的首尾定界法：使用一些特定字符定界一个帧的开始和结束

比特填充的首尾标志法：以特定的比特流作为一帧的开始与结束。

违规编码法:一般在物理层使用，利用非传输信号格式的信号来表示一帧的开始与结束。</code></pre><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E7%BB%84%E5%B8%A7%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E7%BB%84%E5%B8%A7%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E7%BB%84%E5%B8%A7%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E7%BB%84%E5%B8%A7%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E7%BB%84%E5%B8%A7%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.jpg" alt></p>
<h3 id="点到点协议"><a href="#点到点协议" class="headerlink" title="点到点协议"></a>点到点协议</h3><p>广域网技术<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE%E5%8A%9F%E8%83%BD.jpg" alt><br>ppp协议（电话网等，一般）<br>    支持多种网络协议<br>    链路协议</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt></p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B.jpg" alt><br>ＰＰＰ连接的每一端都必须首先发送ＬＣＰ数据 包来配置和测试数据连接。在连接建立后，对等实体还有可能需要认证。<br>然后，ＰＰＰ必须发送ＮＣＰ数据包来选择一种或多种网络层协议来配置。一旦被选中的网络层协议被配置好后，该网络层的数据报就可以在链路上传送了。 链路将保持可配置的状态直到有ＬＣＰ数据包和ＮＣＰ数据包终止连接，或者由其他外部事件发生时（例如非活动时钟计时已满或网络管理人员的干涉）</p>
<p>ppp协议三个组成部分<br>1.数据链路层协议支持异步串行或同步串行介质<br>2.使用LCP链路控制协议建立维护链路连接<br>3.网络控制协议NCP允许点对点连接的多种协议<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ppp%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82.jpg" alt></p>
<h4 id="ppp实现透明传输"><a href="#ppp实现透明传输" class="headerlink" title="ppp实现透明传输"></a>ppp实现透明传输</h4><pre><code>差错处理
    零比特填充</code></pre><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>不能随意延长网线</p>
<h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><pre><code>数据发送到接收这个时间段，乘坐争用期。没有发生数据碰撞算发送成功。

时间为2t（实际为端到端往返时间）

以太网最短有效帧 64字节</code></pre><h5 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h5><pre><code>基本退避时间 2t
定义参数k
k=Min(重传次数，10)
从【0，1，...,（2的k次方-1）】随机选一个数，记为r
重传所需的延时 为 2t*r</code></pre><p>为了使数据链路层更好的适应多种局域网标准<br>局域网的数据链路层分为两个子层：<br>        逻辑链路控制LLC<br>        媒体接入控制MAC<br>以太网提供的是不可靠的服务，尽最大努力传输</p>
<h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E6%9C%80%E5%A4%A7%E5%8C%96.jpg" alt></p>
<p>mac地址<br>    前24位指定厂家<br>    mac地址接受以太网单播，多播，广播</p>
<p>交换机生成树算法<br>多个交换机互联后，通过优先级实现根交换机和生成树</p>
<h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>LAN和VLAN<br>LAN是交换机网络<br>VLAN划分LAN局域网,更小的LAN</p>
<h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h3><p>网络层应该像传输层提供什么服务？<br>1.虚电路服务<br>2.数据报服务<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.jpg" alt></p>
<p>现在互联网使用的是数据报服务<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%99%9A%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt></p>
<h4 id="网际协议-ip"><a href="#网际协议-ip" class="headerlink" title="网际协议 ip"></a>网际协议 ip</h4><p>物理层中继器：集线器转换器<br>数据链路层中继器：网桥<br>网络层中继器：路由器<br>网络层以上中继器：网关</p>
<h4 id="IP层次化"><a href="#IP层次化" class="headerlink" title="IP层次化"></a>IP层次化</h4><p>ip=网络层+主机层</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E5%85%B7%E4%BD%93.jpg" alt></p>
<p>保留的私网地址<br>    10.0.0.0<br>    172.16.0.0–172.31.0.0<br>    192.168.0.0–192.168.255.0</p>
<p>169.254.0.0 是用来表示没有分派到公网地址的主机。</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%BD%9C%E7%94%A8.jpg" alt></p>
<p>子网掩码：判断两个网址是否在同一网段</p>
<p>广播地址一般主机位全为1，例如10.255.255.255即发送给10网段的广播地址。</p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>等长子网划分<br>子网掩码把主机层位分给网络层位<br>    主机位归零，网络位做与运算<br>    主机部分不能全为1，也不能全为0</p>
<p>变长子网划分<br>判断变长子网的主机的网段，主机位归零，网络位做与运算，<br>在定长子网划分的基础下：<br>/num<br>num是划分主机个数的</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E5%AE%9A%E9%95%BF%E4%B8%8E%E5%8F%98%E9%95%BF%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.jpg" alt></p>
<p>超网<br>合并同一物理层上的网段<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E8%B6%85%E7%BD%91.jpg" alt></p>
<h4 id="ip与mac"><a href="#ip与mac" class="headerlink" title="ip与mac"></a>ip与mac</h4><p>ip地址：决定目标地址<br>mac地址：决定下一跳</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/%E4%BC%A0%E8%BE%93%E6%97%B6ip%E4%B8%8Emac.jpg" alt></p>
<p>两个计算机跨网段通信，在网络层是透明的，数据链路层不断更改mac地址，传输数据帧</p>
<h4 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h4><p>arp广播询问主机ip地址</p>
<p>arp欺骗：利用arp 修改ip地址对应的mac地址，实现截获发送给该ip地址的数据包。</p>
<h4 id="rarp-逆向arp协议"><a href="#rarp-逆向arp协议" class="headerlink" title="rarp 逆向arp协议"></a>rarp 逆向arp协议</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/rarp.jpg" alt></p>
<p>偏移量：字节数除以8的偏移量，代表关于8个字节的偏移量为多少。</p>
<p>路由：<br>沿途路由器必须知道到目标网络的下一跳给哪个接口<br>默认路由 0.0.0.0 就是网关</p>
<p>网关的目的确定一条指定的路线</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/icmp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/icmp%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.jpg" alt></p>
<h4 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h4><p>RIP：动态路由协议，周期性广播30秒，最大跳数16,内部网关协议，每个路由器都得维护自己到其他相邻每个目的网络的距离记录。<br>OPSF：内部网关协议，触发式更新，支持多区域，开放式，内部网关协议<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/ospf.jpg" alt></p>
<p>BGP：边界网关协议，外部网关协议的一种</p>
<h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>访问远程服务器，远程服务器分配私网地址，让其访问<br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/vpn.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/vpn%E7%AA%97%E5%8F%A3.jpg" alt></p>
<h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>通过公有网络时，把私有网址转换为公有网络地址。</p>
<p>PAT 端口地址转换<br>    外网的人访问内网的web服务器端口，使用PAT,</p>
<p>应用层准备数据-&gt;传输层分块数据-&gt;网络层打包数据(发片)-&gt;数据链路层封装成帧</p>
<p>ip协议：<br>rip：（动态路由协议）周期性广播路由表，<br>ospf</p>
<h3 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h3><p>TCP:可靠传输，传输的文件需要分段，建立会话<br>UDP：不需要会话，不分段，不可靠传输 例如：多播，广播</p>
<p>负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。<br>    复用，就是多个应用层进程可同时使用下面运输层的服务。<br>    分用，就是把收到的信息分别交付给上面应用层中相应的进程。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E6%8A%A5%E6%96%87.jpg" alt><br>URG: 标识紧急指针是否有效<br>ACK: 标识确认序号是否有效<br>PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走<br>RST: 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段<br>SYN: 请求建立连接. 我们把含有SYN标识的报文称为同步报文段<br>FIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E6%96%87%E5%AD%97.jpg" alt><br><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E4%B8%A2%E5%A4%B1%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>tcp协议功能：可靠传输，流量控制，拥塞控制</p>
<p>可靠传输：停止等待协议（特色：自动超时重传）</p>
<p>拥塞控制<br>tcp超时重传：<br>tcp允余确认：通过重复3次发送失序之前的前一个允余ack来确认报文段之后的报文段丢失。</p>
<p><img src="/2020/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/tcp%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.jpg" alt></p>
<p>netstat 查看会话</p>
<p>-an 查看侦听端口</p>
<p>提供进程中间联系</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习3</title>
    <url>/2020/02/02/Mybatis%E5%AD%A6%E4%B9%A03/</url>
    <content><![CDATA[<p>1.mybatis的curd（基于代理dao的方式）<br>2.mybatis的参数深入及结果集的深入<br>3.mybatis种基于传统dao方式<br>4.mybatis中配置（主配置文件）<br>    properties标签<br>    typeAliases标签</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>java笔记2</title>
    <url>/2020/02/01/java%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>this关键字：<br>    1.代表对象<br>    2.调用对象构造</p>
<p>垃圾回收机制：<br>fn：不一定销毁类的存储</p>
<p>java复用类<br>    1.组合复用<br>    2.继承复用</p>
<p>类被当作字符串输出时，调用tostring()；</p>
<p>静态方法不具备多态性</p>
<p>java单继承</p>
<p>多继承是接口；</p>
<p>实现类+已有类+接口；<br>接口=不实现方法+静态，最终变量；</p>
<p>stringbld 可变字符串</p>
<p>java类型信息</p>
<p>类型<br>每一个类都是class的一个对象；</p>
<p>反射：java能获得不知道的类的结构和方法（运行时）</p>
<p>限定类名，就是类名全称，带包路径的用点隔开，例如: java.lang.String。<br>非限定(non-qualified)类名也叫短名，就是我们平时说的类名，不带包的，例如：String。</p>
<h3 id="类全名、二进制名、全限定名是一个东西。"><a href="#类全名、二进制名、全限定名是一个东西。" class="headerlink" title="类全名、二进制名、全限定名是一个东西。"></a>类全名、二进制名、全限定名是一个东西。</h3><p>类全名：java.lang.Thread（用于日常的沟通表达）<br>二进制名：java.lang.Thread（Java 语言规范中的定义）<br>全限定名：java/lang/Thread（class 文件结构中的二进制名格式，在描述符中使用，只有非数组引用类型有）</p>
<p>由于历史原因，class 文件结构中的二进制名格式，跟 java 语言规范中定义的二进制名格式有所不同。</p>
<p>Java 语言规范中定义的二进制名格式，使用 . 作为分隔符。<br>class 文件结构中的二进制名格式，使用 / 作为分隔符。</p>
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>分为字段描述符、方法描述符。<br>字段描述符，其实就是类型描述符，分为原始类型描述符、非数组引用类型描述符、数组引用类型描述符。</p>
<p>原始类型描述符：C、D、F、I、J、S、Z<br>非数组引用类型描述符：L全限定名;<br>数组引用类型描述符：[自己元素类型的描述符<br>如：<br>int 的描述符：I<br>Thread 的描述符：Ljava/lang/Thread;<br>Thread[][][] 的描述符：[[[Ljava/lang/Thread;（是几维数组，就有几个 [）</p>
<h3 id="JAVA的JVM的内存可分为3个区：堆-heap-、栈-stack-和方法区-method"><a href="#JAVA的JVM的内存可分为3个区：堆-heap-、栈-stack-和方法区-method" class="headerlink" title="JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)"></a>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</h3><p>堆区:<br>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)<br>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身<br>栈区:<br>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中<br>2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。<br>方法区:<br>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>
<p><img src="/2020/02/01/java%E5%9F%BA%E7%A1%802/jvm%E8%BF%90%E8%A1%8C%E6%97%B6.ng" alt></p>
<p>一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。<br>接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：<br>Sample test1=new Sample(“测试1”);<br>语句很简单啦，就是让java虚拟机创建一个Sample实例，并且呢，使引用变量test1引用这个实例。貌似小case一桩哦，就让我们来跟踪一下Java虚拟机，看看它究竟是怎么来执行这个任务的：<br>1、 Java虚拟机一看，不就是建立一个Sample实例吗，简单，于是就直奔方法区而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到@@， 这会儿的方法区里还没有Sample类呢。可Java虚拟机也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的类型信息存放在方法区里。<br>2、 好啦，资料找到了，下面就开始干活啦。Java虚拟机做的第一件事情就是在堆区中为一个新的Sample实例分配内存, 这个Sample实例持有着指向方法区的Sample类的类型信息的引用。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址， 其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample实例的数据区里。<br>3、 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方 法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位 于“=”前的Test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，它被会添加到了执行main()方法的主线程的JAVA方 法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，它持有指向Sample实例的引用。<br>OK，到这里为止呢，JAVA虚拟机就完成了这个简单语句的执行任务。参考我们的行动向导图，我们终于初步摸清了JAVA虚拟机的一点点底细了，COOL！<br>接下来，JAVA虚拟机将继续执行后续指令，在堆区里继续创建另一个Sample实例，然后依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample 实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令。</p>
<p>c 控制反转：解决程序合<br>依赖注入：依赖关系的维护由来</p>
<p>接口与抽象类的关系<br>        No.    区别点        抽象类                                    接口<br>        1    定义            包含一个抽象方法的类                        抽象方法和全局常量的集合<br>        2    组成            构造方法、抽象方法、普通方法、常量、变量        常量、抽象方法<br>        3    使用            子类继承抽象类(extends)                    子类实现接口(implements)<br>        4    关系            抽象类可以实现多个接口                    接口不能继承抽象类，但允许继承多个接口<br>        5    常见            设计模式    模板设计                            工厂设计、代理设计<br>        6    对象                    都通过对象的多态性产生实例化对象<br>        7    局限            抽象类有单继承的局限                        接口没有此局限<br>        8    实际            作为一个模板                                是作为一个标准或是表示一种能力<br>        9    选择                    如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限<br>        10    特殊                    一个抽象类中可以包含多个接口，一个接口中可以包含多个抽象类<br>————————————————</p>
<h4 id="java关键字-transient-和-持久化serialization"><a href="#java关键字-transient-和-持久化serialization" class="headerlink" title="java关键字 transient 和 持久化serialization"></a>java关键字 transient 和 持久化serialization</h4><p>transient：<br>Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。<br>当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的</p>
<p>serialization：</p>
<p>序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个储存媒介，例如档案或记忆体缓冲等，在网络传输过程中，可以是字节或者XML等格式；而字节或者XML格式的可以还原成与原来完全相等的对象，这个相反的过程又称为反序列化。<br>Java提供一种机制叫做序列化，通过有序的格式或者字节序列持久化java对象，其中包含对象的数据，还有对象的类型，和保存在对象中的数据类型。</p>
<p>在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失；</p>
<p>但是在真实的应用场景中，我们需要将这些对象持久化下来，并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能。</p>
<p>对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存未字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换。<br>java类通过实现java.io.Serialization接口来启用序列化功能，未实现此接口的类将无法将其任何状态或者信息进行序列化或者反序列化。可序列化类的所有子类型都是可以序列化的。序列化接口没有方法或者字段，仅用于标识可序列化的语义。<br>当试图对一个对象进行序列化时，如果遇到一个没有实现java.io.Serialization接口的对象时，将抛出NotSerializationException异常。</p>
<p>如果你需要序列化任何类，那么你必须实现 Serializable 接口 ，这个接口是标记接口（marker interface）。Java中的标记接口就是一个没有任何字段或者方法的接口，简单的来说，java中把空接口叫做标记接口（marker interface）</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？<br>顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），<br>然后在使用/调用时传入具体的类型（类型实参）。<br>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，<br>操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<p>####其中通配符(?)<br>当赋值的类型不确定的时候，我们用通配符(?)代替了：</p>
<p>如<br>  List&lt;?&gt; unknownList;<br>  List&lt;? extends Number&gt; unknownNumberList;<br>  List&lt;? super Integer&gt; unknownBaseLineIntgerList;<br>在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素， 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis学习(2)</title>
    <url>/2020/02/01/Mybatis%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<p>自定义的mybatis通过例.1看到的类</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>爱情公寓观感</title>
    <url>/2020/01/31/%E7%88%B1%E6%83%85%E5%85%AC%E5%AF%93%E8%A7%82%E6%84%9F/</url>
    <content><![CDATA[<p>大力大力你真棒</p>
<h3 id="大力的模拟家庭实验"><a href="#大力的模拟家庭实验" class="headerlink" title="大力的模拟家庭实验"></a>大力的模拟家庭实验</h3><pre><code>财务计划：总资产 -固定投资-日常开销-应急备用
        总资产的70%作备用金，投资金。
        剩下是使用金。</code></pre><h3 id="大力的知识储存"><a href="#大力的知识储存" class="headerlink" title="大力的知识储存"></a>大力的知识储存</h3><pre><code>喷嚏传播的速度是120公里每秒，2秒能传播整个房间。
感冒在痊愈前传染更强。

量子纠缠，量子描述物质或物质量的最小单位，量子纠缠描述的是两个物质不论距离多远，一方变化都会影响另一方，爱因斯坦称之为诡异的互动性</code></pre><p>(1-COSt)/SINt = SINt/(1+COSt)</p>
<p>两个看似不同的表现但实质上是同一个东西。</p>
<p>新冠性病毒已经持续了4个月了，今天我挂掉了科目二，为了做一些形式上的自我惩罚，我选择去找个工厂干一干，我。发现了一个制造口罩的零时工工作，12小时制</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlap学习</title>
    <url>/2020/01/31/Matlap%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>矩阵处理<br>科学计算</p>
<h2 id="专题预览"><a href="#专题预览" class="headerlink" title="专题预览"></a>专题预览</h2><p>专题一： matlap基础知识<br>专题二： matlap矩阵处理<br>专题三： matlap程序流程控制<br>专题四： matlap绘图<br>专题五： 数据分析和多项式计算<br>专题六： 数值微积分与方程求解<br>专题七： matlap符号计算<br>专题八： matlap图形用户界面<br>专题九： simulink系统仿真<br>专题十： 外部程序接口</p>
<h3 id="专题一：-matlap基础知识"><a href="#专题一：-matlap基础知识" class="headerlink" title="专题一： matlap基础知识"></a>专题一： matlap基础知识</h3><p>… //续行符</p>
<p><img src="/2020/01/31/Matlap%E5%AD%A6%E4%B9%A0/matlap%E7%95%8C%E9%9D%A2.png" alt></p>
<h4 id="数值数据类型分类"><a href="#数值数据类型分类" class="headerlink" title="数值数据类型分类"></a>数值数据类型分类</h4><pre><code>整型，浮点型，复数型

format 只改变数据输出形式，不改变存储和计算。

函数的调用格式: 函数名（参数）

常用函数的应用
    &gt;&gt;sin()

    &gt;&gt;abs(-4) //绝对值，复数的模，字符串deascll值

    &gt;&gt;round（）四舍五入取整

    //求1到100之间的所有素数
    &gt;&gt; x=1:100
    &gt;&gt; k=isprime(x)
    &gt;&gt; k1=find(k)
    &gt;&gt; p=x(k1)</code></pre><h4 id="变量及其操作"><a href="#变量及其操作" class="headerlink" title="变量及其操作"></a>变量及其操作</h4><pre><code>变量是内存单元的一个抽象。以字母开头区分大小写。
标准函数名必须小写。

赋值语句
    变量=表达式
    表达式</code></pre><p>who ,whos 输出所有变量</p>
<h4 id="内存变量文件"><a href="#内存变量文件" class="headerlink" title="内存变量文件"></a>内存变量文件</h4><p>save ，创建内存变量文件<br>load，</p>
<h4 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h4><pre><code>基本数据对象
建立矩阵
1.直接输入法
    A=[1,2,3;4,5,6,;7,8,9]
2.利用要建立好的矩阵建立更好的矩阵。
    A=[1,2,3]
    B=[4,5,6]
    C=[A,B;B,A]</code></pre>]]></content>
      <categories>
        <category>生活</category>
        <category>matlap</category>
      </categories>
      <tags>
        <tag>matlap</tag>
      </tags>
  </entry>
  <entry>
    <title>Bye Kobe</title>
    <url>/2020/01/28/bye-kobe/</url>
    <content><![CDATA[<h3 id="“what-can-i-say-“-“曼巴out！”"><a href="#“what-can-i-say-“-“曼巴out！”" class="headerlink" title="“what can i say “ “曼巴out！”"></a>“what can i say “ “曼巴out！”</h3><p>  2020年1月27日，清晨6点多，我无意间看到QQ上推送的新闻，科比在凌晨时分不幸去世，<br>根据新闻上说的，是科比乘坐的直升飞机遇上大雾天气，坠机身亡，当时直升机上还有几个人，其中他的二女儿也在上面，也不幸去世。<br>  我能说什么？正如你在退役上说的一样。命运发生在你身上的，历史要你背负的，人生你必须经历的，从来都不会和你商量。<br>我能说什么？只有遗憾，无法看到你将你对篮球近乎信仰的执着继续传递到你接下来的人生之中，它一定也如同你在nba上一样美好。<br>无可奈何花落去，世事发生在你的身上却是残忍的，所以我不愿相信你的离去。虽然你已经离开，但在我的心中，你一定在其他地方活的会同样精彩，无论发生什么都不会磨灭你在nba的光辉岁月。</p>
<p><img src="/2020/01/28/bye-kobe/kobe01.jpg" alt></p>
<p>科比是高中毕业进入NBA，加入湖人队的，在1996－1997年，科比进入NBA的第一个赛季的最后一场比赛，湖人对战爵士队，最后关头，刚入NBA的科比在最后关键时刻投丢了三个关键三分球，输了比赛。</p>
<p>科比初入NBA并不顺利，但从他最后投出的三颗球中足以看出他的孤傲。任何一名球员，在最关键的时候，有胆量投丢一颗球，却绝对没有胆量投丢三颗球，但是科比敢，这也让他最终成长为了NBA最出名的关键先生。就连和他搭档的奥尼尔也不得不佩服他的大心脏。</p>
<p><img src="/2020/01/28/bye-kobe/kb02.jpg" alt></p>
<p>从进入NBA开始，科比总共征战了20个赛季，而且二十年都在一座城市，真正的一人一城。8号到24号，黑曼巴到关键先生，这就是科比整个篮球生涯的写照，一人五冠，虽然比不了乔丹的六冠，但却足以笑傲NBA。</p>
<p>科比刚刚进入NBA的时候，他场均得分只有7.6分，而经过一个赛季之后，场均15.4分，成倍的增长，没有足够多的汗水，绝对不能成就。</p>
<p>很多人都说科比是21世纪以来最伟大的篮球运动员，但却很少有人知道他伟大在哪里？21世纪初的NBA正是球星井喷的一段时期，艾弗森未老，马刺三驾马车刚刚套好，76人、马刺、开拓者都是当时的强队，一个比赛冠军的含金量高不高看的不是自己，而是对手，对手越强劲，冠军的含金量就越高。</p>
<p><img src="/2020/01/28/bye-kobe/kobe05.jpg" alt></p>
<p>2000－2002年，科比率队拿到了三座总冠军奖杯，2009年－2010年科比再次率队拿下了两座总冠军奖杯。这是他的成绩，期间多次获得MVP，进入全明星首发。这是科比伟大的理由，但却不仅仅是他数据的优秀。</p>
<p>科比职业生涯荣获2次奥运会冠军，带领湖人队5夺NBA总冠军，荣膺1次常规赛MVP，2次总决赛MVP，4次全明星赛MVP，共18次入选NBA全明星阵容，15次入选NBA最佳阵容，12次入选NBA最佳防守阵容……</p>
<p><img src="/2020/01/28/bye-kobe/kobe04.jpg" alt></p>
<p>2×奥运会金牌</p>
<pre><code>2012 2008</code></pre><p>5×总冠军</p>
<pre><code>2009-10 2008-09

2001-02 2000-01 1999-00</code></pre><p>2×总决赛MVP</p>
<pre><code>2009-10 2008-09</code></pre><p>1×常规赛MVP</p>
<pre><code>2007-08</code></pre><p>4×全明星MVP</p>
<pre><code>2010-11 2008-09 2006-07 2001-02</code></pre><p>2×得分王</p>
<pre><code>2006-07 2005-06</code></pre><p>32×周最佳球员</p>
<pre><code>2013年04月08日 2013年03月04日

2013年02月19日 2012年01月09日

2012年01月02日 2009年12月28日

2009年12月21日 2009年11月23日

2009年03月16日 2009年01月12日

2008年12月29日 2008年04月06日

2008年03月02日 2008年01月13日

2007年03月25日 2007年03月18日

2006年04月16日 2006年01月22日

2005年12月26日 2005年12月19日

2005年11月07日 2004年03月29日

2004年02月22日 2003年02月23日

2003年02月02日 2003年01月12日

2002年12月08日 2002年11月03日

2002年01月20日 2001年11月04日

2000年12月24日 2000年04月17日</code></pre><p>17×月最佳球员</p>
<pre><code>2013年02月 2012年01月 2011年03月

2009年12月 2009年01月 2008年12月

2008年04月 2008年02月 2007年04月

2007年03月 2006年12月 2006年04月

2006年01月 2004年03月 2003年01月

2001年11月 2000年12月 </code></pre><p>11×最佳阵容第一阵容</p>
<pre><code>2012-13 2011-12 2010-11 2009-10

2008-09 2007-08 2006-07 2005-06

2003-04 2002-03 2001-02 </code></pre><p>2×最佳阵容第二阵容</p>
<pre><code>2000-01 1999-00</code></pre><p>2×最佳阵容第三阵容</p>
<pre><code>2004-05 1998-99</code></pre><p>9×最佳防守阵容第一阵容</p>
<pre><code>2010-11 2009-10 2008-09

2007-08 2006-07 2005-06

2003-04 2002-03 1999-00 </code></pre><p>3×最佳防守阵容第二阵容</p>
<pre><code>2011-12 2001-02 2000-01</code></pre><p>1×最佳新秀阵容第二阵容</p>
<pre><code>1996-97   </code></pre><p>1×全明星扣篮大赛冠军 </p>
<pre><code>1996-97</code></pre><p>18×全明星 </p>
<pre><code>2015-16 2014-15 2013-14 2012-13

2011-12 2010-11 2009-10 2008-09

2007-08 2006-07 2005-06 2004-05

2003-04 2002-03 2001-02 2000-01

1999-00 1997-98


                 你不负众望，携目光乘风飞翔，背身，后仰，大灌篮
                 你放手离开，挥手臂背离灯光，小飞侠，曼巴，科比
                                                        --致敬    科比.布莱恩特以及他美丽的二女儿Gigi</code></pre><p><img src="/2020/01/28/bye-kobe/kobe03.jpg" alt></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
